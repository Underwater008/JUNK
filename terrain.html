<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Terrain Grid Visualization</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200');

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #f5f7fa 0%, #e8eaf6 50%, #f3e5f5 100%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 10;
        }
        #info img {
            height: 40px;
            display: block;
            filter: brightness(0);
            opacity: 0.9;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6b4ce6;
            font-size: 20px;
            font-weight: 400;
            letter-spacing: 1px;
            z-index: 5;
        }
        #color-picker {
            position: absolute;
            left: 30px;
            bottom: 30px;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            padding: 24px;
            color: #1a1a1a;
            font-size: 14px;
            min-width: 260px;
            z-index: 10;
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #color-picker.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        #color-picker h3 {
            margin: 0 0 16px 0;
            font-size: 16px;
            font-weight: 600;
            color: #1a1a1a;
        }
        .picker-group {
            margin-bottom: 16px;
        }
        .picker-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #4a4a4a;
            font-size: 13px;
        }
        .picker-group input[type="text"] {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            color: #1a1a1a;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }
        .picker-group input[type="text"]:focus {
            outline: none;
            border-color: #6b4ce6;
        }
        .cube-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            color: #1a1a1a;
            white-space: nowrap;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transform: translate(-50%, -100%);
            margin-top: -8px;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .cube-label .material-symbols-outlined {
            font-size: 16px;
            font-variation-settings: 'FILL' 1, 'wght' 500, 'GRAD' 0, 'opsz' 20;
        }
        .picker-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            color: #1a1a1a;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }
        .picker-group select:focus {
            outline: none;
            border-color: #6b4ce6;
        }
        .picker-group select option {
            padding: 8px;
        }
        .color-swatches {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 100%;
        }
        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border: 3px solid transparent;
            position: relative;
            box-sizing: border-box;
        }
        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .color-swatch.selected {
            border-color: #1a1a1a;
            transform: scale(1.05);
        }
        .color-swatch.original {
            background: linear-gradient(135deg, #e0e0e0 0%, #f5f5f5 100%);
            position: relative;
        }
        .color-swatch.original::after {
            content: '‚Üª';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #666;
        }
        #notification {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            padding: 12px 20px;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }
        #notification.visible {
            opacity: 1;
        }
        #notification .icon {
            font-size: 20px;
            line-height: 1;
        }
        #notification.success .icon {
            color: #4caf50;
        }
        #notification.error .icon {
            color: #f44336;
        }
        #notification .message {
            font-size: 13px;
            font-weight: 500;
            color: #1a1a1a;
        }
        #signature {
            position: absolute;
            bottom: 30px;
            left: 30px;
            z-index: 10;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        #signature:hover {
            opacity: 1;
        }
        #signature a {
            display: block;
            text-decoration: none;
        }
        #signature img {
            height: 50px;
            display: block;
        }
        #controls {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            padding: 20px;
            color: #1a1a1a;
            font-size: 13px;
            min-width: 220px;
            z-index: 10;
            display: none;
        }
        #controls h3 {
            margin: 0 0 15px 0;
            font-size: 15px;
            font-weight: 600;
            text-align: center;
            color: #6b4ce6;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #4a4a4a;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .control-group input[type="number"] {
            width: 70px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            color: #1a1a1a;
            padding: 4px 8px;
        }
    </style>
</head>
<body>
    <div id="info">
        <img src="junk-logo.png" alt="JUNK">
    </div>
    <div id="loading">Loading...</div>

    <div id="color-picker">
        <h3>Customize Cube</h3>
        <div class="picker-group">
            <label>Icon Preset</label>
            <select id="cube-icon">
                <option value="">None</option>
                <option value="electric_bolt">‚ö° Power Station</option>
                <option value="local_hospital">üè• Hospital</option>
                <option value="school">üè´ School</option>
                <option value="account_balance">üèõÔ∏è Government</option>
                <option value="radio">üìª Radio Station</option>
                <option value="anchor">‚öì Port</option>
                <option value="factory">üè≠ Factory</option>
                <option value="agriculture">üåæ Farm</option>
                <option value="water_drop">üíß Water</option>
                <option value="home">üè† Residential</option>
                <option value="store">üè™ Market</option>
                <option value="local_fire_department">üöí Fire Station</option>
                <option value="local_police">üöì Police</option>
                <option value="flight">‚úàÔ∏è Airport</option>
                <option value="warehouse">üì¶ Warehouse</option>
            </select>
        </div>
        <div class="picker-group">
            <label>Custom Icon <a href="https://fonts.google.com/icons" target="_blank" style="font-size: 11px; color: #6b4ce6; text-decoration: none;">(browse)</a></label>
            <input type="text" id="cube-icon-custom" placeholder="e.g., restaurant, build, star...">
        </div>
        <div class="picker-group">
            <label>Label</label>
            <input type="text" id="cube-label" placeholder="Enter name..." maxlength="20">
        </div>
        <div class="color-swatches">
            <div class="color-swatch original" data-color="original" title="Original"></div>
            <div class="color-swatch" data-color="#5CCBD4" style="background: #5CCBD4;" title="Cyan"></div>
            <div class="color-swatch" data-color="#C855D8" style="background: #C855D8;" title="Magenta"></div>
            <div class="color-swatch" data-color="#4A8EC2" style="background: #4A8EC2;" title="Blue"></div>
            <div class="color-swatch" data-color="#6B4CE6" style="background: #6B4CE6;" title="Purple"></div>
            <div class="color-swatch" data-color="#F4C2C2" style="background: #F4C2C2;" title="Pink"></div>
            <div class="color-swatch" data-color="#A64D79" style="background: #A64D79;" title="Burgundy"></div>
            <div class="color-swatch" data-color="#5ABF8C" style="background: #5ABF8C;" title="Green"></div>
            <div class="color-swatch" data-color="#F4D35E" style="background: #F4D35E;" title="Yellow"></div>
        </div>
    </div>

    <div id="notification">
        <div class="icon">‚úì</div>
        <div class="message">Saved successfully!</div>
    </div>

    <div id="controls">
        <h3>CAMERA CONTROLS</h3>
        <div class="control-group">
            <label>FOV: <span id="fov-value">30</span></label>
            <input type="range" id="fov" min="30" max="120" value="30" step="1">
        </div>
        <div class="control-group">
            <label>Position Y: <span id="pos-y-value">260</span></label>
            <input type="range" id="pos-y" min="10" max="320" value="260" step="1">
        </div>
        <div class="control-group">
            <label>Position X: <span id="pos-x-value">80</span></label>
            <input type="range" id="pos-x" min="-200" max="200" value="80" step="1">
        </div>
        <div class="control-group">
            <label>Position Z: <span id="pos-z-value">80</span></label>
            <input type="range" id="pos-z" min="-200" max="200" value="80" step="1">
        </div>
        <div class="control-group">
            <label>Height Scale: <span id="height-value">7</span></label>
            <input type="range" id="height-scale" min="5" max="100" value="7" step="1">
        </div>
        <div class="control-group">
            <label>Sea Threshold: <span id="sea-threshold-value">0.07</span></label>
            <input type="range" id="sea-threshold" min="0" max="0.5" value="0.07" step="0.01">
            <input type="number" id="sea-threshold-input" min="0" max="0.5" value="0.07" step="0.001">
        </div>
        <div class="control-group">
            <label>Sea Level Height: <span id="sea-height-value">1.00</span></label>
            <input type="range" id="sea-height" min="0.1" max="10" value="1.0" step="0.01">
            <input type="number" id="sea-height-input" min="0.1" max="10" value="1.0" step="0.01">
        </div>
        <div class="control-group">
            <label>Material Rotation: <span id="mat-rotation-value">180</span>¬∞</label>
            <input type="range" id="mat-rotation" min="-180" max="180" value="180" step="1">
        </div>
        <div class="control-group">
            <label><input type="checkbox" id="mat-flip-u"> Flip U</label>
            <label style="margin-left:10px;"><input type="checkbox" id="mat-flip-v" checked> Flip V</label>
        </div>
    </div>

    <div id="signature">
        <a href="mailto:1@xiao.studio">
            <img src="Assets/images/Xiao_Sign.png" alt="Xiao">
        </a>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // JSONBin configuration
        const JSONBIN_BIN_ID = '68e0256043b1c97be95965b9';
        const JSONBIN_API_KEY = '$2a$10$IcHy/if.465WYHfVCaX0WOrS.zvgk8DinfdOFdHuUoCZLt7YTP4RS';
        const JSONBIN_URL = `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`;

        let scene, camera, renderer, controls, labelRenderer;
        let instancedMesh;
        let cubeData = [];
        let animationStartTime = 0;
        let cameraMixer = null;
        let cameraAction = null;
        let cameraIntroPlaying = false;
        let posXSlider = null;
        let posXValueDisplay = null;
        let posYSlider = null;
        let posYValueDisplay = null;
        // Mouse interaction
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let mouseDownPos = new THREE.Vector2();
        let isDragging = false;
        let hoveredCubeIndex = -1;
        let previousHoveredIndex = -1;
        let selectedCubeIndex = -1;
        let isOrbiting = false;
        let orbitAngle = 0;
        let cameraTransitioning = false;
        let cameraTransitionProgress = 0;
        let savedCameraPos = null;
        let savedControlsTarget = null;
        let cubeEditChanged = false;
        let initialCubeState = null;
        let lastSaveTime = 0;
        // Mobile detection
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        // Post-processing
        let composer;
        // Material map data for land coloring
        let matImageData = null;
        let matW = 0;
        let matH = 0;
        let flipMaterialU = true;  // allow horizontal flip
        let flipMaterialV = true;  // vertical flip (image origin alignment)
        let matRotationDeg = 180; // rotation around material center (default sweet spot)
        const clock = new THREE.Clock();
        let heightScale = 7;
        const gridGap = 1.0;
        const cubeSize = 1.0;
        const sampleRate = 4; // Sample every Nth pixel (128x128 = 16k instances)
        let seaThreshold = 0.07; // Grayscale cutoff: <= is ocean (default sweet spot)
        let seaFlatHeight = 1.0; // Flat column height for ocean

        const cameraStartPos = { x: 80, y: 260, z: 80 };
        const cameraEndPos = { x: 80, y: 140, z: 140 };

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f7fa);

            // Camera - start at high position for entrance animation
            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Label renderer
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            // Post-processing setup (no bloom)
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2;

            // Mouse events
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);

            // Lighting - soft and ambient for clean look
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0xb8a5ff, 0.8, 200);
            pointLight1.position.set(50, 40, 0);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffc4e1, 0.8, 200);
            pointLight2.position.set(-50, 40, 0);
            scene.add(pointLight2);

            // Setup control panel
            setupControls();

            // Load heightmap
            loadHeightmap();
        }

        function setupControls() {
            // FOV control
            const fovSlider = document.getElementById('fov');
            const fovValue = document.getElementById('fov-value');
            fovSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.fov = value;
                camera.updateProjectionMatrix();
                fovValue.textContent = value;
            });

            // Position Y control
            posYSlider = document.getElementById('pos-y');
            posYValueDisplay = document.getElementById('pos-y-value');
            posYSlider.value = camera.position.y;
            posYValueDisplay.textContent = Math.round(camera.position.y);
            posYSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.y = value;
                posYValueDisplay.textContent = value;
            });

            // Position X control
            posXSlider = document.getElementById('pos-x');
            posXValueDisplay = document.getElementById('pos-x-value');
            posXSlider.value = camera.position.x;
            posXValueDisplay.textContent = Math.round(camera.position.x);
            posXSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.x = value;
                posXValueDisplay.textContent = value;
            });

            // Position Z control
            const posZSlider = document.getElementById('pos-z');
            const posZValue = document.getElementById('pos-z-value');
            posZSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.z = value;
                posZValue.textContent = value;
            });

            // Height scale control (live update land cube heights)
            const heightSlider = document.getElementById('height-scale');
            const heightValue = document.getElementById('height-value');
            heightSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                heightScale = value;
                heightValue.textContent = value;
                applyHeightScale();
            });

            // Sea threshold control (live recolor + flatten ocean)
            const seaSlider = document.getElementById('sea-threshold');
            const seaValue = document.getElementById('sea-threshold-value');
            const seaInput = document.getElementById('sea-threshold-input');
            const clampSea = (v) => Math.max(parseFloat(seaSlider.min), Math.min(parseFloat(seaSlider.max), v));

            const syncSeaUI = (v) => {
                const vv = clampSea(v);
                seaSlider.value = vv;
                seaInput.value = vv;
                seaValue.textContent = parseFloat(vv).toFixed(2);
            };

            syncSeaUI(seaThreshold);

            seaSlider.addEventListener('input', (e) => {
                const value = clampSea(parseFloat(e.target.value));
                seaThreshold = value;
                seaValue.textContent = value.toFixed(2);
                seaInput.value = value;
                applySeaThreshold();
            });

            seaInput.addEventListener('input', (e) => {
                const raw = parseFloat(e.target.value);
                if (isNaN(raw)) return;
                const value = clampSea(raw);
                seaThreshold = value;
                seaSlider.value = value;
                seaValue.textContent = value.toFixed(2);
                applySeaThreshold();
            });

            // Sea level height control (live update ocean flat height)
            const seaHeightSlider = document.getElementById('sea-height');
            const seaHeightInput = document.getElementById('sea-height-input');
            const seaHeightValue = document.getElementById('sea-height-value');
            const clampSeaHeight = (v) => Math.max(parseFloat(seaHeightSlider.min), Math.min(parseFloat(seaHeightSlider.max), v));

            const syncSeaHeightUI = (v) => {
                const vv = clampSeaHeight(v);
                seaHeightSlider.value = vv;
                seaHeightInput.value = vv;
                seaHeightValue.textContent = parseFloat(vv).toFixed(2);
            };

            syncSeaHeightUI(seaFlatHeight);

            const applySeaHeight = (value) => {
                seaFlatHeight = value;
                applySeaThreshold();
            };

            seaHeightSlider.addEventListener('input', (e) => {
                const value = clampSeaHeight(parseFloat(e.target.value));
                syncSeaHeightUI(value);
                applySeaHeight(value);
            });
            seaHeightInput.addEventListener('input', (e) => {
                const raw = parseFloat(e.target.value);
                if (isNaN(raw)) return;
                const value = clampSeaHeight(raw);
                syncSeaHeightUI(value);
                applySeaHeight(value);
            });

            // Material rotation slider
            const matRotSlider = document.getElementById('mat-rotation');
            const matRotValue = document.getElementById('mat-rotation-value');
            matRotSlider.value = matRotationDeg;
            matRotValue.textContent = Math.round(matRotationDeg);
            matRotSlider.addEventListener('input', (e) => {
                matRotationDeg = parseFloat(e.target.value) || 0;
                matRotValue.textContent = Math.round(matRotationDeg);
                applySeaThreshold();
            });

            // Material flip toggles
            const flipUEl = document.getElementById('mat-flip-u');
            const flipVEl = document.getElementById('mat-flip-v');
            flipUEl.checked = !!flipMaterialU;
            flipVEl.checked = !!flipMaterialV;
            flipUEl.addEventListener('change', (e) => {
                flipMaterialU = !!e.target.checked;
                applySeaThreshold();
            });
            flipVEl.addEventListener('change', (e) => {
                flipMaterialV = !!e.target.checked;
                applySeaThreshold();
            });
        }

        function loadTexturePromise(url) {
            return new Promise((resolve, reject) => {
                new THREE.TextureLoader().load(url, resolve, undefined, reject);
            });
        }

        function getImageDataFromTexture(tex) {
            const img = tex.image;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            return { data: imageData.data, width: canvas.width, height: canvas.height };
        }

        function loadHeightmap() {
            console.log('Loading maps...');
            Promise.all([
                loadTexturePromise('TerrainFromWorldBuilder4.png'),
                loadTexturePromise('Terrain/Islands_MaterialForBlender.jpg')
            ]).then(async ([heightTex, materialTex]) => {
                const h = getImageDataFromTexture(heightTex);
                const m = getImageDataFromTexture(materialTex);

                // Store material globally for land coloring
                matImageData = m.data;
                matW = m.width;
                matH = m.height;

                console.log('Creating terrain grid...');
                await createGridTerrain(h.data, h.width, h.height);
                console.log('Terrain created, starting animation');

                document.getElementById('loading').style.display = 'none';

                animationStartTime = Date.now();
                startCameraIntro();
            }).catch((error) => {
                console.error('Error loading maps:', error);
                document.getElementById('loading').innerText = 'ERROR LOADING TERRAIN';
            });
        }

        // Simple noise function
        function noise2D(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return n - Math.floor(n);
        }

        // Sample material color with optional V-flip and rotation
        function sampleMaterialColor(u, v) {
            if (!matImageData) return [1, 1, 1];
            let uu = Math.max(0, Math.min(1, u));
            let vv = Math.max(0, Math.min(1, v));
            // Apply flips first if enabled
            if (flipMaterialU) uu = 1 - uu;
            if (flipMaterialV) vv = 1 - vv;
            // Apply rotation about center (0.5, 0.5)
            if (matRotationDeg !== 0) {
                const rad = matRotationDeg * Math.PI / 180;
                const cosr = Math.cos(rad);
                const sinr = Math.sin(rad);
                const cx = uu - 0.5;
                const cy = vv - 0.5;
                const rx = cx * cosr - cy * sinr;
                const ry = cx * sinr + cy * cosr;
                uu = Math.max(0, Math.min(1, rx + 0.5));
                vv = Math.max(0, Math.min(1, ry + 0.5));
            }
            const x = Math.min(matW - 1, Math.floor(uu * matW));
            const y = Math.min(matH - 1, Math.floor(vv * matH));
            const i = (y * matW + x) * 4;
            return [matImageData[i] / 255, matImageData[i + 1] / 255, matImageData[i + 2] / 255];
        }

        async function createGridTerrain(data, width, height) {
            const sampledWidth = Math.floor(width / sampleRate);
            const sampledHeight = Math.floor(height / sampleRate);
            const borderSize = 30; // Extra space for circular border
            const extendedWidth = sampledWidth + borderSize * 2;
            const extendedHeight = sampledHeight + borderSize * 2;

            // Center the extended grid
            const offsetX = (extendedWidth * gridGap) / 2;
            const offsetZ = (extendedHeight * gridGap) / 2;

            const centerX = extendedWidth / 2;
            const centerZ = extendedHeight / 2;
            const baseRadius = Math.min(sampledWidth, sampledHeight) / 2 + 15; // Circular boundary
            const maxDist = baseRadius + 20;

            // First pass: count valid cubes and collect their data
            const cubeInfo = [];
            const heightMap = new Map(); // Store sampled data by position

            // Ocean defined using grayscale threshold from heightmap

            for (let z = 0; z < extendedHeight; z++) {
                for (let x = 0; x < extendedWidth; x++) {
                    // Distance from center
                    const dx = x - centerX;
                    const dz = z - centerZ;
                    const distFromCenter = Math.sqrt(dx * dx + dz * dz);

                    // Add noise to radius for irregular edge
                    const angle = Math.atan2(dz, dx);
                    const noiseVal = noise2D(Math.cos(angle) * 0.5, Math.sin(angle) * 0.5);
                    const secondNoise = noise2D(x * 0.1, z * 0.1);
                    const noisyRadius = baseRadius + noiseVal * 15 + secondNoise * 8;

                    // Skip cubes outside the noisy circular boundary
                    if (distFromCenter > noisyRadius) continue;

                    // Check if this position is within the heightmap
                    const isInHeightmap = x >= borderSize && x < sampledWidth + borderSize &&
                                         z >= borderSize && z < sampledHeight + borderSize;

                    let grayscale = 0;
                    let targetHeight = 0.5;
                    let isOcean = false;

                    if (isInHeightmap) {
                        const dataX = (x - borderSize) * sampleRate;
                        const dataZ = (z - borderSize) * sampleRate;
                        const index = (dataZ * width + dataX) * 4;
                        grayscale = data[index] / 255;
                        isOcean = grayscale <= seaThreshold;
                        targetHeight = isOcean ? seaFlatHeight : (grayscale * heightScale + 0.5);
                    } else {
                        // Border area - blend with nearest heightmap edge
                        const blendDistance = 10; // Pixels over which to blend

                        // Find nearest point on heightmap edge
                        let nearestX = Math.max(borderSize, Math.min(x, sampledWidth + borderSize - 1));
                        let nearestZ = Math.max(borderSize, Math.min(z, sampledHeight + borderSize - 1));

                        // Distance from heightmap edge
                        let distToEdge = Math.min(
                            Math.abs(x - borderSize),
                            Math.abs(x - (sampledWidth + borderSize - 1)),
                            Math.abs(z - borderSize),
                            Math.abs(z - (sampledHeight + borderSize - 1))
                        );

                        if (x < borderSize || x >= sampledWidth + borderSize ||
                            z < borderSize || z >= sampledHeight + borderSize) {
                            distToEdge = Math.sqrt(
                                Math.pow(Math.max(0, borderSize - x, x - (sampledWidth + borderSize - 1)), 2) +
                                Math.pow(Math.max(0, borderSize - z, z - (sampledHeight + borderSize - 1)), 2)
                            );
                        }

                        // Sample from nearest edge pixel
                        const edgeDataX = (nearestX - borderSize) * sampleRate;
                        const edgeDataZ = (nearestZ - borderSize) * sampleRate;
                        const edgeIndex = (edgeDataZ * width + edgeDataX) * 4;
                        const edgeGrayscale = data[edgeIndex] / 255;

                        // Blend between edge value and ocean
                        const blendFactor = Math.min(distToEdge / blendDistance, 1);
                        grayscale = edgeGrayscale * (1 - blendFactor) + 0.05 * blendFactor;
                        isOcean = grayscale <= seaThreshold;
                        targetHeight = isOcean ? seaFlatHeight : (grayscale * heightScale + 0.5);
                    }

                    heightMap.set(`${x},${z}`, { grayscale, isOcean });
                    cubeInfo.push({ x, z, grayscale, targetHeight, distFromCenter, isOcean });
                }
            }

            // Ocean/land already classified from grayscale threshold above

            // Second pass: detect shore areas (ocean near land)
            cubeInfo.forEach(cube => {
                if (cube.isOcean) { // Ocean cube (black/very dark)
                    // Check neighbors for land
                    let hasLandNearby = false;
                    for (let dz = -2; dz <= 2; dz++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            if (dx === 0 && dz === 0) continue;
                            const neighbor = heightMap.get(`${cube.x + dx},${cube.z + dz}`);
                            if (neighbor !== undefined && !neighbor.isOcean) {
                                hasLandNearby = true;
                                break;
                            }
                        }
                        if (hasLandNearby) break;
                    }
                    cube.isNearShore = hasLandNearby;
                } else {
                    cube.isNearShore = false;
                }
            });

            const count = cubeInfo.length;
            console.log(`Creating ${count} instanced cubes with circular noisy edge (grid: ${extendedWidth}x${extendedHeight})`);

            // Create geometry and material
            const geometry = new THREE.BoxGeometry(cubeSize, 1, cubeSize);
            const material = new THREE.MeshBasicMaterial();

            // Create instanced mesh
            instancedMesh = new THREE.InstancedMesh(geometry, material, count);
            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            const oceanColor = new THREE.Color(0x006994); // Ocean blue

            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const scale = new THREE.Vector3(1, 0.01, 1);

            // Third pass: create instances from valid cubes
            cubeInfo.forEach((cube, idx) => {
                const { x, z, grayscale, targetHeight, distFromCenter, isNearShore, isOcean } = cube;

                // Compute UV into material map anchored to heightmap area
                const u = Math.max(0, Math.min(1, (x - borderSize) / sampledWidth));
                const v = Math.max(0, Math.min(1, (z - borderSize) / sampledHeight));

                // Color: ocean fixed blue; land uses material map color
                let color;
                if (isOcean) {
                    color = oceanColor;
                } else {
                    const [r, g, b] = sampleMaterialColor(u, v);
                    color = new THREE.Color().setRGB(r, g, b);
                }

                // Set color for this instance using proper instanced mesh API
                instancedMesh.setColorAt(idx, color);

                // Position
                position.set(
                    x * gridGap - offsetX,
                    0,
                    z * gridGap - offsetZ
                );

                matrix.compose(position, new THREE.Quaternion(), scale);
                instancedMesh.setMatrixAt(idx, matrix);

                // Store animation data
                cubeData.push({
                    index: idx,
                    x: x * gridGap - offsetX,
                    z: z * gridGap - offsetZ,
                    targetHeight: targetHeight,
                    baseHeight: grayscale * heightScale + 0.5,
                    u: u,
                    v: v,
                    currentHeight: 0,
                    delay: getAnimationDelay(x, z, sampledWidth, sampledHeight),
                    animated: false,
                    isNearShore: isNearShore,
                    isOcean: isOcean,
                    grayscale: grayscale,
                    gridX: x,
                    gridZ: z,
                    originalColor: color.clone(),
                    isHovered: false,
                    wasHovered: false,
                    hoverProgress: 0,
                    hoverElevation: 0,
                    hoverElevationBonus: 0,
                    label: '',
                    icon: '',
                    labelObject: null
                });
            });

            instancedMesh.instanceMatrix.needsUpdate = true;
            if (instancedMesh.instanceColor) {
                instancedMesh.instanceColor.needsUpdate = true;
            }
            scene.add(instancedMesh);

            // Load saved custom colors
            await loadCustomColors();

            // Start auto-sync to get updates from other users
            startAutoSync();
        }

        function getAnimationDelay(x, z, width, height) {
            // Ripple from center
            const centerX = width / 2;
            const centerZ = height / 2;
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(z - centerZ, 2));
            const maxDistance = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerZ, 2));
            return (distance / maxDistance) * 2000; // 2 second wave
        }

        function startCameraIntro() {
            const midPoint = new THREE.Vector3(
                cameraStartPos.x + 30,
                cameraStartPos.y - 70,
                cameraStartPos.z + 60
            );

            if (!cameraMixer) {
                cameraMixer = new THREE.AnimationMixer(camera);

                // Build a smooth curve through start -> mid -> end
                const start = new THREE.Vector3(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
                const end = new THREE.Vector3(cameraEndPos.x, cameraEndPos.y, cameraEndPos.z);
                const curve = new THREE.CatmullRomCurve3([start, midPoint, end], false, 'catmullrom', 0.5);

                // Sample the curve to create a single smooth motion
                // Shorter duration for earlier stop, with ease-out for gentle finish
                const duration = 3.2; // seconds
                const samples = 100;
                const times = new Float32Array(samples);
                const values = new Float32Array(samples * 3);

                for (let i = 0; i < samples; i++) {
                    const t = i / (samples - 1);
                    // Ease-out on the curve parameter so motion decelerates near the end
                    const te = 1 - Math.pow(1 - t, 3); // easeOutCubic
                    const p = curve.getPoint(te);
                    times[i] = t * duration;
                    values[i * 3 + 0] = p.x;
                    values[i * 3 + 1] = p.y;
                    values[i * 3 + 2] = p.z;
                }

                const positionTrack = new THREE.VectorKeyframeTrack('.position', times, values);
                positionTrack.setInterpolation(THREE.InterpolateSmooth);
                const clip = new THREE.AnimationClip('CameraIntro', duration, [positionTrack]);

                cameraAction = cameraMixer.clipAction(clip);
                cameraAction.setLoop(THREE.LoopOnce, 1);
                cameraAction.clampWhenFinished = true;

                cameraMixer.addEventListener('finished', (event) => {
                    if (event.action === cameraAction) {
                        cameraIntroPlaying = false;
                        updateCameraControlDisplays();
                    }
                });
            }

            camera.position.set(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
            controls.target.set(0, 0, 0);
            controls.update();

            if (cameraAction) {
                cameraAction.reset();
                cameraAction.play();
            }

            cameraIntroPlaying = true;
            updateCameraControlDisplays();
        }

        function updateCameraControlDisplays() {
            const yActive = posYSlider && document.activeElement === posYSlider;
            if (posYSlider && !yActive) {
                posYSlider.value = Math.round(camera.position.y);
            }
            if (posYValueDisplay && !yActive) {
                posYValueDisplay.textContent = Math.round(camera.position.y);
            }

            const xActive = posXSlider && document.activeElement === posXSlider;
            if (posXSlider && !xActive) {
                posXSlider.value = Math.round(camera.position.x);
            }
            if (posXValueDisplay && !xActive) {
                posXValueDisplay.textContent = Math.round(camera.position.x);
            }
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
        }

        function animateCubes() {
            if (!instancedMesh) return;

            const elapsed = Date.now() - animationStartTime;
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();
            let needsUpdate = false;
            

            cubeData.forEach(cube => {
                let heightToUse = cube.currentHeight;

                if (!cube.animated) {
                    const timeSinceDelay = elapsed - cube.delay;

                    if (timeSinceDelay > 0) {
                        const duration = 800;
                        const progress = Math.min(timeSinceDelay / duration, 1);

                        if (progress >= 1) {
                            cube.animated = true;
                        }

                        const easedProgress = easeOutBack(progress);
                        cube.currentHeight = cube.targetHeight * easedProgress;
                        heightToUse = cube.currentHeight;
                        needsUpdate = true;
                    }
                }

                if (needsUpdate) {
                    // Update instance matrix
                    position.set(cube.x, heightToUse / 2, cube.z);
                    scale.set(1, Math.max(0.01, heightToUse), 1);
                    matrix.compose(position, quaternion, scale);
                    instancedMesh.setMatrixAt(cube.index, matrix);
                }
            });

            if (needsUpdate) {
                instancedMesh.instanceMatrix.needsUpdate = true;
            }
            
        }

        function applySeaThreshold() {
            if (!instancedMesh) return;

            const oceanColor = new THREE.Color(0x006994); // Ocean blue
            const tempColor = new THREE.Color();
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();

            cubeData.forEach((cube) => {
                const isOcean = cube.grayscale <= seaThreshold;
                cube.isOcean = isOcean;
                const newTarget = isOcean ? seaFlatHeight : (cube.grayscale * heightScale + 0.5);
                cube.targetHeight = newTarget;
                cube.currentHeight = newTarget;
                cube.animated = true;

                // Update color
                if (isOcean) {
                    tempColor.copy(oceanColor);
                } else {
                    // Sample land color from material map honoring rotation
                    const baseU = cube.u !== undefined ? cube.u : 0;
                    const baseV = cube.v !== undefined ? cube.v : 0;
                    const [sr, sg, sb] = sampleMaterialColor(baseU, baseV);
                    tempColor.setRGB(sr, sg, sb);
                }

                // Update original color for this cube
                cube.originalColor = tempColor.clone();
                instancedMesh.setColorAt(cube.index, tempColor);

                // Update transform
                position.set(cube.x, newTarget / 2, cube.z);
                scale.set(1, Math.max(0.01, newTarget), 1);
                matrix.compose(position, quaternion, scale);
                instancedMesh.setMatrixAt(cube.index, matrix);
            });

            if (instancedMesh.instanceColor) {
                instancedMesh.instanceColor.needsUpdate = true;
            }
            instancedMesh.instanceMatrix.needsUpdate = true;
        }

        function applyHeightScale() {
            if (!instancedMesh) return;

            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();

            cubeData.forEach((cube) => {
                const isOcean = cube.grayscale <= seaThreshold;
                const newTarget = isOcean ? seaFlatHeight : (cube.grayscale * heightScale + 0.5);
                cube.isOcean = isOcean;
                cube.targetHeight = newTarget;
                cube.currentHeight = newTarget;
                cube.animated = true;

                // Update transform only (colors unchanged here)
                position.set(cube.x, newTarget / 2, cube.z);
                scale.set(1, Math.max(0.01, newTarget), 1);
                matrix.compose(position, quaternion, scale);
                instancedMesh.setMatrixAt(cube.index, matrix);
            });

            instancedMesh.instanceMatrix.needsUpdate = true;
        }

        function onMouseDown(event) {
            mouseDownPos.x = event.clientX;
            mouseDownPos.y = event.clientY;
            isDragging = false;

            // Stop camera intro animation if user clicks/drags
            if (cameraIntroPlaying) {
                if (cameraAction) {
                    cameraAction.stop();
                }
                cameraIntroPlaying = false;
                controls.enabled = true;
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check if mouse moved significantly from mousedown position
            if (mouseDownPos.x !== undefined && mouseDownPos.y !== undefined) {
                const dx = event.clientX - mouseDownPos.x;
                const dy = event.clientY - mouseDownPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 5) { // 5 pixel threshold
                    isDragging = true;
                }
            }
        }

        function onMouseUp(event) {
            // Reset mousedown position
            mouseDownPos.x = undefined;
            mouseDownPos.y = undefined;

            // Reset after a short delay to allow click event to fire
            setTimeout(() => {
                isDragging = false;
            }, 50);
        }

        function showNotification(success, message, cubeIndex = -1) {
            const notification = document.getElementById('notification');
            const icon = notification.querySelector('.icon');
            const messageEl = notification.querySelector('.message');

            // Update content
            icon.textContent = success ? '‚úì' : '‚úï';
            messageEl.textContent = message;

            // Position above the cube if index provided
            if (cubeIndex >= 0 && cubeIndex < cubeData.length) {
                const cube = cubeData[cubeIndex];
                const worldPos = new THREE.Vector3(cube.x, cube.currentHeight + 10, cube.z);
                const screenPos = worldPos.project(camera);

                const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

                notification.style.left = `${x}px`;
                notification.style.top = `${y - 20}px`; // Offset for animation
                notification.style.transform = 'translate(-50%, -100%)';
            }

            // Update styling and show
            notification.className = success ? 'success visible' : 'error visible';

            // Auto-hide after 2 seconds
            setTimeout(() => {
                notification.classList.remove('visible');
            }, 2000);
        }

        async function saveCustomColors(cubeIndex = -1) {
            // Set save time immediately to prevent auto-sync race condition
            lastSaveTime = Date.now();

            try {
                // First, fetch the latest data to merge with
                let existingData = {};
                try {
                    const getResponse = await fetch(`${JSONBIN_URL}/latest`, {
                        method: 'GET',
                        headers: {
                            'X-Master-Key': JSONBIN_API_KEY
                        }
                    });

                    if (getResponse.ok) {
                        const result = await getResponse.json();
                        existingData = result.record?.cubes || {};
                        console.log('Fetched existing data, cubes:', Object.keys(existingData).length);
                    }
                } catch (e) {
                    console.warn('Could not fetch existing data, will overwrite:', e);
                }

                // Merge our changes with existing data
                const mergedData = { ...existingData };
                cubeData.forEach(cube => {
                    const hasData = cube.customColor || cube.label || cube.icon;
                    const existsInBin = existingData[cube.index];

                    if (hasData || existsInBin) {
                        // Save if has data OR if it exists in bin (to update/clear it)
                        if (hasData) {
                            const savedData = {
                                color: cube.customColor ? '#' + cube.customColor.getHexString() : null,
                                label: cube.label || '',
                                icon: cube.icon || ''
                            };
                            console.log('Saving cube', cube.index, 'with data:', savedData);
                            mergedData[cube.index] = savedData;
                        } else {
                            // Remove from bin if no data
                            console.log('Deleting cube', cube.index, 'from bin (no custom data)');
                            delete mergedData[cube.index];
                        }
                    }
                });

                console.log('Saving to JSONBin, total cubes:', Object.keys(mergedData).length);
                const response = await fetch(JSONBIN_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': JSONBIN_API_KEY
                    },
                    body: JSON.stringify({ cubes: mergedData })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Failed to save to JSONBin:', response.status, response.statusText, errorText);
                    showNotification(false, 'Changes not saved', cubeIndex);
                    return false;
                }

                const saveResult = await response.json();
                console.log('Save successful:', saveResult);
                showNotification(true, 'Changes saved', cubeIndex);
                return true;
            } catch (error) {
                console.error('Error saving to JSONBin:', error);
                showNotification(false, 'Changes not saved', cubeIndex);
                return false;
            }
        }

        async function loadCustomColors() {
            try {
                const response = await fetch(`${JSONBIN_URL}/latest`, {
                    method: 'GET',
                    headers: {
                        'X-Master-Key': JSONBIN_API_KEY
                    }
                });

                if (!response.ok) {
                    console.error('Failed to load from JSONBin:', response.statusText);
                    return;
                }

                const result = await response.json();
                const customData = result.record?.cubes || {};

                Object.keys(customData).forEach(index => {
                    const idx = parseInt(index);
                    if (idx >= 0 && idx < cubeData.length) {
                        const data = customData[index];

                        // Load color
                        if (data.color) {
                            cubeData[idx].customColor = new THREE.Color(data.color);
                        } else if (typeof data === 'string') {
                            // Backward compatibility with old format
                            cubeData[idx].customColor = new THREE.Color(data);
                        }

                        // Load label and icon
                        if (data.label || data.icon) {
                            cubeData[idx].label = data.label || '';
                            cubeData[idx].icon = data.icon || '';
                            updateCubeLabel(cubeData[idx], data.label, data.icon);
                        }
                    }
                });
            } catch (e) {
                console.error('Failed to load custom colors:', e);
            }
        }

        function startAutoSync() {
            // Poll for updates every 5 seconds
            setInterval(async () => {
                // Skip if we just saved (avoid overwriting our own changes)
                if (Date.now() - lastSaveTime < 10000) {
                    return;
                }

                try {
                    const response = await fetch(`${JSONBIN_URL}/latest`, {
                        method: 'GET',
                        headers: {
                            'X-Master-Key': JSONBIN_API_KEY
                        }
                    });

                    if (!response.ok) return;

                    const result = await response.json();
                    const customData = result.record?.cubes || {};

                    // First, clear any cubes that were deleted from the bin
                    cubeData.forEach((cube, idx) => {
                        // Skip if currently selected to avoid conflicts
                        if (cube.index === selectedCubeIndex) return;

                        // If cube has custom data locally but not in bin, clear it
                        if ((cube.customColor || cube.label || cube.icon) && !customData[idx]) {
                            console.log('Auto-sync: Clearing cube', idx, 'as it was deleted from bin');
                            cube.customColor = null;
                            cube.label = '';
                            cube.icon = '';
                            updateCubeLabel(cube, '', '');
                        }
                    });

                    // Update cubes that have changed
                    Object.keys(customData).forEach(index => {
                        const idx = parseInt(index);
                        if (idx >= 0 && idx < cubeData.length) {
                            const data = customData[index];
                            const cube = cubeData[idx];

                            // Check if this cube needs updating (skip if currently selected to avoid conflicts)
                            if (cube.index === selectedCubeIndex) return;

                            // Update color if changed
                            const newColorHex = data.color;
                            const currentColorHex = cube.customColor ? '#' + cube.customColor.getHexString() : null;
                            if (newColorHex !== currentColorHex) {
                                console.log('Auto-sync: Updating cube', idx, 'color from', currentColorHex, 'to', newColorHex);
                                cube.customColor = newColorHex ? new THREE.Color(newColorHex) : null;
                            }

                            // Update label/icon if changed
                            const newLabel = data.label || '';
                            const newIcon = data.icon || '';
                            if (cube.label !== newLabel || cube.icon !== newIcon) {
                                cube.label = newLabel;
                                cube.icon = newIcon;
                                updateCubeLabel(cube, newLabel, newIcon);
                            }
                        }
                    });
                } catch (e) {
                    // Silently fail - don't spam console with sync errors
                }
            }, 5000); // Sync every 5 seconds
        }

        function updateCubeLabel(cube, labelText, iconName) {
            // Remove existing label
            if (cube.labelObject) {
                scene.remove(cube.labelObject);
                cube.labelObject = null;
            }

            // Update cube data
            cube.label = labelText ? labelText.trim() : '';
            cube.icon = iconName || '';

            // Create new label if text or icon is provided
            if (cube.label || cube.icon) {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'cube-label';

                // Add icon if provided
                if (cube.icon) {
                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'material-symbols-outlined';
                    iconSpan.textContent = cube.icon;
                    labelDiv.appendChild(iconSpan);
                }

                // Add text if provided
                if (cube.label) {
                    const textSpan = document.createElement('span');
                    textSpan.textContent = cube.label;
                    labelDiv.appendChild(textSpan);
                }

                const label = new CSS2DObject(labelDiv);
                const totalHeight = cube.currentHeight + cube.hoverElevation;
                label.position.set(cube.x, totalHeight + 2, cube.z);
                scene.add(label);

                cube.labelObject = label;
            }
        }

        function setupColorSwatches() {
            const swatches = document.querySelectorAll('.color-swatch');
            const cube = cubeData[selectedCubeIndex];

            // Setup icon preset dropdown
            const iconSelect = document.getElementById('cube-icon');
            const newIconSelect = iconSelect.cloneNode(true);
            iconSelect.parentNode.replaceChild(newIconSelect, iconSelect);

            // Check if current icon is in preset options
            const isPresetIcon = Array.from(newIconSelect.options).some(opt => opt.value === cube.icon);

            if (isPresetIcon) {
                newIconSelect.value = cube.icon;
            } else {
                newIconSelect.value = '';
            }

            newIconSelect.addEventListener('change', (e) => {
                const customInput = document.getElementById('cube-icon-custom');
                customInput.value = ''; // Clear custom input when preset is selected
                updateCubeLabel(cube, cube.label, e.target.value);
            });

            newIconSelect.addEventListener('mousedown', (e) => e.stopPropagation());
            newIconSelect.addEventListener('click', (e) => e.stopPropagation());

            // Setup custom icon input
            const customIconInput = document.getElementById('cube-icon-custom');
            const newCustomIconInput = customIconInput.cloneNode(true);
            customIconInput.parentNode.replaceChild(newCustomIconInput, customIconInput);

            // Show custom icon if it's not a preset
            if (cube.icon && !isPresetIcon) {
                newCustomIconInput.value = cube.icon;
            } else {
                newCustomIconInput.value = '';
            }

            newCustomIconInput.addEventListener('input', (e) => {
                const select = document.getElementById('cube-icon');
                select.value = ''; // Clear preset when custom is typed
                updateCubeLabel(cube, cube.label, e.target.value.trim());
            });

            newCustomIconInput.addEventListener('mousedown', (e) => e.stopPropagation());
            newCustomIconInput.addEventListener('click', (e) => e.stopPropagation());

            // Setup label input
            const labelInput = document.getElementById('cube-label');
            labelInput.value = cube.label || '';

            const newLabelInput = labelInput.cloneNode(true);
            labelInput.parentNode.replaceChild(newLabelInput, labelInput);

            newLabelInput.addEventListener('input', (e) => {
                updateCubeLabel(cube, e.target.value, cube.icon);
            });

            newLabelInput.addEventListener('mousedown', (e) => e.stopPropagation());
            newLabelInput.addEventListener('click', (e) => e.stopPropagation());

            // Remove previous listeners
            swatches.forEach(swatch => {
                const clone = swatch.cloneNode(true);
                swatch.parentNode.replaceChild(clone, swatch);
            });

            // Re-query after cloning
            const newSwatches = document.querySelectorAll('.color-swatch');

            newSwatches.forEach(swatch => {
                // Mark currently selected color
                const swatchColor = swatch.getAttribute('data-color');
                if (swatchColor === 'original' && !cube.customColor) {
                    swatch.classList.add('selected');
                } else if (cube.customColor && swatchColor === '#' + cube.customColor.getHexString()) {
                    swatch.classList.add('selected');
                }

                // Add click listener
                swatch.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent click from bubbling to window
                    const color = swatch.getAttribute('data-color');

                    // Remove selected from all swatches
                    newSwatches.forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');

                    // Update cube's custom color (updateHover will apply it)
                    if (color === 'original') {
                        cube.customColor = null;
                    } else {
                        cube.customColor = new THREE.Color(color);
                    }
                });
            });
        }

        function onMouseClick(event) {
            if (cameraIntroPlaying) return; // Don't allow clicks during intro
            if (isDragging) return; // Don't allow selection if dragging

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(instancedMesh);

            // If something is already selected, any click deselects
            if (selectedCubeIndex !== -1) {
                deselectCube();
                return;
            }

            // Nothing selected - allow new selection
            if (intersects.length > 0) {
                const clickedIndex = intersects[0].instanceId;
                selectCube(clickedIndex);
            }
        }

        function selectCube(index) {
            if (index < 0 || index >= cubeData.length) return;

            selectedCubeIndex = index;
            const cube = cubeData[index];

            // Save initial state for change detection
            cubeEditChanged = false;
            initialCubeState = {
                color: cube.customColor ? cube.customColor.clone() : null,
                label: cube.label || '',
                icon: cube.icon || ''
            };

            // Save current camera state
            if (!isOrbiting) {
                savedCameraPos = camera.position.clone();
                savedControlsTarget = controls.target.clone();
            }

            // Start transition to cube
            cameraTransitioning = true;
            cameraTransitionProgress = 0;
            isOrbiting = true;
            orbitAngle = 0;

            // Disable controls during orbit
            controls.enabled = false;

            // Show color picker
            const colorPicker = document.getElementById('color-picker');
            colorPicker.classList.add('visible');

            // Setup color swatches
            setupColorSwatches();
        }

        function deselectCube() {
            if (selectedCubeIndex === -1) return;

            const cubeIndex = selectedCubeIndex;
            const cube = cubeData[cubeIndex];

            // Check if anything changed
            const hasChanges = checkIfCubeChanged(cube);

            selectedCubeIndex = -1;

            // Only save if changes were made
            if (hasChanges) {
                saveCustomColors(cubeIndex);
            }

            // Transition back to saved position
            if (savedCameraPos && savedControlsTarget) {
                cameraTransitioning = true;
                cameraTransitionProgress = 0;
                isOrbiting = false;
                // Controls will be re-enabled in updateCameraOrbit when transition completes
            }

            // Hide color picker
            const colorPicker = document.getElementById('color-picker');
            colorPicker.classList.remove('visible');
        }

        function checkIfCubeChanged(cube) {
            if (!initialCubeState) return false;

            const currentColor = cube.customColor ? cube.customColor.getHexString() : null;
            const initialColor = initialCubeState.color ? initialCubeState.color.getHexString() : null;

            return currentColor !== initialColor ||
                   cube.label !== initialCubeState.label ||
                   cube.icon !== initialCubeState.icon;
        }

        function updateCameraOrbit() {
            // Handle transition back to normal
            if (!isOrbiting && cameraTransitioning && savedCameraPos && savedControlsTarget) {
                cameraTransitionProgress += 0.05;
                if (cameraTransitionProgress >= 1) {
                    cameraTransitionProgress = 1;
                    cameraTransitioning = false;
                    controls.enabled = true;
                }

                const eased = 1 - Math.pow(1 - cameraTransitionProgress, 3); // ease out
                camera.position.lerpVectors(camera.position.clone(), savedCameraPos, eased * 0.2);
                controls.target.lerpVectors(controls.target.clone(), savedControlsTarget, eased * 0.2);
                camera.lookAt(controls.target);
                return;
            }

            if (!isOrbiting || selectedCubeIndex === -1) return;

            const cube = cubeData[selectedCubeIndex];
            const cubeWorldPos = new THREE.Vector3(cube.x, cube.currentHeight + 2, cube.z);

            // Camera orbit parameters
            const orbitRadius = 15;
            const orbitHeight = 15; // Height above the top of the cube
            const orbitSpeed = 0.001; // Slower rotation

            // Update orbit angle
            orbitAngle += orbitSpeed;

            // Calculate camera position
            const targetCameraPos = new THREE.Vector3(
                cubeWorldPos.x + Math.cos(orbitAngle) * orbitRadius,
                cubeWorldPos.y + orbitHeight,
                cubeWorldPos.z + Math.sin(orbitAngle) * orbitRadius
            );

            // Animate transition to orbit position
            if (cameraTransitioning) {
                cameraTransitionProgress += 0.05;
                if (cameraTransitionProgress >= 1) {
                    cameraTransitionProgress = 1;
                    cameraTransitioning = false;
                }

                const eased = 1 - Math.pow(1 - cameraTransitionProgress, 3); // ease out
                camera.position.lerpVectors(savedCameraPos, targetCameraPos, eased);
                controls.target.lerpVectors(savedControlsTarget, cubeWorldPos, eased);
            } else {
                // Smooth orbit around cube
                camera.position.copy(targetCameraPos);
                controls.target.copy(cubeWorldPos);
            }

            camera.lookAt(controls.target);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateCameraAnimation(delta) {
            if (!cameraMixer || !cameraAction) return;

            cameraMixer.update(delta);

            if (cameraIntroPlaying) {
                updateCameraControlDisplays();
            }
        }

        function updateHover() {
            if (!instancedMesh) return;

            // Skip hover detection on mobile devices
            if (!isMobile) {
                // Only do hover detection when no cube is selected
                if (selectedCubeIndex === -1) {
                    // Raycast to find intersected instance
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObject(instancedMesh);

                    if (intersects.length > 0) {
                        hoveredCubeIndex = intersects[0].instanceId;
                    } else {
                        hoveredCubeIndex = -1;
                    }

                    // Update hover states
                    if (previousHoveredIndex !== hoveredCubeIndex) {
                        // Mark previous as no longer hovered
                        if (previousHoveredIndex >= 0 && previousHoveredIndex < cubeData.length) {
                            cubeData[previousHoveredIndex].isHovered = false;
                        }
                        // Mark new as hovered
                        if (hoveredCubeIndex >= 0 && hoveredCubeIndex < cubeData.length) {
                            cubeData[hoveredCubeIndex].isHovered = true;
                        }
                        previousHoveredIndex = hoveredCubeIndex;
                    }
                } else {
                    // Clear any existing hover when a cube is selected
                    if (hoveredCubeIndex !== -1) {
                        if (hoveredCubeIndex >= 0 && hoveredCubeIndex < cubeData.length) {
                            cubeData[hoveredCubeIndex].isHovered = false;
                        }
                        hoveredCubeIndex = -1;
                        previousHoveredIndex = -1;
                    }
                }
            }

            // Animate all cubes with hover transitions
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();
            const tempColor = new THREE.Color();
            let needsUpdate = false;
            let colorNeedsUpdate = false;

            cubeData.forEach(cube => {
                // If this cube is selected, keep it elevated and white
                const isSelected = cube.index === selectedCubeIndex;
                const hasCustomColor = cube.customColor !== null && cube.customColor !== undefined;
                const targetProgress = (cube.isHovered || isSelected || hasCustomColor) ? 1 : 0;

                // Animate hover progress
                const progressChanged = cube.hoverProgress !== targetProgress;
                const hoverStateChanged = cube.wasHovered !== cube.isHovered;
                cube.wasHovered = cube.isHovered;

                if (progressChanged) {
                    const speed = 0.15; // Animation speed
                    cube.hoverProgress += (targetProgress - cube.hoverProgress) * speed;

                    // Clamp to target when very close
                    if (Math.abs(cube.hoverProgress - targetProgress) < 0.01) {
                        cube.hoverProgress = targetProgress;
                    }
                }

                // Animate elevation bonus for colored cubes when hovering
                const targetElevationBonus = (hasCustomColor && cube.isHovered && !isSelected) ? 3 : 0;
                const bonusChanged = Math.abs(cube.hoverElevationBonus - targetElevationBonus) > 0.01;
                if (bonusChanged) {
                    const speed = 0.15;
                    cube.hoverElevationBonus += (targetElevationBonus - cube.hoverElevationBonus) * speed;

                    // Clamp to target when very close
                    if (Math.abs(cube.hoverElevationBonus - targetElevationBonus) < 0.01) {
                        cube.hoverElevationBonus = targetElevationBonus;
                    }
                }

                // Update color if progress changed OR if this cube is selected OR if hover state changed OR bonus changed
                if (progressChanged || isSelected || hasCustomColor || hoverStateChanged || bonusChanged) {
                    // For selected cubes
                    if (isSelected) {
                        if (cube.customColor) {
                            // Show custom color
                            tempColor.copy(cube.customColor);
                        } else {
                            // Show white for default/original color
                            tempColor.setRGB(1, 1, 1);
                        }
                    } else if (hasCustomColor) {
                        // For cubes with custom color, brighten when hovered (animated)
                        const whiteColor = new THREE.Color(1, 1, 1);
                        const brightenAmount = (cube.hoverElevationBonus / 3) * 0.3; // Smoothly animate 0 to 0.3
                        tempColor.copy(cube.customColor).lerp(whiteColor, brightenAmount);
                    } else {
                        // For hovered cubes, lerp to white
                        const whiteColor = new THREE.Color(1, 1, 1);
                        tempColor.copy(cube.originalColor).lerp(whiteColor, cube.hoverProgress);
                    }

                    instancedMesh.setColorAt(cube.index, tempColor);
                    colorNeedsUpdate = true;

                    // Update elevation with animated bonus
                    cube.hoverElevation = cube.hoverProgress * 5 + cube.hoverElevationBonus;
                    const totalHeight = cube.currentHeight + cube.hoverElevation;
                    position.set(cube.x, totalHeight / 2, cube.z);
                    scale.set(1, Math.max(0.01, totalHeight), 1);
                    matrix.compose(position, quaternion, scale);
                    instancedMesh.setMatrixAt(cube.index, matrix);

                    // Update label position if exists
                    if (cube.labelObject) {
                        cube.labelObject.position.set(cube.x, totalHeight + 2, cube.z);
                    }

                    needsUpdate = true;
                }
            });

            if (needsUpdate) {
                instancedMesh.instanceMatrix.needsUpdate = true;
            }
            if (colorNeedsUpdate && instancedMesh.instanceColor) {
                instancedMesh.instanceColor.needsUpdate = true;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (!isOrbiting) {
                controls.update();
            }
            animateCubes();
            updateCameraAnimation(delta);
            updateCameraOrbit();
            updateHover();

            // Rotate lights
            const time = Date.now() * 0.0003;
            scene.children.forEach(child => {
                if (child instanceof THREE.PointLight) {
                    const radius = 80;
                    child.position.x = Math.sin(time) * radius;
                    child.position.z = Math.cos(time) * radius;
                }
            });

            composer.render();
            labelRenderer.render(scene, camera);
            updateLabelVisibility();
        }

        function updateLabelVisibility() {
            // Get all visible labels with their screen positions
            const labels = cubeData
                .filter(cube => cube.labelObject)
                .map(cube => {
                    const labelDiv = cube.labelObject.element;
                    const rect = labelDiv.getBoundingClientRect();
                    return {
                        cube: cube,
                        element: labelDiv,
                        rect: rect,
                        center: {
                            x: rect.left + rect.width / 2,
                            y: rect.top + rect.height / 2
                        }
                    };
                });

            // Check each label against others
            labels.forEach(label1 => {
                let hasOverlap = false;

                labels.forEach(label2 => {
                    if (label1 === label2) return;

                    // Check if rectangles overlap
                    const overlap = !(
                        label1.rect.right < label2.rect.left ||
                        label1.rect.left > label2.rect.right ||
                        label1.rect.bottom < label2.rect.top ||
                        label1.rect.top > label2.rect.bottom
                    );

                    if (overlap) {
                        // Calculate distance to camera
                        const dist1 = camera.position.distanceTo(label1.cube.labelObject.position);
                        const dist2 = camera.position.distanceTo(label2.cube.labelObject.position);

                        // Hide the one that's farther from camera
                        if (dist1 > dist2) {
                            hasOverlap = true;
                        }
                    }
                });

                // Set opacity based on overlap
                label1.element.style.opacity = hasOverlap ? '0' : '1';
            });
        }

        init();
        animate();
    </script>
</body>
</html>
