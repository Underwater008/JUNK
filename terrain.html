<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Terrain Grid Visualization</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200');

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #f5f7fa 0%, #e8eaf6 50%, #f3e5f5 100%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 10;
        }
        #info img {
            height: 40px;
            display: block;
            filter: brightness(0);
            opacity: 0.9;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6b4ce6;
            font-size: 20px;
            font-weight: 400;
            letter-spacing: 1px;
            z-index: 5;
        }
        #color-picker {
            position: absolute;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            padding: 24px;
            color: #1a1a1a;
            font-size: 14px;
            min-width: 260px;
            z-index: 10;
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #color-picker.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        #color-picker h3 {
            margin: 0 0 16px 0;
            font-size: 16px;
            font-weight: 600;
            color: #1a1a1a;
        }
        .picker-group {
            margin-bottom: 16px;
        }
        .picker-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #4a4a4a;
            font-size: 13px;
        }
        .picker-group input[type="text"] {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            color: #1a1a1a;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }
        .picker-group input[type="text"]:focus {
            outline: none;
            border-color: #6b4ce6;
        }
        .cube-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            color: #1a1a1a;
            white-space: nowrap;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transform: translate(-50%, -100%);
            margin-top: -8px;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .cube-label .material-symbols-outlined {
            font-size: 16px;
            font-variation-settings: 'FILL' 1, 'wght' 500, 'GRAD' 0, 'opsz' 20;
        }
        .picker-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            color: #1a1a1a;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }
        .picker-group select:focus {
            outline: none;
            border-color: #6b4ce6;
        }
        .picker-group select option {
            padding: 8px;
        }
        .color-swatches {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 100%;
        }
        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border: 3px solid transparent;
            position: relative;
            box-sizing: border-box;
        }
        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .color-swatch.selected {
            border-color: #1a1a1a;
            transform: scale(1.05);
        }
        .color-swatch.original {
            background: linear-gradient(135deg, #e0e0e0 0%, #f5f5f5 100%);
            position: relative;
        }
        .color-swatch.original::after {
            content: '‚Üª';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #666;
        }
        #notification {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            padding: 12px 20px;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }
        #notification.visible {
            opacity: 1;
        }
        #notification .icon {
            font-size: 20px;
            line-height: 1;
        }
        #notification.success .icon {
            color: #4caf50;
        }
        #notification.error .icon {
            color: #f44336;
        }
        #notification .message {
            font-size: 13px;
            font-weight: 500;
            color: #1a1a1a;
        }
        #signature {
            position: absolute;
            bottom: 30px;
            left: 30px;
            z-index: 10;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        #signature:hover {
            opacity: 1;
        }
        #signature a {
            display: block;
            text-decoration: none;
        }
        #signature img {
            height: 50px;
            display: block;
        }
        /* Journey Media Popup */
        #media-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #media-popup.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .media-container {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 80%;
            max-height: 80%;
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        .media-close {
            position: absolute;
            top: -12px;
            right: -12px;
            width: 36px;
            height: 36px;
            background: white;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
        }
        .media-close:hover {
            transform: scale(1.1);
        }
        .media-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }
        .media-content h2 {
            margin: 0;
            font-size: 24px;
            color: #1a1a1a;
        }
        .media-content p {
            margin: 0;
            color: #666;
            font-size: 14px;
            text-align: center;
            max-width: 400px;
        }
        .media-placeholder {
            width: 500px;
            height: 300px;
            background: linear-gradient(135deg, #e8eaf6 0%, #f3e5f5 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6b4ce6;
            font-size: 48px;
        }
        .journey-marker {
            position: absolute;
            background: rgba(107, 76, 230, 0.9);
            backdrop-filter: blur(10px);
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: white;
            white-space: nowrap;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(107, 76, 230, 0.4);
            transform: translate(-50%, -100%);
            margin-top: -12px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .journey-marker::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(107, 76, 230, 0.9);
        }
        .journey-marker .material-symbols-outlined {
            font-size: 16px;
            font-variation-settings: 'FILL' 1, 'wght' 500, 'GRAD' 0, 'opsz' 20;
        }
        #controls {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            padding: 20px;
            color: #1a1a1a;
            font-size: 13px;
            min-width: 220px;
            z-index: 10;
            display: none;
        }
        #controls h3 {
            margin: 0 0 15px 0;
            font-size: 15px;
            font-weight: 600;
            text-align: center;
            color: #6b4ce6;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #4a4a4a;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .control-group input[type="number"] {
            width: 70px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            color: #1a1a1a;
            padding: 4px 8px;
        }
    </style>
</head>
<body>
    <div id="info">
        <img src="junk-logo.png" alt="JUNK">
    </div>
    <div id="loading">Loading...</div>

    <div id="color-picker">
        <h3>Customize Cube</h3>
        <div class="picker-group">
            <label>Icon Preset</label>
            <select id="cube-icon">
                <option value="">None</option>
                <option value="electric_bolt">‚ö° Power Station</option>
                <option value="local_hospital">üè• Hospital</option>
                <option value="school">üè´ School</option>
                <option value="account_balance">üèõÔ∏è Government</option>
                <option value="radio">üìª Radio Station</option>
                <option value="anchor">‚öì Port</option>
                <option value="factory">üè≠ Factory</option>
                <option value="agriculture">üåæ Farm</option>
                <option value="water_drop">üíß Water</option>
                <option value="home">üè† Residential</option>
                <option value="store">üè™ Market</option>
                <option value="local_fire_department">üöí Fire Station</option>
                <option value="local_police">üöì Police</option>
                <option value="flight">‚úàÔ∏è Airport</option>
                <option value="warehouse">üì¶ Warehouse</option>
            </select>
        </div>
        <div class="picker-group">
            <label>Custom Icon <a href="https://fonts.google.com/icons" target="_blank" style="font-size: 11px; color: #6b4ce6; text-decoration: none;">(browse)</a></label>
            <input type="text" id="cube-icon-custom" placeholder="e.g., restaurant, build, star...">
        </div>
        <div class="picker-group">
            <label>Label</label>
            <input type="text" id="cube-label" placeholder="Enter name..." maxlength="20">
        </div>
        <div class="color-swatches">
            <div class="color-swatch original" data-color="original" title="Original"></div>
            <div class="color-swatch" data-color="#5CCBD4" style="background: #5CCBD4;" title="Cyan"></div>
            <div class="color-swatch" data-color="#C855D8" style="background: #C855D8;" title="Magenta"></div>
            <div class="color-swatch" data-color="#4A8EC2" style="background: #4A8EC2;" title="Blue"></div>
            <div class="color-swatch" data-color="#6B4CE6" style="background: #6B4CE6;" title="Purple"></div>
            <div class="color-swatch" data-color="#F4C2C2" style="background: #F4C2C2;" title="Pink"></div>
            <div class="color-swatch" data-color="#A64D79" style="background: #A64D79;" title="Burgundy"></div>
            <div class="color-swatch" data-color="#5ABF8C" style="background: #5ABF8C;" title="Green"></div>
            <div class="color-swatch" data-color="#F4D35E" style="background: #F4D35E;" title="Yellow"></div>
        </div>
    </div>

    <div id="notification">
        <div class="icon">‚úì</div>
        <div class="message">Saved successfully!</div>
    </div>

    <div id="controls">
        <h3>CAMERA CONTROLS</h3>
        <div class="control-group">
            <label>FOV: <span id="fov-value">30</span></label>
            <input type="range" id="fov" min="30" max="120" value="30" step="1">
        </div>
        <div class="control-group">
            <label>Position Y: <span id="pos-y-value">260</span></label>
            <input type="range" id="pos-y" min="10" max="320" value="260" step="1">
        </div>
        <div class="control-group">
            <label>Position X: <span id="pos-x-value">80</span></label>
            <input type="range" id="pos-x" min="-200" max="200" value="80" step="1">
        </div>
        <div class="control-group">
            <label>Position Z: <span id="pos-z-value">80</span></label>
            <input type="range" id="pos-z" min="-200" max="200" value="80" step="1">
        </div>
        <div class="control-group">
            <label>Height Scale: <span id="height-value">7</span></label>
            <input type="range" id="height-scale" min="5" max="100" value="7" step="1">
        </div>
        <div class="control-group">
            <label>Sea Threshold: <span id="sea-threshold-value">0.07</span></label>
            <input type="range" id="sea-threshold" min="0" max="0.5" value="0.07" step="0.01">
            <input type="number" id="sea-threshold-input" min="0" max="0.5" value="0.07" step="0.001">
        </div>
        <div class="control-group">
            <label>Sea Level Height: <span id="sea-height-value">1.00</span></label>
            <input type="range" id="sea-height" min="0.1" max="10" value="1.0" step="0.01">
            <input type="number" id="sea-height-input" min="0.1" max="10" value="1.0" step="0.01">
        </div>
        <div class="control-group">
            <label>Material Rotation: <span id="mat-rotation-value">180</span>¬∞</label>
            <input type="range" id="mat-rotation" min="-180" max="180" value="180" step="1">
        </div>
        <div class="control-group">
            <label><input type="checkbox" id="mat-flip-u"> Flip U</label>
            <label style="margin-left:10px;"><input type="checkbox" id="mat-flip-v" checked> Flip V</label>
        </div>
    </div>

    <div id="signature">
        <a href="mailto:xiaozhix@usc.edu">
            <img src="Assets/images/Xiao_Sign.png" alt="Xiao">
        </a>
    </div>

    <!-- Journey Media Popup -->
    <div id="media-popup">
        <div class="media-container">
            <button class="media-close" onclick="closeMediaPopup()">√ó</button>
            <div class="media-content">
                <h2 id="media-title">Location Title</h2>
                <div class="media-placeholder" id="media-placeholder">
                    <span class="material-symbols-outlined">image</span>
                </div>
                <p id="media-description">Description of this journey location.</p>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // JSONBin configuration
        const JSONBIN_BIN_ID = '68e0256043b1c97be95965b9';
        const JSONBIN_API_KEY = '$2a$10$IcHy/if.465WYHfVCaX0WOrS.zvgk8DinfdOFdHuUoCZLt7YTP4RS';
        const JSONBIN_URL = `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`;

        let scene, camera, renderer, controls, labelRenderer;
        let instancedMesh;
        let cubeData = [];
        let animationStartTime = 0;
        let cameraMixer = null;
        let cameraAction = null;
        let cameraIntroPlaying = false;
        let posXSlider = null;
        let posXValueDisplay = null;
        let posYSlider = null;
        let posYValueDisplay = null;
        // Mouse interaction
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let mouseDownPos = new THREE.Vector2();
        let isDragging = false;
        let hoveredCubeIndex = -1;
        let previousHoveredIndex = -1;
        let selectedCubeIndex = -1;
        let isOrbiting = false;
        let orbitAngle = 0;
        let cameraTransitioning = false;
        let cameraTransitionProgress = 0;
        let savedCameraPos = null;
        let savedControlsTarget = null;
        let cubeEditChanged = false;
        let initialCubeState = null;
        let lastSaveTime = 0;
        // Mobile detection
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        // Post-processing
        let composer;
        // Material map data for land coloring
        let matImageData = null;
        let matW = 0;
        let matH = 0;
        let flipMaterialU = true;  // allow horizontal flip
        let flipMaterialV = true;  // vertical flip (image origin alignment)
        let matRotationDeg = 180; // rotation around material center (default sweet spot)
        const clock = new THREE.Clock();
        let heightScale = 7;
        const gridGap = 1.0;
        const cubeSize = 1.0;
        const sampleRate = 4; // Sample every Nth pixel (128x128 = 16k instances)
        let seaThreshold = 0.07; // Grayscale cutoff: <= is ocean (default sweet spot)
        let seaFlatHeight = 1.0; // Flat column height for ocean

        const cameraStartPos = { x: 80, y: 260, z: 80 };
        const cameraEndPos = { x: 80, y: 140, z: 140 };

        // Journey points data - fake journey locations on the map
        const journeyPoints = [
            {
                id: 1,
                name: "Science Vault",
                icon: "science",
                x: -20,
                z: 10,
                description: "An underground vault where scientific knowledge was preserved during the collapse.",
                media: "Assets/images/Science class in the vault.jpg",
                mediaType: "image"
            },
            {
                id: 2,
                name: "Old Harbor",
                icon: "anchor",
                x: -35,
                z: -25,
                description: "The remnants of a once-bustling port, now silent and overgrown.",
                media: null,
                mediaType: "placeholder"
            },
            {
                id: 3,
                name: "Radio Tower",
                icon: "cell_tower",
                x: 5,
                z: -15,
                description: "A communication tower that still broadcasts mysterious signals.",
                media: null,
                mediaType: "placeholder"
            },
            {
                id: 4,
                name: "Mountain Refuge",
                icon: "landscape",
                x: 25,
                z: 20,
                description: "A hidden settlement high in the mountains, offering safety and panoramic views.",
                media: null,
                mediaType: "placeholder"
            },
            {
                id: 5,
                name: "Power Station",
                icon: "electric_bolt",
                x: 40,
                z: -10,
                description: "An abandoned power plant that once energized the entire region.",
                media: null,
                mediaType: "placeholder"
            }
        ];

        // Journey system variables
        let journeyMarkers = [];
        let journeyLine = null;
        let selectedJourneyPoint = null;
        let journeyTransitioning = false;
        let journeyTransitionProgress = 0;
        let journeySavedCameraPos = null;
        let journeySavedTarget = null;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f7fa);

            // Camera - start at high position for entrance animation
            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Label renderer
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            // Post-processing setup (no bloom)
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2;

            // Mouse events
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);

            // Lighting - soft and ambient for clean look
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0xb8a5ff, 0.8, 200);
            pointLight1.position.set(50, 40, 0);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffc4e1, 0.8, 200);
            pointLight2.position.set(-50, 40, 0);
            scene.add(pointLight2);

            // Setup control panel
            setupControls();

            // Load heightmap
            loadHeightmap();
        }

        function setupControls() {
            // FOV control
            const fovSlider = document.getElementById('fov');
            const fovValue = document.getElementById('fov-value');
            fovSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.fov = value;
                camera.updateProjectionMatrix();
                fovValue.textContent = value;
            });

            // Position Y control
            posYSlider = document.getElementById('pos-y');
            posYValueDisplay = document.getElementById('pos-y-value');
            posYSlider.value = camera.position.y;
            posYValueDisplay.textContent = Math.round(camera.position.y);
            posYSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.y = value;
                posYValueDisplay.textContent = value;
            });

            // Position X control
            posXSlider = document.getElementById('pos-x');
            posXValueDisplay = document.getElementById('pos-x-value');
            posXSlider.value = camera.position.x;
            posXValueDisplay.textContent = Math.round(camera.position.x);
            posXSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.x = value;
                posXValueDisplay.textContent = value;
            });

            // Position Z control
            const posZSlider = document.getElementById('pos-z');
            const posZValue = document.getElementById('pos-z-value');
            posZSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.z = value;
                posZValue.textContent = value;
            });

            // Height scale control (live update land cube heights)
            const heightSlider = document.getElementById('height-scale');
            const heightValue = document.getElementById('height-value');
            heightSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                heightScale = value;
                heightValue.textContent = value;
                applyHeightScale();
            });

            // Sea threshold control (live recolor + flatten ocean)
            const seaSlider = document.getElementById('sea-threshold');
            const seaValue = document.getElementById('sea-threshold-value');
            const seaInput = document.getElementById('sea-threshold-input');
            const clampSea = (v) => Math.max(parseFloat(seaSlider.min), Math.min(parseFloat(seaSlider.max), v));

            const syncSeaUI = (v) => {
                const vv = clampSea(v);
                seaSlider.value = vv;
                seaInput.value = vv;
                seaValue.textContent = parseFloat(vv).toFixed(2);
            };

            syncSeaUI(seaThreshold);

            seaSlider.addEventListener('input', (e) => {
                const value = clampSea(parseFloat(e.target.value));
                seaThreshold = value;
                seaValue.textContent = value.toFixed(2);
                seaInput.value = value;
                applySeaThreshold();
            });

            seaInput.addEventListener('input', (e) => {
                const raw = parseFloat(e.target.value);
                if (isNaN(raw)) return;
                const value = clampSea(raw);
                seaThreshold = value;
                seaSlider.value = value;
                seaValue.textContent = value.toFixed(2);
                applySeaThreshold();
            });

            // Sea level height control (live update ocean flat height)
            const seaHeightSlider = document.getElementById('sea-height');
            const seaHeightInput = document.getElementById('sea-height-input');
            const seaHeightValue = document.getElementById('sea-height-value');
            const clampSeaHeight = (v) => Math.max(parseFloat(seaHeightSlider.min), Math.min(parseFloat(seaHeightSlider.max), v));

            const syncSeaHeightUI = (v) => {
                const vv = clampSeaHeight(v);
                seaHeightSlider.value = vv;
                seaHeightInput.value = vv;
                seaHeightValue.textContent = parseFloat(vv).toFixed(2);
            };

            syncSeaHeightUI(seaFlatHeight);

            const applySeaHeight = (value) => {
                seaFlatHeight = value;
                applySeaThreshold();
            };

            seaHeightSlider.addEventListener('input', (e) => {
                const value = clampSeaHeight(parseFloat(e.target.value));
                syncSeaHeightUI(value);
                applySeaHeight(value);
            });
            seaHeightInput.addEventListener('input', (e) => {
                const raw = parseFloat(e.target.value);
                if (isNaN(raw)) return;
                const value = clampSeaHeight(raw);
                syncSeaHeightUI(value);
                applySeaHeight(value);
            });

            // Material rotation slider
            const matRotSlider = document.getElementById('mat-rotation');
            const matRotValue = document.getElementById('mat-rotation-value');
            matRotSlider.value = matRotationDeg;
            matRotValue.textContent = Math.round(matRotationDeg);
            matRotSlider.addEventListener('input', (e) => {
                matRotationDeg = parseFloat(e.target.value) || 0;
                matRotValue.textContent = Math.round(matRotationDeg);
                applySeaThreshold();
            });

            // Material flip toggles
            const flipUEl = document.getElementById('mat-flip-u');
            const flipVEl = document.getElementById('mat-flip-v');
            flipUEl.checked = !!flipMaterialU;
            flipVEl.checked = !!flipMaterialV;
            flipUEl.addEventListener('change', (e) => {
                flipMaterialU = !!e.target.checked;
                applySeaThreshold();
            });
            flipVEl.addEventListener('change', (e) => {
                flipMaterialV = !!e.target.checked;
                applySeaThreshold();
            });
        }

        function loadTexturePromise(url) {
            return new Promise((resolve, reject) => {
                new THREE.TextureLoader().load(url, (texture) => {
                    // Use linear filtering for smooth, non-pixelated textures
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    resolve(texture);
                }, undefined, reject);
            });
        }

        function getImageDataFromTexture(tex) {
            const img = tex.image;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            return { data: imageData.data, width: canvas.width, height: canvas.height };
        }

        function loadHeightmap() {
            console.log('Loading maps...');
            const cacheBuster = '?t=' + Date.now();
            Promise.all([
                loadTexturePromise('TerrainFromWorldBuilder4.png' + cacheBuster),
                loadTexturePromise('Terrain/Islands_MaterialForBlender.jpg' + cacheBuster)
            ]).then(async ([heightTex, materialTex]) => {
                const h = getImageDataFromTexture(heightTex);
                const m = getImageDataFromTexture(materialTex);

                // Store material globally for land coloring
                matImageData = m.data;
                matW = m.width;
                matH = m.height;

                console.log('Creating terrain grid...');
                await createGridTerrain(h.data, h.width, h.height, materialTex);
                console.log('Terrain created, starting animation');

                document.getElementById('loading').style.display = 'none';

                animationStartTime = Date.now();
                startCameraIntro();
            }).catch((error) => {
                console.error('Error loading maps:', error);
                document.getElementById('loading').innerText = 'ERROR LOADING TERRAIN';
            });
        }

        // Simple noise function
        function noise2D(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return n - Math.floor(n);
        }

        // Sample material color with optional V-flip and rotation
        function sampleMaterialColor(u, v) {
            if (!matImageData) return [1, 1, 1];
            let uu = Math.max(0, Math.min(1, u));
            let vv = Math.max(0, Math.min(1, v));
            // Apply flips first if enabled
            if (flipMaterialU) uu = 1 - uu;
            if (flipMaterialV) vv = 1 - vv;
            // Apply rotation about center (0.5, 0.5)
            if (matRotationDeg !== 0) {
                const rad = matRotationDeg * Math.PI / 180;
                const cosr = Math.cos(rad);
                const sinr = Math.sin(rad);
                const cx = uu - 0.5;
                const cy = vv - 0.5;
                const rx = cx * cosr - cy * sinr;
                const ry = cx * sinr + cy * cosr;
                uu = Math.max(0, Math.min(1, rx + 0.5));
                vv = Math.max(0, Math.min(1, ry + 0.5));
            }
            const x = Math.min(matW - 1, Math.floor(uu * matW));
            const y = Math.min(matH - 1, Math.floor(vv * matH));
            const i = (y * matW + x) * 4;
            return [matImageData[i] / 255, matImageData[i + 1] / 255, matImageData[i + 2] / 255];
        }

        async function createGridTerrain(data, width, height, materialTex) {
            const segments = Math.min(width, height) / sampleRate;

            // Create plane geometry with segments matching the texture resolution
            const geometry = new THREE.PlaneGeometry(128, 128, segments - 1, segments - 1);

            // Apply the material texture directly
            const material = new THREE.MeshBasicMaterial({
                map: materialTex,
                side: THREE.DoubleSide
            });

            // Get position attribute to modify heights
            const positions = geometry.attributes.position;

            // Modify vertex heights based on heightmap
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getY(i); // In PlaneGeometry, Y is the vertical axis

                // Convert world position to texture coordinates
                const u = (x + 64) / 128; // 0 to 1
                const v = (z + 64) / 128; // 0 to 1

                // Sample heightmap
                const dataX = Math.floor(u * width);
                const dataZ = Math.floor(v * height);
                const index = (dataZ * width + dataX) * 4;
                const grayscale = data[index] / 255;

                // Calculate vertex height
                const isOcean = grayscale <= seaThreshold;
                const vertexHeight = isOcean ? seaFlatHeight : (grayscale * heightScale + 0.5);

                // Set Z position (height in plane geometry)
                positions.setZ(i, vertexHeight);
            }

            positions.needsUpdate = true;
            geometry.computeVertexNormals(); // Recalculate normals for proper lighting

            // Create mesh
            instancedMesh = new THREE.Mesh(geometry, material);
            instancedMesh.rotation.x = -Math.PI / 2; // Rotate to lay flat
            scene.add(instancedMesh);

            // Initialize empty cubeData for compatibility
            cubeData = [];

            // Load saved custom colors
            await loadCustomColors();

            // Start auto-sync to get updates from other users
            startAutoSync();

            // Create journey markers and line after terrain is ready
            createJourneySystem(data, width, height);
        }

        // Get terrain height at a given world position
        function getTerrainHeight(worldX, worldZ, heightData, dataWidth, dataHeight) {
            // Convert world position to texture coordinates
            const u = (worldX + 64) / 128;
            const v = (worldZ + 64) / 128;

            // Clamp to valid range
            const clampedU = Math.max(0, Math.min(1, u));
            const clampedV = Math.max(0, Math.min(1, v));

            // Sample heightmap
            const dataX = Math.floor(clampedU * dataWidth);
            const dataZ = Math.floor(clampedV * dataHeight);
            const index = (dataZ * dataWidth + dataX) * 4;
            const grayscale = heightData[index] / 255;

            // Calculate height
            const isOcean = grayscale <= seaThreshold;
            return isOcean ? seaFlatHeight : (grayscale * heightScale + 0.5);
        }

        // Create journey markers and connecting line
        function createJourneySystem(heightData, dataWidth, dataHeight) {
            const linePoints = [];

            journeyPoints.forEach((point, index) => {
                // Get terrain height at this position
                const terrainHeight = getTerrainHeight(point.x, point.z, heightData, dataWidth, dataHeight);
                point.y = terrainHeight + 2; // Slightly above terrain

                // Create 3D sphere marker
                const sphereGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0x6b4ce6,
                    transparent: true,
                    opacity: 0.9
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(point.x, point.y, point.z);
                sphere.userData = { journeyPoint: point, index: index };
                scene.add(sphere);

                // Create pulsing ring around sphere
                const ringGeometry = new THREE.RingGeometry(2, 2.5, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x6b4ce6,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.set(point.x, point.y, point.z);
                ring.rotation.x = -Math.PI / 2;
                ring.userData = { pulseTime: index * 0.5 }; // Offset pulse timing
                scene.add(ring);

                // Create CSS2D label
                const labelDiv = document.createElement('div');
                labelDiv.className = 'journey-marker';
                labelDiv.innerHTML = `
                    <span class="material-symbols-outlined">${point.icon}</span>
                    <span>${point.name}</span>
                `;
                const label = new CSS2DObject(labelDiv);
                label.position.set(point.x, point.y + 3, point.z);
                scene.add(label);

                journeyMarkers.push({
                    point: point,
                    sphere: sphere,
                    ring: ring,
                    label: label
                });

                // Add to line points
                linePoints.push(new THREE.Vector3(point.x, point.y + 0.5, point.z));
            });

            // Create connecting line using CatmullRomCurve3 for smooth path
            if (linePoints.length > 1) {
                const curve = new THREE.CatmullRomCurve3(linePoints, false, 'catmullrom', 0.5);
                const curvePoints = curve.getPoints(100);
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x6b4ce6,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 2
                });
                journeyLine = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(journeyLine);

                // Create animated dashed line on top
                const dashGeometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
                const dashMaterial = new THREE.LineDashedMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8,
                    dashSize: 2,
                    gapSize: 1
                });
                const dashLine = new THREE.Line(dashGeometry, dashMaterial);
                dashLine.computeLineDistances();
                dashLine.userData = { dashOffset: 0 };
                scene.add(dashLine);
                journeyLine.userData = { dashLine: dashLine };
            }
        }

        // Animate journey elements
        function animateJourney() {
            const time = Date.now() * 0.001;

            journeyMarkers.forEach((marker, index) => {
                // Pulse effect on rings
                const pulsePhase = time + marker.ring.userData.pulseTime;
                const pulseScale = 1 + Math.sin(pulsePhase * 2) * 0.2;
                marker.ring.scale.set(pulseScale, pulseScale, 1);
                marker.ring.material.opacity = 0.3 + Math.sin(pulsePhase * 2) * 0.2;

                // Gentle bob on spheres
                const bobOffset = Math.sin(time * 1.5 + index * 0.7) * 0.3;
                marker.sphere.position.y = marker.point.y + bobOffset;
                marker.label.position.y = marker.point.y + 3 + bobOffset;
            });

            // Animate dashed line
            if (journeyLine && journeyLine.userData.dashLine) {
                const dashLine = journeyLine.userData.dashLine;
                dashLine.userData.dashOffset -= 0.05;
                dashLine.material.dashOffset = dashLine.userData.dashOffset;
            }
        }

        // Handle journey point click
        function onJourneyPointClick(marker) {
            selectedJourneyPoint = marker;

            // Save current camera state
            journeySavedCameraPos = camera.position.clone();
            journeySavedTarget = controls.target.clone();

            // Start transition
            journeyTransitioning = true;
            journeyTransitionProgress = 0;
            controls.enabled = false;
        }

        // Update journey camera transition
        function updateJourneyCamera() {
            if (!journeyTransitioning || !selectedJourneyPoint) return;

            journeyTransitionProgress += 0.02;
            if (journeyTransitionProgress >= 1) {
                journeyTransitionProgress = 1;
                journeyTransitioning = false;

                // Show media popup when zoom complete
                showMediaPopup(selectedJourneyPoint.point);
            }

            const eased = 1 - Math.pow(1 - journeyTransitionProgress, 3);

            // Calculate target camera position (close to the point)
            const point = selectedJourneyPoint.point;
            const targetPos = new THREE.Vector3(
                point.x + 15,
                point.y + 12,
                point.z + 15
            );
            const targetLookAt = new THREE.Vector3(point.x, point.y, point.z);

            // Lerp camera
            camera.position.lerpVectors(journeySavedCameraPos, targetPos, eased);
            controls.target.lerpVectors(journeySavedTarget, targetLookAt, eased);
            camera.lookAt(controls.target);
        }

        // Show media popup
        function showMediaPopup(point) {
            const popup = document.getElementById('media-popup');
            const title = document.getElementById('media-title');
            const description = document.getElementById('media-description');
            const placeholder = document.getElementById('media-placeholder');

            title.textContent = point.name;
            description.textContent = point.description;

            // Set media content
            if (point.media && point.mediaType === 'image') {
                placeholder.innerHTML = `<img src="${point.media}" alt="${point.name}" style="max-width: 100%; max-height: 300px; border-radius: 12px; object-fit: cover;">`;
            } else if (point.mediaType === 'video') {
                placeholder.innerHTML = `<video controls style="max-width: 100%; max-height: 300px; border-radius: 12px;"><source src="${point.media}" type="video/mp4">Your browser does not support video.</video>`;
            } else {
                placeholder.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
            }

            popup.classList.add('visible');
        }

        // Close media popup (global function for onclick)
        window.closeMediaPopup = function() {
            const popup = document.getElementById('media-popup');
            popup.classList.remove('visible');

            // Return camera to saved position
            if (journeySavedCameraPos && journeySavedTarget) {
                journeyTransitioning = true;
                journeyTransitionProgress = 0;

                const returnTransition = () => {
                    journeyTransitionProgress += 0.03;
                    if (journeyTransitionProgress >= 1) {
                        journeyTransitionProgress = 1;
                        controls.enabled = true;
                        selectedJourneyPoint = null;
                        journeyTransitioning = false;
                        return;
                    }

                    const eased = 1 - Math.pow(1 - journeyTransitionProgress, 3);
                    camera.position.lerp(journeySavedCameraPos, eased * 0.1);
                    controls.target.lerp(journeySavedTarget, eased * 0.1);
                    camera.lookAt(controls.target);

                    requestAnimationFrame(returnTransition);
                };

                returnTransition();
            } else {
                controls.enabled = true;
                selectedJourneyPoint = null;
            }
        };

        // Also close popup when clicking outside
        document.getElementById('media-popup').addEventListener('click', function(e) {
            if (e.target === this) {
                closeMediaPopup();
            }
        });

        function getAnimationDelay(x, z, width, height) {
            // Ripple from center
            const centerX = width / 2;
            const centerZ = height / 2;
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(z - centerZ, 2));
            const maxDistance = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerZ, 2));
            return (distance / maxDistance) * 2000; // 2 second wave
        }

        function startCameraIntro() {
            const midPoint = new THREE.Vector3(
                cameraStartPos.x + 30,
                cameraStartPos.y - 70,
                cameraStartPos.z + 60
            );

            if (!cameraMixer) {
                cameraMixer = new THREE.AnimationMixer(camera);

                // Build a smooth curve through start -> mid -> end
                const start = new THREE.Vector3(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
                const end = new THREE.Vector3(cameraEndPos.x, cameraEndPos.y, cameraEndPos.z);
                const curve = new THREE.CatmullRomCurve3([start, midPoint, end], false, 'catmullrom', 0.5);

                // Sample the curve to create a single smooth motion
                // Shorter duration for earlier stop, with ease-out for gentle finish
                const duration = 3.2; // seconds
                const samples = 100;
                const times = new Float32Array(samples);
                const values = new Float32Array(samples * 3);

                for (let i = 0; i < samples; i++) {
                    const t = i / (samples - 1);
                    // Ease-out on the curve parameter so motion decelerates near the end
                    const te = 1 - Math.pow(1 - t, 3); // easeOutCubic
                    const p = curve.getPoint(te);
                    times[i] = t * duration;
                    values[i * 3 + 0] = p.x;
                    values[i * 3 + 1] = p.y;
                    values[i * 3 + 2] = p.z;
                }

                const positionTrack = new THREE.VectorKeyframeTrack('.position', times, values);
                positionTrack.setInterpolation(THREE.InterpolateSmooth);
                const clip = new THREE.AnimationClip('CameraIntro', duration, [positionTrack]);

                cameraAction = cameraMixer.clipAction(clip);
                cameraAction.setLoop(THREE.LoopOnce, 1);
                cameraAction.clampWhenFinished = true;

                cameraMixer.addEventListener('finished', (event) => {
                    if (event.action === cameraAction) {
                        cameraIntroPlaying = false;
                        updateCameraControlDisplays();
                    }
                });
            }

            camera.position.set(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
            controls.target.set(0, 0, 0);
            controls.update();

            if (cameraAction) {
                cameraAction.reset();
                cameraAction.play();
            }

            cameraIntroPlaying = true;
            updateCameraControlDisplays();
        }

        function updateCameraControlDisplays() {
            const yActive = posYSlider && document.activeElement === posYSlider;
            if (posYSlider && !yActive) {
                posYSlider.value = Math.round(camera.position.y);
            }
            if (posYValueDisplay && !yActive) {
                posYValueDisplay.textContent = Math.round(camera.position.y);
            }

            const xActive = posXSlider && document.activeElement === posXSlider;
            if (posXSlider && !xActive) {
                posXSlider.value = Math.round(camera.position.x);
            }
            if (posXValueDisplay && !xActive) {
                posXValueDisplay.textContent = Math.round(camera.position.x);
            }
        }

        function easeOutBack(x) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
        }

        function animateCubes() {
            if (!instancedMesh) return;

            const elapsed = Date.now() - animationStartTime;
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();
            let needsUpdate = false;
            

            cubeData.forEach(cube => {
                let heightToUse = cube.currentHeight;

                if (!cube.animated) {
                    const timeSinceDelay = elapsed - cube.delay;

                    if (timeSinceDelay > 0) {
                        const duration = 800;
                        const progress = Math.min(timeSinceDelay / duration, 1);

                        if (progress >= 1) {
                            cube.animated = true;
                        }

                        const easedProgress = easeOutBack(progress);
                        cube.currentHeight = cube.targetHeight * easedProgress;
                        heightToUse = cube.currentHeight;
                        needsUpdate = true;
                    }
                }

                if (needsUpdate) {
                    // Update instance matrix
                    position.set(cube.x, heightToUse / 2, cube.z);
                    scale.set(1, Math.max(0.01, heightToUse), 1);
                    matrix.compose(position, quaternion, scale);
                    instancedMesh.setMatrixAt(cube.index, matrix);
                }
            });

            if (needsUpdate) {
                instancedMesh.instanceMatrix.needsUpdate = true;
            }
            
        }

        function applySeaThreshold() {
            if (!instancedMesh) return;

            const oceanColor = new THREE.Color(0x006994); // Ocean blue
            const tempColor = new THREE.Color();
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();

            cubeData.forEach((cube) => {
                const isOcean = cube.grayscale <= seaThreshold;
                cube.isOcean = isOcean;
                const newTarget = isOcean ? seaFlatHeight : (cube.grayscale * heightScale + 0.5);
                cube.targetHeight = newTarget;
                cube.currentHeight = newTarget;
                cube.animated = true;

                // Update color
                if (isOcean) {
                    tempColor.copy(oceanColor);
                } else {
                    // Sample land color from material map honoring rotation
                    const baseU = cube.u !== undefined ? cube.u : 0;
                    const baseV = cube.v !== undefined ? cube.v : 0;
                    const [sr, sg, sb] = sampleMaterialColor(baseU, baseV);
                    tempColor.setRGB(sr, sg, sb);
                }

                // Update original color for this cube
                cube.originalColor = tempColor.clone();
                instancedMesh.setColorAt(cube.index, tempColor);

                // Update transform
                position.set(cube.x, newTarget / 2, cube.z);
                scale.set(1, Math.max(0.01, newTarget), 1);
                matrix.compose(position, quaternion, scale);
                instancedMesh.setMatrixAt(cube.index, matrix);
            });

            if (instancedMesh.instanceColor) {
                instancedMesh.instanceColor.needsUpdate = true;
            }
            instancedMesh.instanceMatrix.needsUpdate = true;
        }

        function applyHeightScale() {
            if (!instancedMesh) return;

            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();

            cubeData.forEach((cube) => {
                const isOcean = cube.grayscale <= seaThreshold;
                const newTarget = isOcean ? seaFlatHeight : (cube.grayscale * heightScale + 0.5);
                cube.isOcean = isOcean;
                cube.targetHeight = newTarget;
                cube.currentHeight = newTarget;
                cube.animated = true;

                // Update transform only (colors unchanged here)
                position.set(cube.x, newTarget / 2, cube.z);
                scale.set(1, Math.max(0.01, newTarget), 1);
                matrix.compose(position, quaternion, scale);
                instancedMesh.setMatrixAt(cube.index, matrix);
            });

            instancedMesh.instanceMatrix.needsUpdate = true;
        }

        function onMouseDown(event) {
            mouseDownPos.x = event.clientX;
            mouseDownPos.y = event.clientY;
            isDragging = false;

            // Stop camera intro animation if user clicks/drags
            if (cameraIntroPlaying) {
                if (cameraAction) {
                    cameraAction.stop();
                }
                cameraIntroPlaying = false;
                controls.enabled = true;
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check if mouse moved significantly from mousedown position
            if (mouseDownPos.x !== undefined && mouseDownPos.y !== undefined) {
                const dx = event.clientX - mouseDownPos.x;
                const dy = event.clientY - mouseDownPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 5) { // 5 pixel threshold
                    isDragging = true;
                }
            }
        }

        function onMouseUp(event) {
            // Reset mousedown position
            mouseDownPos.x = undefined;
            mouseDownPos.y = undefined;

            // Reset after a short delay to allow click event to fire
            setTimeout(() => {
                isDragging = false;
            }, 50);
        }

        function showNotification(success, message, cubeIndex = -1) {
            const notification = document.getElementById('notification');
            const icon = notification.querySelector('.icon');
            const messageEl = notification.querySelector('.message');

            // Update content
            icon.textContent = success ? '‚úì' : '‚úï';
            messageEl.textContent = message;

            // Position above the cube if index provided
            if (cubeIndex >= 0 && cubeIndex < cubeData.length) {
                const cube = cubeData[cubeIndex];
                const worldPos = new THREE.Vector3(cube.x, cube.currentHeight + 10, cube.z);
                const screenPos = worldPos.project(camera);

                const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

                notification.style.left = `${x}px`;
                notification.style.top = `${y - 20}px`; // Offset for animation
                notification.style.transform = 'translate(-50%, -100%)';
            }

            // Update styling and show
            notification.className = success ? 'success visible' : 'error visible';

            // Auto-hide after 2 seconds
            setTimeout(() => {
                notification.classList.remove('visible');
            }, 2000);
        }

        async function saveCustomColors(cubeIndex = -1) {
            // Set save time immediately to prevent auto-sync race condition
            lastSaveTime = Date.now();

            try {
                // First, fetch the latest data to merge with
                let existingData = {};
                try {
                    const getResponse = await fetch(`${JSONBIN_URL}/latest`, {
                        method: 'GET',
                        headers: {
                            'X-Master-Key': JSONBIN_API_KEY
                        }
                    });

                    if (getResponse.ok) {
                        const result = await getResponse.json();
                        existingData = result.record?.cubes || {};
                        console.log('Fetched existing data, cubes:', Object.keys(existingData).length);
                    }
                } catch (e) {
                    console.warn('Could not fetch existing data, will overwrite:', e);
                }

                // Merge our changes with existing data
                const mergedData = { ...existingData };
                cubeData.forEach(cube => {
                    const hasData = cube.customColor || cube.label || cube.icon;
                    const existsInBin = existingData[cube.index];

                    if (hasData || existsInBin) {
                        // Save if has data OR if it exists in bin (to update/clear it)
                        if (hasData) {
                            const savedData = {
                                color: cube.customColor ? '#' + cube.customColor.getHexString() : null,
                                label: cube.label || '',
                                icon: cube.icon || ''
                            };
                            console.log('Saving cube', cube.index, 'with data:', savedData);
                            mergedData[cube.index] = savedData;
                        } else {
                            // Remove from bin if no data
                            console.log('Deleting cube', cube.index, 'from bin (no custom data)');
                            delete mergedData[cube.index];
                        }
                    }
                });

                console.log('Saving to JSONBin, total cubes:', Object.keys(mergedData).length);
                const response = await fetch(JSONBIN_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': JSONBIN_API_KEY
                    },
                    body: JSON.stringify({ cubes: mergedData })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Failed to save to JSONBin:', response.status, response.statusText, errorText);
                    showNotification(false, 'Changes not saved', cubeIndex);
                    return false;
                }

                const saveResult = await response.json();
                console.log('Save successful:', saveResult);
                showNotification(true, 'Changes saved', cubeIndex);
                return true;
            } catch (error) {
                console.error('Error saving to JSONBin:', error);
                showNotification(false, 'Changes not saved', cubeIndex);
                return false;
            }
        }

        async function loadCustomColors() {
            try {
                const response = await fetch(`${JSONBIN_URL}/latest`, {
                    method: 'GET',
                    headers: {
                        'X-Master-Key': JSONBIN_API_KEY
                    }
                });

                if (!response.ok) {
                    console.error('Failed to load from JSONBin:', response.statusText);
                    return;
                }

                const result = await response.json();
                const customData = result.record?.cubes || {};

                Object.keys(customData).forEach(index => {
                    const idx = parseInt(index);
                    if (idx >= 0 && idx < cubeData.length) {
                        const data = customData[index];

                        // Load color
                        if (data.color) {
                            cubeData[idx].customColor = new THREE.Color(data.color);
                        } else if (typeof data === 'string') {
                            // Backward compatibility with old format
                            cubeData[idx].customColor = new THREE.Color(data);
                        }

                        // Load label and icon
                        if (data.label || data.icon) {
                            cubeData[idx].label = data.label || '';
                            cubeData[idx].icon = data.icon || '';
                            updateCubeLabel(cubeData[idx], data.label, data.icon);
                        }
                    }
                });
            } catch (e) {
                console.error('Failed to load custom colors:', e);
            }
        }

        function startAutoSync() {
            // Poll for updates every 5 seconds
            setInterval(async () => {
                // Skip if we just saved (avoid overwriting our own changes)
                if (Date.now() - lastSaveTime < 10000) {
                    return;
                }

                try {
                    const response = await fetch(`${JSONBIN_URL}/latest`, {
                        method: 'GET',
                        headers: {
                            'X-Master-Key': JSONBIN_API_KEY
                        }
                    });

                    if (!response.ok) return;

                    const result = await response.json();
                    const customData = result.record?.cubes || {};

                    // First, clear any cubes that were deleted from the bin
                    cubeData.forEach((cube, idx) => {
                        // Skip if currently selected to avoid conflicts
                        if (cube.index === selectedCubeIndex) return;

                        // If cube has custom data locally but not in bin, clear it
                        if ((cube.customColor || cube.label || cube.icon) && !customData[idx]) {
                            console.log('Auto-sync: Clearing cube', idx, 'as it was deleted from bin');
                            cube.customColor = null;
                            cube.label = '';
                            cube.icon = '';
                            updateCubeLabel(cube, '', '');
                        }
                    });

                    // Update cubes that have changed
                    Object.keys(customData).forEach(index => {
                        const idx = parseInt(index);
                        if (idx >= 0 && idx < cubeData.length) {
                            const data = customData[index];
                            const cube = cubeData[idx];

                            // Check if this cube needs updating (skip if currently selected to avoid conflicts)
                            if (cube.index === selectedCubeIndex) return;

                            // Update color if changed
                            const newColorHex = data.color;
                            const currentColorHex = cube.customColor ? '#' + cube.customColor.getHexString() : null;
                            if (newColorHex !== currentColorHex) {
                                console.log('Auto-sync: Updating cube', idx, 'color from', currentColorHex, 'to', newColorHex);
                                cube.customColor = newColorHex ? new THREE.Color(newColorHex) : null;
                            }

                            // Update label/icon if changed
                            const newLabel = data.label || '';
                            const newIcon = data.icon || '';
                            if (cube.label !== newLabel || cube.icon !== newIcon) {
                                cube.label = newLabel;
                                cube.icon = newIcon;
                                updateCubeLabel(cube, newLabel, newIcon);
                            }
                        }
                    });
                } catch (e) {
                    // Silently fail - don't spam console with sync errors
                }
            }, 5000); // Sync every 5 seconds
        }

        function updateCubeLabel(cube, labelText, iconName) {
            // Remove existing label
            if (cube.labelObject) {
                scene.remove(cube.labelObject);
                cube.labelObject = null;
            }

            // Update cube data
            cube.label = labelText ? labelText.trim() : '';
            cube.icon = iconName || '';

            // Create new label if text or icon is provided
            if (cube.label || cube.icon) {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'cube-label';

                // Add icon if provided
                if (cube.icon) {
                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'material-symbols-outlined';
                    iconSpan.textContent = cube.icon;
                    labelDiv.appendChild(iconSpan);
                }

                // Add text if provided
                if (cube.label) {
                    const textSpan = document.createElement('span');
                    textSpan.textContent = cube.label;
                    labelDiv.appendChild(textSpan);
                }

                const label = new CSS2DObject(labelDiv);
                const totalHeight = cube.currentHeight + cube.hoverElevation;
                label.position.set(cube.x, totalHeight + 2, cube.z);
                scene.add(label);

                cube.labelObject = label;
            }
        }

        function setupColorSwatches() {
            const swatches = document.querySelectorAll('.color-swatch');
            const cube = cubeData[selectedCubeIndex];

            // Setup icon preset dropdown
            const iconSelect = document.getElementById('cube-icon');
            const newIconSelect = iconSelect.cloneNode(true);
            iconSelect.parentNode.replaceChild(newIconSelect, iconSelect);

            // Check if current icon is in preset options
            const isPresetIcon = Array.from(newIconSelect.options).some(opt => opt.value === cube.icon);

            if (isPresetIcon) {
                newIconSelect.value = cube.icon;
            } else {
                newIconSelect.value = '';
            }

            newIconSelect.addEventListener('change', (e) => {
                const customInput = document.getElementById('cube-icon-custom');
                customInput.value = ''; // Clear custom input when preset is selected
                updateCubeLabel(cube, cube.label, e.target.value);
            });

            newIconSelect.addEventListener('mousedown', (e) => e.stopPropagation());
            newIconSelect.addEventListener('click', (e) => e.stopPropagation());

            // Setup custom icon input
            const customIconInput = document.getElementById('cube-icon-custom');
            const newCustomIconInput = customIconInput.cloneNode(true);
            customIconInput.parentNode.replaceChild(newCustomIconInput, customIconInput);

            // Show custom icon if it's not a preset
            if (cube.icon && !isPresetIcon) {
                newCustomIconInput.value = cube.icon;
            } else {
                newCustomIconInput.value = '';
            }

            newCustomIconInput.addEventListener('input', (e) => {
                const select = document.getElementById('cube-icon');
                select.value = ''; // Clear preset when custom is typed
                updateCubeLabel(cube, cube.label, e.target.value.trim());
            });

            newCustomIconInput.addEventListener('mousedown', (e) => e.stopPropagation());
            newCustomIconInput.addEventListener('click', (e) => e.stopPropagation());

            // Setup label input
            const labelInput = document.getElementById('cube-label');
            labelInput.value = cube.label || '';

            const newLabelInput = labelInput.cloneNode(true);
            labelInput.parentNode.replaceChild(newLabelInput, labelInput);

            newLabelInput.addEventListener('input', (e) => {
                updateCubeLabel(cube, e.target.value, cube.icon);
            });

            newLabelInput.addEventListener('mousedown', (e) => e.stopPropagation());
            newLabelInput.addEventListener('click', (e) => e.stopPropagation());

            // Remove previous listeners
            swatches.forEach(swatch => {
                const clone = swatch.cloneNode(true);
                swatch.parentNode.replaceChild(clone, swatch);
            });

            // Re-query after cloning
            const newSwatches = document.querySelectorAll('.color-swatch');

            newSwatches.forEach(swatch => {
                // Mark currently selected color
                const swatchColor = swatch.getAttribute('data-color');
                if (swatchColor === 'original' && !cube.customColor) {
                    swatch.classList.add('selected');
                } else if (cube.customColor && swatchColor === '#' + cube.customColor.getHexString()) {
                    swatch.classList.add('selected');
                }

                // Add click listener
                swatch.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent click from bubbling to window
                    const color = swatch.getAttribute('data-color');

                    // Remove selected from all swatches
                    newSwatches.forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');

                    // Update cube's custom color (updateHover will apply it)
                    if (color === 'original') {
                        cube.customColor = null;
                    } else {
                        cube.customColor = new THREE.Color(color);
                    }
                });
            });
        }

        function onMouseClick(event) {
            if (cameraIntroPlaying) return; // Don't allow clicks during intro
            if (isDragging) return; // Don't allow selection if dragging
            if (selectedJourneyPoint) return; // Don't allow clicks while viewing journey point

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check for journey marker clicks
            raycaster.setFromCamera(mouse, camera);
            const journeySpheres = journeyMarkers.map(m => m.sphere);
            const journeyIntersects = raycaster.intersectObjects(journeySpheres);

            if (journeyIntersects.length > 0) {
                const clickedSphere = journeyIntersects[0].object;
                const marker = journeyMarkers.find(m => m.sphere === clickedSphere);
                if (marker) {
                    onJourneyPointClick(marker);
                    return;
                }
            }

            // Clicking anywhere now just deselects (no cube selection in plane mode)
            if (selectedCubeIndex !== -1) {
                deselectCube();
                return;
            }
        }

        function selectCube(index) {
            if (index < 0 || index >= cubeData.length) return;

            selectedCubeIndex = index;
            const cube = cubeData[index];

            // Save initial state for change detection
            cubeEditChanged = false;
            initialCubeState = {
                color: cube.customColor ? cube.customColor.clone() : null,
                label: cube.label || '',
                icon: cube.icon || ''
            };

            // Save current camera state
            if (!isOrbiting) {
                savedCameraPos = camera.position.clone();
                savedControlsTarget = controls.target.clone();
            }

            // Start transition to cube
            cameraTransitioning = true;
            cameraTransitionProgress = 0;
            isOrbiting = true;
            orbitAngle = 0;

            // Disable controls during orbit
            controls.enabled = false;

            // Show color picker
            const colorPicker = document.getElementById('color-picker');

            // Fixed position: right side, vertically centered
            const pickerWidth = 300;
            const margin = 30;

            colorPicker.style.right = `${margin}px`;
            colorPicker.style.left = 'auto';
            colorPicker.style.top = '50%';
            colorPicker.style.transform = 'translateY(-50%)';

            colorPicker.classList.add('visible');

            // Setup color swatches
            setupColorSwatches();
        }

        function deselectCube() {
            if (selectedCubeIndex === -1) return;

            const cubeIndex = selectedCubeIndex;
            const cube = cubeData[cubeIndex];

            // Check if anything changed
            const hasChanges = checkIfCubeChanged(cube);

            selectedCubeIndex = -1;

            // Only save if changes were made
            if (hasChanges) {
                saveCustomColors(cubeIndex);
            }

            // Transition back to saved position
            if (savedCameraPos && savedControlsTarget) {
                cameraTransitioning = true;
                cameraTransitionProgress = 0;
                isOrbiting = false;
                // Controls will be re-enabled in updateCameraOrbit when transition completes
            }

            // Hide color picker
            const colorPicker = document.getElementById('color-picker');
            colorPicker.classList.remove('visible');
        }

        function checkIfCubeChanged(cube) {
            if (!initialCubeState) return false;

            const currentColor = cube.customColor ? cube.customColor.getHexString() : null;
            const initialColor = initialCubeState.color ? initialCubeState.color.getHexString() : null;

            return currentColor !== initialColor ||
                   cube.label !== initialCubeState.label ||
                   cube.icon !== initialCubeState.icon;
        }

        function updateCameraOrbit() {
            // Handle transition back to normal
            if (!isOrbiting && cameraTransitioning && savedCameraPos && savedControlsTarget) {
                cameraTransitionProgress += 0.05;
                if (cameraTransitionProgress >= 1) {
                    cameraTransitionProgress = 1;
                    cameraTransitioning = false;
                    controls.enabled = true;
                }

                const eased = 1 - Math.pow(1 - cameraTransitionProgress, 3); // ease out
                camera.position.lerpVectors(camera.position.clone(), savedCameraPos, eased * 0.2);
                controls.target.lerpVectors(controls.target.clone(), savedControlsTarget, eased * 0.2);
                camera.lookAt(controls.target);
                return;
            }

            if (!isOrbiting || selectedCubeIndex === -1) return;

            const cube = cubeData[selectedCubeIndex];
            const cubeWorldPos = new THREE.Vector3(cube.x, cube.currentHeight + 2, cube.z);

            // Camera orbit parameters
            const orbitRadius = 15;
            const orbitHeight = 15; // Height above the top of the cube
            const orbitSpeed = 0.001; // Slower rotation

            // Update orbit angle
            orbitAngle += orbitSpeed;

            // Calculate camera position
            const targetCameraPos = new THREE.Vector3(
                cubeWorldPos.x + Math.cos(orbitAngle) * orbitRadius,
                cubeWorldPos.y + orbitHeight,
                cubeWorldPos.z + Math.sin(orbitAngle) * orbitRadius
            );

            // Animate transition to orbit position
            if (cameraTransitioning) {
                cameraTransitionProgress += 0.05;
                if (cameraTransitionProgress >= 1) {
                    cameraTransitionProgress = 1;
                    cameraTransitioning = false;
                }

                const eased = 1 - Math.pow(1 - cameraTransitionProgress, 3); // ease out
                camera.position.lerpVectors(savedCameraPos, targetCameraPos, eased);
                controls.target.lerpVectors(savedControlsTarget, cubeWorldPos, eased);
            } else {
                // Smooth orbit around cube
                camera.position.copy(targetCameraPos);
                controls.target.copy(cubeWorldPos);
            }

            camera.lookAt(controls.target);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateCameraAnimation(delta) {
            if (!cameraMixer || !cameraAction) return;

            cameraMixer.update(delta);

            if (cameraIntroPlaying) {
                updateCameraControlDisplays();
            }
        }

        function updateHover() {
            // Hover and cube interaction disabled in plane mode
            if (cubeData.length === 0) return;

            // Still animate cubes if they exist (for backwards compatibility)
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();
            const tempColor = new THREE.Color();
            let needsUpdate = false;
            let colorNeedsUpdate = false;

            cubeData.forEach(cube => {
                // If this cube is selected, keep it elevated and white
                const isSelected = cube.index === selectedCubeIndex;
                const hasCustomColor = cube.customColor !== null && cube.customColor !== undefined;
                const targetProgress = (cube.isHovered || isSelected || hasCustomColor) ? 1 : 0;

                // Animate hover progress
                const progressChanged = cube.hoverProgress !== targetProgress;
                const hoverStateChanged = cube.wasHovered !== cube.isHovered;
                cube.wasHovered = cube.isHovered;

                if (progressChanged) {
                    const speed = 0.15; // Animation speed
                    cube.hoverProgress += (targetProgress - cube.hoverProgress) * speed;

                    // Clamp to target when very close
                    if (Math.abs(cube.hoverProgress - targetProgress) < 0.01) {
                        cube.hoverProgress = targetProgress;
                    }
                }

                // Animate elevation bonus for colored cubes when hovering
                const targetElevationBonus = (hasCustomColor && cube.isHovered && !isSelected) ? 3 : 0;
                const bonusChanged = Math.abs(cube.hoverElevationBonus - targetElevationBonus) > 0.01;
                if (bonusChanged) {
                    const speed = 0.15;
                    cube.hoverElevationBonus += (targetElevationBonus - cube.hoverElevationBonus) * speed;

                    // Clamp to target when very close
                    if (Math.abs(cube.hoverElevationBonus - targetElevationBonus) < 0.01) {
                        cube.hoverElevationBonus = targetElevationBonus;
                    }
                }

                // Update color if progress changed OR if this cube is selected OR if hover state changed OR bonus changed
                if (progressChanged || isSelected || hasCustomColor || hoverStateChanged || bonusChanged) {
                    // For selected cubes
                    if (isSelected) {
                        if (cube.customColor) {
                            // Show custom color
                            tempColor.copy(cube.customColor);
                        } else {
                            // Show white for default/original color
                            tempColor.setRGB(1, 1, 1);
                        }
                    } else if (hasCustomColor) {
                        // For cubes with custom color, brighten when hovered (animated)
                        const whiteColor = new THREE.Color(1, 1, 1);
                        const brightenAmount = (cube.hoverElevationBonus / 3) * 0.3; // Smoothly animate 0 to 0.3
                        tempColor.copy(cube.customColor).lerp(whiteColor, brightenAmount);
                    } else {
                        // For hovered cubes, lerp to white
                        const whiteColor = new THREE.Color(1, 1, 1);
                        tempColor.copy(cube.originalColor).lerp(whiteColor, cube.hoverProgress);
                    }

                    instancedMesh.setColorAt(cube.index, tempColor);
                    colorNeedsUpdate = true;

                    // Update elevation with animated bonus
                    cube.hoverElevation = cube.hoverProgress * 5 + cube.hoverElevationBonus;
                    const totalHeight = cube.currentHeight + cube.hoverElevation;
                    position.set(cube.x, totalHeight / 2, cube.z);
                    scale.set(1, Math.max(0.01, totalHeight), 1);
                    matrix.compose(position, quaternion, scale);
                    instancedMesh.setMatrixAt(cube.index, matrix);

                    // Update label position if exists
                    if (cube.labelObject) {
                        cube.labelObject.position.set(cube.x, totalHeight + 2, cube.z);
                    }

                    needsUpdate = true;
                }
            });

            if (needsUpdate) {
                instancedMesh.instanceMatrix.needsUpdate = true;
            }
            if (colorNeedsUpdate && instancedMesh.instanceColor) {
                instancedMesh.instanceColor.needsUpdate = true;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (!isOrbiting && !journeyTransitioning) {
                controls.update();
            }
            animateCubes();
            updateCameraAnimation(delta);
            updateCameraOrbit();
            updateHover();
            animateJourney();
            updateJourneyCamera();

            // Rotate lights
            const time = Date.now() * 0.0003;
            scene.children.forEach(child => {
                if (child instanceof THREE.PointLight) {
                    const radius = 80;
                    child.position.x = Math.sin(time) * radius;
                    child.position.z = Math.cos(time) * radius;
                }
            });

            composer.render();
            labelRenderer.render(scene, camera);
            updateLabelVisibility();
        }

        function updateLabelVisibility() {
            // Get all visible labels with their screen positions
            const labels = cubeData
                .filter(cube => cube.labelObject)
                .map(cube => {
                    const labelDiv = cube.labelObject.element;
                    const rect = labelDiv.getBoundingClientRect();
                    return {
                        cube: cube,
                        element: labelDiv,
                        rect: rect,
                        center: {
                            x: rect.left + rect.width / 2,
                            y: rect.top + rect.height / 2
                        }
                    };
                });

            // Check each label against others
            labels.forEach(label1 => {
                let hasOverlap = false;

                labels.forEach(label2 => {
                    if (label1 === label2) return;

                    // Check if rectangles overlap
                    const overlap = !(
                        label1.rect.right < label2.rect.left ||
                        label1.rect.left > label2.rect.right ||
                        label1.rect.bottom < label2.rect.top ||
                        label1.rect.top > label2.rect.bottom
                    );

                    if (overlap) {
                        // Calculate distance to camera
                        const dist1 = camera.position.distanceTo(label1.cube.labelObject.position);
                        const dist2 = camera.position.distanceTo(label2.cube.labelObject.position);

                        // Hide the one that's farther from camera
                        if (dist1 > dist2) {
                            hasOverlap = true;
                        }
                    }
                });

                // Set opacity based on overlap
                label1.element.style.opacity = hasOverlap ? '0' : '1';
            });
        }

        init();
        animate();
    </script>
</body>
</html>
