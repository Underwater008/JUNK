<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Terrain Grid Visualization</title>
    <link rel="icon" type="image/png" href="junk-logo-square.png">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.0/dist/hls.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200');

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #f5f7fa 0%, #e8eaf6 50%, #f3e5f5 100%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 10;
        }
        #info img {
            height: 40px;
            display: block;
            filter: brightness(0);
            opacity: 0.9;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6b4ce6;
            font-size: 20px;
            font-weight: 400;
            letter-spacing: 1px;
            z-index: 5;
        }
        #notification {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            padding: 12px 20px;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }
        #notification.visible {
            opacity: 1;
        }
        #notification .icon {
            font-size: 20px;
            line-height: 1;
        }
        #notification.success .icon {
            color: #4caf50;
        }
        #notification.error .icon {
            color: #f44336;
        }
        #notification .message {
            font-size: 13px;
            font-weight: 500;
            color: #1a1a1a;
        }
        #signature {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 10;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        #signature:hover {
            opacity: 1;
        }
        #signature a {
            display: block;
            text-decoration: none;
        }
        #signature img {
            height: 50px;
            display: block;
        }
        /* Journey Media Popup - Fullscreen Gallery */
        #media-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #media-popup.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .gallery-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            font-size: 28px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.2s;
            z-index: 10;
        }
        .gallery-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        .gallery-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            font-size: 36px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.2s;
            z-index: 10;
        }
        .gallery-nav:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-50%) scale(1.1);
        }
        .gallery-nav.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .gallery-prev {
            left: 20px;
        }
        .gallery-next {
            right: 20px;
        }
        .gallery-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 90vw;
            max-height: 85vh;
            gap: 20px;
        }
        .gallery-media {
            display: flex;
            align-items: center;
            justify-content: center;
            max-width: 90vw;
            max-height: 70vh;
            border-radius: 12px;
            overflow: hidden;
            background: linear-gradient(135deg, #e8eaf6 0%, #f3e5f5 100%);
        }
        .gallery-media img,
        .gallery-media video {
            max-width: 90vw;
            max-height: 70vh;
            object-fit: contain;
            border-radius: 12px;
        }
        .gallery-media .material-symbols-outlined {
            font-size: 120px;
            color: #6b4ce6;
            padding: 80px;
        }
        .gallery-info {
            text-align: center;
            color: white;
            max-width: 600px;
        }
        .gallery-info h2 {
            margin: 0 0 8px 0;
            font-size: 28px;
            font-weight: 600;
        }
        .gallery-info p {
            margin: 0;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
        }
        .gallery-dots {
            position: absolute;
            bottom: 30px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .gallery-dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
        }
        .gallery-dot:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        .gallery-dot.active {
            background: white;
            color: #1a1a1a;
            transform: scale(1.1);
        }
        .journey-marker {
            --journey-accent: rgba(107, 76, 230, 0.9);
            --journey-accent-surface: rgba(107, 76, 230, 0.14);
            --journey-accent-border: rgba(107, 76, 230, 0.35);
            position: absolute;
            background: var(--journey-accent-surface);
            border: 1px solid var(--journey-accent-border);
            backdrop-filter: blur(10px);
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: #0f172a;
            white-space: nowrap;
            pointer-events: none;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            transform: translate(-50%, -100%);
            margin-top: -12px;
            transition: opacity 0.2s ease, background 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .journey-marker::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid var(--journey-accent);
        }
        .journey-marker .material-symbols-outlined {
            font-size: 16px;
            font-variation-settings: 'FILL' 1, 'wght' 500, 'GRAD' 0, 'opsz' 20;
        }
        .journey-marker .journey-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--journey-accent);
            color: white;
            font-size: 11px;
            font-weight: 700;
        }
        /* Icon-only marker for "Everyone's Journey" view */
        .journey-marker.icon-only {
            padding: 8px;
            border-radius: 50%;
            min-width: 32px;
            min-height: 32px;
            justify-content: center;
            background: var(--journey-accent);
            border-color: rgba(255, 255, 255, 0.3);
        }
        .journey-marker.icon-only .material-symbols-outlined {
            color: white;
            font-size: 14px;
        }
        .journey-marker.icon-only::after {
            border-top-color: var(--journey-accent);
        }
        /* Journey Navigation - Apple/OpenAI Style */
        #journey-nav {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        #top-nav {
            position: absolute;
            right: 30px;
            top: 30px;
            z-index: 20;
            display: flex;
            gap: 12px;
        }
        #top-nav .journey-nav-item:hover {
            transform: translateY(-2px);
        }
        #top-nav .journey-nav-item.selected {
            transform: translateY(-4px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.15);
        }
        .journey-nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 140px;
            min-height: 40px;
            box-sizing: border-box;
        }
        .journey-nav-item:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateX(4px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        .journey-nav-item.selected {
            background: rgba(255, 255, 255, 0.98);
            transform: translateX(8px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
        }
        .journey-nav-item.selected .nav-dot {
            transform: scale(1.2);
            box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.1);
        }
        .nav-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .nav-name {
            font-size: 13px;
            font-weight: 500;
            color: #1a1a1a;
            letter-spacing: -0.01em;
        }
        /* Top Journey Overview Button */
        #journey-overview {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 140px;
            min-height: 40px;
            box-sizing: border-box;
        }
        #journey-overview:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateX(4px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        #journey-overview.selected {
            background: rgba(255, 255, 255, 0.98);
            transform: translateX(8px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
        }
        #journey-overview.selected .mini-dot {
            transform: scale(1.3);
        }
        .overview-icon {
            font-size: 18px;
            color: #6b4ce6;
            transition: color 0.3s;
        }
        .overview-text {
            font-size: 14px;
            font-weight: 600;
            color: #1a1a1a;
            letter-spacing: -0.01em;
            transition: color 0.3s;
        }
        .overview-dots {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }
        .overview-dots .mini-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            opacity: 0.9;
        }
        #controls {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            padding: 20px;
            color: #1a1a1a;
            font-size: 13px;
            min-width: 220px;
            z-index: 10;
            display: none;
        }
        #controls h3 {
            margin: 0 0 15px 0;
            font-size: 15px;
            font-weight: 600;
            text-align: center;
            color: #6b4ce6;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #4a4a4a;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .control-group input[type="number"] {
            width: 70px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            color: #1a1a1a;
            padding: 4px 8px;
        }
        /* Journey editor */
        #edit-toggle {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 30;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            border-radius: 50%;
            width: 54px;
            height: 54px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        #edit-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.16);
        }
        #edit-toggle.active {
            background: #6b4ce6;
            color: white;
        }
        #edit-toggle .toggle-icon {
            transition: transform 0.2s ease;
        }
        #edit-toggle.active .toggle-icon {
            transform: rotate(90deg);
        }
        #journey-editor {
            position: absolute;
            right: 30px;
            bottom: 100px;
            width: 320px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 16px;
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.18);
            padding: 18px;
            box-sizing: border-box;
            z-index: 25;
            display: none;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        #journey-editor.visible {
            display: block;
        }
        #journey-editor h4 {
            margin: 0 0 12px 0;
            font-size: 15px;
            font-weight: 700;
            letter-spacing: -0.01em;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .editor-field {
            margin-bottom: 10px;
        }
        .editor-field label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            font-weight: 600;
            color: #4a4a4a;
            margin-bottom: 6px;
        }
        .editor-field input,
        .editor-field select,
        .editor-field textarea {
            width: 100%;
            box-sizing: border-box;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
            background: #f8fafc;
            padding: 9px 10px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            color: #0f172a;
        }
        .editor-field textarea {
            resize: vertical;
            min-height: 60px;
        }
        .editor-actions {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .editor-actions button {
            padding: 10px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.2s ease;
        }
        .editor-actions button.primary {
            background: #6b4ce6;
            color: white;
            box-shadow: 0 8px 20px rgba(107, 76, 230, 0.28);
        }
        .editor-actions button.secondary {
            background: #eef2ff;
            color: #312e81;
        }
        .editor-actions button.danger {
            background: #fee2e2;
            color: #b91c1c;
        }
        .editor-actions button:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 26px rgba(0, 0, 0, 0.12);
        }
        .editor-hint {
            margin-top: 8px;
            font-size: 12px;
            color: #475569;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .editor-hint .material-symbols-outlined {
            font-size: 16px;
        }
        body.edit-mode #journey-editor {
            display: block;
        }

        /* Label Admin Mode */
        #label-admin-panel {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
            padding: 24px;
            width: 320px;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            display: none;
            z-index: 900;
        }
        body.label-admin-mode #label-admin-panel {
            display: block;
        }
        #label-admin-panel h4 {
            margin: 0 0 20px 0;
            font-size: 15px;
            font-weight: 600;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .label-field {
            margin-bottom: 16px;
        }
        .label-field label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #64748b;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .label-field input,
        .label-field select {
            width: 100%;
            padding: 10px 12px;
            border: 1.5px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s;
            box-sizing: border-box;
        }
        .label-field input:focus,
        .label-field select:focus {
            outline: none;
            border-color: #6b4ce6;
            box-shadow: 0 0 0 3px rgba(107, 76, 230, 0.1);
        }
        .label-actions {
            display: flex;
            gap: 8px;
            margin-top: 20px;
        }
        .label-actions button {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .label-actions button.primary {
            background: #6b4ce6;
            color: white;
        }
        .label-actions button.secondary {
            background: #e0e7ff;
            color: #312e81;
        }
        .label-actions button.danger {
            background: #fee2e2;
            color: #b91c1c;
        }
        .label-actions button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .label-hint {
            margin-top: 12px;
            font-size: 11px;
            color: #64748b;
            padding: 8px 12px;
            background: #f8fafc;
            border-radius: 6px;
        }
        .map-label {
            pointer-events: all;
            cursor: pointer;
            user-select: none;
            color: #1a1a1a;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(255, 255, 255, 0.9);
            transition: color 0.2s;
        }
        body.label-admin-mode .map-label {
            border: 1px dashed #6b4ce6;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.7);
            cursor: grab !important;
        }
        body.label-admin-mode .map-label:hover {
            background: rgba(107, 76, 230, 0.1);
            border-color: #4c3cc0;
        }
        body.label-admin-mode .map-label:active {
            cursor: grabbing !important;
        }
    </style>
</head>
<body>
    <div id="info">
        <img src="junk-logo.png" alt="JUNK">
    </div>
    <div id="loading">Loading...</div>

    <!-- Journey Navigation (Left Side) -->
    <nav id="journey-nav">
        <!-- All Journeys Button -->
        <div id="journey-overview" onclick="showFullJourney()">
            <div class="overview-dots">
                <div class="mini-dot" style="background: #5CCBD4;"></div>
                <div class="mini-dot" style="background: #F4D35E;"></div>
                <div class="mini-dot" style="background: #A64D79;"></div>
                <div class="mini-dot" style="background: #4A8EC2;"></div>
                <div class="mini-dot" style="background: #6B4CE6;"></div>
                <div class="mini-dot" style="background: #F4C2C2;"></div>
                <div class="mini-dot" style="background: #5ABF8C;"></div>
                <div class="mini-dot" style="background: #C855D8;"></div>
            </div>
        </div>
        <div class="journey-nav-item" data-person="ziyi" onclick="selectPerson('ziyi')">
            <div class="nav-dot" style="background: #C855D8;"></div>
            <span class="nav-name">ZIYI</span>
        </div>
        <div class="journey-nav-item" data-person="steven" onclick="selectPerson('steven')">
            <div class="nav-dot" style="background: #4A8EC2;"></div>
            <span class="nav-name">STEVEN</span>
        </div>
        <div class="journey-nav-item" data-person="yuzie" onclick="selectPerson('yuzie')">
            <div class="nav-dot" style="background: #5ABF8C;"></div>
            <span class="nav-name">YUZIE</span>
        </div>
        <div class="journey-nav-item" data-person="lillith" onclick="selectPerson('lillith')">
            <div class="nav-dot" style="background: #A64D79;"></div>
            <span class="nav-name">LILLITH</span>
        </div>
        <div class="journey-nav-item" data-person="jonny" onclick="selectPerson('jonny')">
            <div class="nav-dot" style="background: #F4D35E;"></div>
            <span class="nav-name">JONNY</span>
        </div>
        <div class="journey-nav-item" data-person="isabel" onclick="selectPerson('isabel')">
            <div class="nav-dot" style="background: #5CCBD4;"></div>
            <span class="nav-name">ISABEL</span>
        </div>
        <div class="journey-nav-item" data-person="xiao" onclick="selectPerson('xiao')">
            <div class="nav-dot" style="background: #F4C2C2;"></div>
            <span class="nav-name">XIAO</span>
        </div>
        <div class="journey-nav-item" data-person="tiger" onclick="selectPerson('tiger')">
            <div class="nav-dot" style="background: #6B4CE6;"></div>
            <span class="nav-name">TIGER</span>
        </div>
    </nav>

    <!-- Top Navigation (Right Side) -->
    <nav id="top-nav">
        <div class="journey-nav-item selected" id="overview-btn" onclick="showOverview()">
            <div class="nav-dot" style="background: #888;"></div>
            <span class="nav-name">OVERVIEW</span>
        </div>
        <a href="Artifact/Artifact.html" class="journey-nav-item" id="artifact-btn" style="text-decoration: none; color: inherit;">
            <div class="nav-dot" style="background: #d4af37;"></div>
            <span class="nav-name">ARTIFACTS</span>
        </a>
        <div class="journey-nav-item" id="about-btn" onclick="showAbout()">
            <div class="nav-dot" style="background: #888;"></div>
            <span class="nav-name">ABOUT</span>
        </div>
    </nav>

    <div id="edit-toggle" title="Toggle edit mode" onclick="toggleEditMode()">
        <span class="material-symbols-outlined toggle-icon" data-state="off">edit</span>
    </div>

    <div id="journey-editor">
        <h4>
            <span class="material-symbols-outlined">edit_square</span>
            Journey Editor
        </h4>
        <div class="editor-field">
            <label>Person <span id="editor-point-id"></span></label>
            <div id="editor-person-name" style="font-weight:700;color:#1a1a1a;font-size:13px;"></div>
        </div>
        <div class="editor-field">
            <label>Point</label>
            <select id="editor-point-select"></select>
        </div>
        <div class="editor-field">
            <label>Order</label>
            <input type="number" id="editor-order" min="1" step="1" value="1">
        </div>
        <div class="editor-field">
            <label>Name</label>
            <input type="text" id="editor-name" placeholder="Location name">
        </div>
        <div class="editor-field">
            <label>Icon</label>
            <input type="text" id="editor-icon" placeholder="Material icon name">
        </div>
        <div class="editor-field">
            <label>Asset Link <span style="font-weight:500;font-size:11px;color:#6b4ce6;">(imgur image or vimeo link)</span></label>
            <input type="text" id="editor-media" placeholder="https://...">
        </div>
        <div class="editor-field">
            <label>Media Type</label>
            <select id="editor-media-type">
                <option value="">Auto</option>
                <option value="image">Image</option>
                <option value="video">Video</option>
            </select>
        </div>
        <div class="editor-field">
            <label>Description</label>
            <textarea id="editor-description" placeholder="What is this point?"></textarea>
        </div>
        <div class="editor-actions">
            <button class="secondary" id="editor-new">New Point</button>
            <button class="primary" id="editor-save">Save Point</button>
            <button class="danger" id="editor-delete">Delete</button>
        </div>
        <div class="editor-hint">
            <span class="material-symbols-outlined">pan_tool_alt</span>
            Drag markers on the map while edit mode is on.
        </div>
    </div>

    <!-- Label Admin Panel -->
    <div id="label-admin-panel">
        <h4>
            <span class="material-symbols-outlined">text_fields</span>
            Map Label Editor
        </h4>
        <div class="label-field">
            <label>Label Text</label>
            <input type="text" id="label-text" placeholder="Enter label text">
        </div>
        <div class="label-field">
            <label>Font Size</label>
            <select id="label-size">
                <option value="12">Small (12px)</option>
                <option value="14">Normal (14px)</option>
                <option value="16" selected>Medium (16px)</option>
                <option value="20">Large (20px)</option>
                <option value="24">Extra Large (24px)</option>
                <option value="32">Huge (32px)</option>
                <option value="48">Giant (48px)</option>
            </select>
        </div>
        <div class="label-field">
            <label>Color</label>
            <input type="color" id="label-color" value="#1a1a1a">
        </div>
        <div class="label-actions">
            <button class="primary" id="add-label">Add Label</button>
            <button class="danger" id="delete-label">Delete Selected</button>
        </div>
        <div class="label-hint">
            <strong>Ctrl+Shift+X</strong> to toggle label mode<br>
            Click terrain to place labels<br>
            Drag labels to reposition them<br>
            Click to select, then delete
        </div>
    </div>

    <div id="notification">
        <div class="icon">✓</div>
        <div class="message">Saved successfully!</div>
    </div>

    <div id="controls">
        <h3>CAMERA CONTROLS</h3>
        <div class="control-group">
            <label>FOV: <span id="fov-value">30</span></label>
            <input type="range" id="fov" min="30" max="120" value="30" step="1">
        </div>
        <div class="control-group">
            <label>Position Y: <span id="pos-y-value">260</span></label>
            <input type="range" id="pos-y" min="10" max="320" value="260" step="1">
        </div>
        <div class="control-group">
            <label>Position X: <span id="pos-x-value">80</span></label>
            <input type="range" id="pos-x" min="-200" max="200" value="80" step="1">
        </div>
        <div class="control-group">
            <label>Position Z: <span id="pos-z-value">80</span></label>
            <input type="range" id="pos-z" min="-200" max="200" value="80" step="1">
        </div>
        <div class="control-group">
            <label>Height Scale: <span id="height-value">7</span></label>
            <input type="range" id="height-scale" min="5" max="100" value="7" step="1">
        </div>
        <div class="control-group">
            <label>Sea Threshold: <span id="sea-threshold-value">0.07</span></label>
            <input type="range" id="sea-threshold" min="0" max="0.5" value="0.07" step="0.01">
            <input type="number" id="sea-threshold-input" min="0" max="0.5" value="0.07" step="0.001">
        </div>
        <div class="control-group">
            <label>Sea Level Height: <span id="sea-height-value">1.00</span></label>
            <input type="range" id="sea-height" min="0.1" max="10" value="1.0" step="0.01">
            <input type="number" id="sea-height-input" min="0.1" max="10" value="1.0" step="0.01">
        </div>
        <div class="control-group">
            <label>Material Rotation: <span id="mat-rotation-value">180</span>°</label>
            <input type="range" id="mat-rotation" min="-180" max="180" value="180" step="1">
        </div>
        <div class="control-group">
            <label>Height Map Rotation: <span id="height-rotation-value">-180</span>°</label>
            <input type="range" id="height-rotation" min="-180" max="180" value="-180" step="1">
        </div>
        <div class="control-group">
            <label><input type="checkbox" id="height-flip-u" checked> Flip Height U</label>
            <label style="margin-left:10px;"><input type="checkbox" id="height-flip-v"> Flip Height V</label>
        </div>
        <div class="control-group">
            <label><input type="checkbox" id="mat-flip-u"> Flip U</label>
            <label style="margin-left:10px;"><input type="checkbox" id="mat-flip-v" checked> Flip V</label>
        </div>
    </div>

    <!-- Journey Media Popup - Fullscreen Gallery -->
    <div id="media-popup">
        <button class="gallery-close" onclick="closeMediaPopup()">×</button>
        <button class="gallery-nav gallery-prev" onclick="navigateJourney(-1)">‹</button>
        <button class="gallery-nav gallery-next" onclick="navigateJourney(1)">›</button>
        <div class="gallery-content">
            <div class="gallery-media" id="media-placeholder">
                <span class="material-symbols-outlined">image</span>
            </div>
            <div class="gallery-info">
                <h2 id="media-title">Location Title</h2>
                <p id="media-description">Description of this journey location.</p>
            </div>
        </div>
        <div class="gallery-dots" id="gallery-dots"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // JSONBin configuration
        const JSONBIN_BIN_ID = '68e0256043b1c97be95965b9';
        const JSONBIN_API_KEY = '$2a$10$IcHy/if.465WYHfVCaX0WOrS.zvgk8DinfdOFdHuUoCZLt7YTP4RS';
        const JSONBIN_URL = `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`;

        let scene, camera, renderer, controls, labelRenderer;
        let terrainMesh;
        let animationStartTime = 0;
        let cameraMixer = null;
        let cameraAction = null;
        let cameraIntroPlaying = false;
        let posXSlider = null;
        let posXValueDisplay = null;
        let posYSlider = null;
        let posYValueDisplay = null;
        // Mouse interaction
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let mouseDownPos = new THREE.Vector2();
        let isDragging = false;
        let lastJourneySaveTime = 0;
        let editMode = false;
        let editingPoint = null;
        let draggingJourneyMarker = null;
        // Mobile detection
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        // Post-processing
        let composer;
        // Material map data for land coloring
        let matImageData = null;
        let matW = 0;
        let matH = 0;
        let flipMaterialU = true;  // allow horizontal flip
        let flipMaterialV = true;  // vertical flip (image origin alignment)
        let matRotationDeg = 180; // rotation around material center (default sweet spot)
        let heightRotationDeg = -180; // rotation for heightmap
        let flipHeightU = true; // flip heightmap horizontally
        let flipHeightV = false; // flip heightmap vertically
        let heightImageData = null; // store heightmap data for reapplying rotation
        let heightW = 0;
        let heightH = 0;
        const clock = new THREE.Clock();
        let heightScale = 7;
        const gridGap = 1.0;
        const sampleRate = 4; // Sample every Nth pixel (128x128 = 16k instances)
        let seaThreshold = 0.15; // Grayscale cutoff: <= is ocean (extended ocean)
        let seaFlatHeight = 1.0; // Flat column height for ocean

        const cameraStartPos = { x: 0, y: 260, z: 0.1 };
        const cameraEndPos = { x: 0, y: 200, z: 0.1 };

        // Person colors matching the navigation
        const personColors = {
            isabel: 0x5CCBD4,
            ziyi: 0xC855D8,
            steven: 0x4A8EC2,
            tiger: 0x6B4CE6,
            xiao: 0xF4C2C2,
            lillith: 0xA64D79,
            yuzie: 0x5ABF8C,
            jonny: 0xF4D35E
        };

        // Default journey data for each person - acts as a seed if JSONBin is empty
        const defaultJourneys = {
            isabel: [
                { id: 1, name: "Coral Bay", icon: "waves", x: -45, z: -30, description: "Isabel discovered a hidden underwater cave system here." },
                { id: 2, name: "Tide Pools", icon: "water_drop", x: -30, z: -20, description: "A research station studying marine life adaptation." },
                { id: 3, name: "Lighthouse Ruins", icon: "navigation", x: -15, z: -10, description: "The old lighthouse where Isabel found her first artifact." }
            ],
            ziyi: [
                { id: 1, name: "Crystal Caverns", icon: "diamond", x: -40, z: 15, description: "Ziyi mapped these luminescent caves over three expeditions." },
                { id: 2, name: "Echo Chamber", icon: "graphic_eq", x: -25, z: 25, description: "A natural amphitheater with strange acoustic properties." },
                { id: 3, name: "Garden Shrine", icon: "local_florist", x: -10, z: 35, description: "An overgrown temple where Ziyi practiced meditation." },
                { id: 4, name: "Mist Valley", icon: "cloud", x: 5, z: 40, description: "A perpetually foggy valley hiding ancient secrets." }
            ],
            steven: [
                { id: 1, name: "Forge Workshop", icon: "hardware", x: 30, z: -35, description: "Steven rebuilt the old forge to craft tools for the community." },
                { id: 2, name: "Scrap Yard", icon: "recycling", x: 45, z: -25, description: "A treasure trove of pre-collapse technology." },
                { id: 3, name: "Wind Farm", icon: "air", x: 50, z: -10, description: "Steven restored three turbines to power the eastern settlements." }
            ],
            tiger: [
                { id: 1, name: "Hunter's Blind", icon: "visibility", x: 20, z: 30, description: "Tiger's lookout point for tracking wildlife movements." },
                { id: 2, name: "Wolf Den", icon: "pets", x: 35, z: 40, description: "Where Tiger befriended the last pack of mountain wolves." },
                { id: 3, name: "Summit Camp", icon: "terrain", x: 45, z: 50, description: "The highest point Tiger reached during the great expedition." },
                { id: 4, name: "River Crossing", icon: "kayaking", x: 30, z: 25, description: "A dangerous ford that Tiger navigated many times." }
            ],
            xiao: [
                { id: 1, name: "Observatory Dome", icon: "nights_stay", x: -5, z: 5, description: "Xiao spent nights here studying the changed constellations." },
                { id: 2, name: "Data Archive", icon: "storage", x: 10, z: 0, description: "A server room Xiao worked to restore and preserve." }
            ],
            lillith: [
                { id: 1, name: "Apothecary", icon: "medication", x: -35, z: -5, description: "Lillith established a clinic to heal the wounded." },
                { id: 2, name: "Herb Garden", icon: "spa", x: -25, z: 5, description: "A carefully cultivated garden of medicinal plants." },
                { id: 3, name: "Hot Springs", icon: "hot_tub", x: -15, z: 15, description: "Natural springs with therapeutic properties." },
                { id: 4, name: "Sanctuary", icon: "temple_buddhist", x: -5, z: 25, description: "A place of rest and healing that Lillith built." }
            ],
            yuzie: [
                { id: 1, name: "Farmer's Market", icon: "storefront", x: 0, z: -25, description: "Yuzie organized the first post-collapse trade fair here." },
                { id: 2, name: "Greenhouse", icon: "yard", x: 15, z: -30, description: "A restored greenhouse producing food year-round." },
                { id: 3, name: "Orchard", icon: "park", x: 25, z: -20, description: "Yuzie planted these fruit trees five years ago." }
            ],
            jonny: [
                { id: 1, name: "Radio Tower", icon: "cell_tower", x: 5, z: -15, description: "Jonny got the old transmitter working again." },
                { id: 2, name: "Signal Station", icon: "podcasts", x: 20, z: -5, description: "A relay point extending communication range." },
                { id: 3, name: "Watchtower", icon: "location_city", x: 35, z: 5, description: "The tallest structure Jonny climbed to install antennas." },
                { id: 4, name: "Bunker HQ", icon: "military_tech", x: 40, z: 15, description: "Command center for coordinating expeditions." }
            ]
        };

        const cloneJourneys = (source) => JSON.parse(JSON.stringify(source));

        // Active journey data (mutable and synced to JSONBin)
        let allJourneys = cloneJourneys(defaultJourneys);

        const navPersonOrder = ['ziyi','steven','yuzie','lillith','jonny','isabel','xiao','tiger'];
        const getSortedPeople = () => {
            const existing = Object.keys(allJourneys);
            const ordered = navPersonOrder.filter(p => existing.includes(p));
            const extras = existing.filter(p => !navPersonOrder.includes(p)).sort((a, b) => a.localeCompare(b));
            return [...ordered, ...extras];
        };

        const detectMediaType = (link = '') => {
            let lower = (link || '').toLowerCase().trim();
            if (!lower) return '';
            if (lower.startsWith('%3cblockquote') || lower.includes('<blockquote')) return ''; // treat old embed snippets as invalid
            if (lower.includes('<iframe') || lower.includes('<div')) return 'embed';
            if (lower.includes('player.vimeo.com/external/')) return 'vimeo-external';
            if (lower.endsWith('.m3u8') || lower.includes('.m3u8?')) return 'hls';
            if (lower.includes('vimeo.com')) return 'vimeo';
            if (lower.includes('youtube.com') || lower.includes('youtu.be') || lower.endsWith('.mp4') || lower.endsWith('.webm')) return 'video';
            return 'image';
        };

        function getVimeoId(url = '') {
            // Matches vimeo.com/{id} or vimeo.com/.../{id}
            const match = url.match(/vimeo\.com\/(?:video\/)?(\d+)/i);
            return match ? match[1] : '';
        }

        function getVimeoExternalId(url = '') {
            // Matches player.vimeo.com/external/{id}.m3u8 or .mp4
            const match = url.match(/player\.vimeo\.com\/external\/(\d+)/i);
            return match ? match[1] : '';
        }

        function normalizeJourneyPoint(stop, index, person) {
            const point = stop;
            delete point.y; // remove transient render data
            delete point.color;
            point.person = person;
            const orderValue = point.order !== undefined ? point.order : (point.id !== undefined ? point.id : index + 1);
            point.order = parseInt(orderValue, 10) || index + 1;
            point.id = point.order;
            const detectedType = point.media ? detectMediaType(point.media) : '';
            if (detectedType) {
                point.mediaType = detectedType;
            } else if (point.media) {
                // If it's an old embed snippet, clear it so it doesn't try to load
                point.media = '';
                point.mediaType = '';
            }
            return point;
        }

        function normalizeJourneyData(data) {
            const safeData = data && Object.keys(data).length > 0 ? cloneJourneys(data) : cloneJourneys(defaultJourneys);
            Object.keys(safeData).forEach(person => {
                safeData[person] = (safeData[person] || []).map((stop, idx) => normalizeJourneyPoint(stop, idx, person));
            });
            return safeData;
        }

        function hexToRgba(hex, alpha = 1) {
            const color = new THREE.Color(hex);
            const r = Math.round(color.r * 255);
            const g = Math.round(color.g * 255);
            const b = Math.round(color.b * 255);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function buildJourneyPoints(selection = 'all') {
            const people = selection === 'all' ? getSortedPeople() : [selection];
            const combined = [];

            people.forEach((person) => {
                const stops = (allJourneys[person] || []).slice().sort((a, b) => (a.order ?? a.id ?? 0) - (b.order ?? b.id ?? 0));
                stops.forEach((stop, idx) => {
                    combined.push(normalizeJourneyPoint(stop, idx, person));
                });
            });

            return combined;
        }

        function renumberPersonJourneys(person) {
            const list = allJourneys[person] || [];
            list.sort((a, b) => (a.order ?? a.id ?? 0) - (b.order ?? b.id ?? 0));
            list.forEach((pt, idx) => {
                pt.order = idx + 1;
                pt.id = pt.order;
            });
        }

        function rebuildJourneySystem() {
            if (!heightImageData || !journeysVisible) return;
            journeyPoints = buildJourneyPoints(selectedPersonName);
            clearJourneySystem();
            createJourneySystem(heightImageData, heightW, heightH);
        }

        function populateEditorFields(point) {
            const orderInput = document.getElementById('editor-order');
            const nameInput = document.getElementById('editor-name');
            const iconInput = document.getElementById('editor-icon');
            const mediaInput = document.getElementById('editor-media');
            const mediaTypeSelect = document.getElementById('editor-media-type');
            const descriptionInput = document.getElementById('editor-description');
            const idBadge = document.getElementById('editor-point-id');
            const personName = document.getElementById('editor-person-name');
            const pointSelect = document.getElementById('editor-point-select');

            const personToShow = (point && point.person) || (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]);
            personName.textContent = personToShow ? personToShow.toUpperCase() : '';

            // Update point selector options
            updatePointSelectOptions(point);

            if (!point) {
                orderInput.value = 1;
                nameInput.value = '';
                iconInput.value = '';
                mediaInput.value = '';
                mediaTypeSelect.value = '';
                descriptionInput.value = '';
                idBadge.textContent = '';
                return;
            }

            orderInput.value = point.order || point.id || 1;
            nameInput.value = point.name || '';
            iconInput.value = point.icon || '';
            mediaInput.value = point.media || '';
            mediaTypeSelect.value = point.mediaType || '';
            descriptionInput.value = point.description || '';
            idBadge.textContent = `#${point.order || point.id || ''}`;
        }

        function setEditingPoint(point) {
            editingPoint = point || null;
            populateEditorFields(point || null);
            updatePointSelectOptions(point || null);
        }

        function updatePointSelectOptions(currentPoint = null) {
            const select = document.getElementById('editor-point-select');
            if (!select) return;

            const person = (currentPoint && currentPoint.person) || (editingPoint && editingPoint.person) || (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]);
            const list = (allJourneys[person] || []).slice().sort((a, b) => (a.order ?? a.id ?? 0) - (b.order ?? b.id ?? 0));

            select.innerHTML = '';
            if (!list.length) {
                select.disabled = true;
                const opt = document.createElement('option');
                opt.textContent = 'No points';
                opt.value = '';
                select.appendChild(opt);
                return;
            }

            select.disabled = false;
            list.forEach(pt => {
                const opt = document.createElement('option');
                opt.value = pt.order;
                opt.textContent = `${pt.order} — ${pt.name || 'Untitled'}`;
                select.appendChild(opt);
            });

            const targetOrder = currentPoint?.order || (editingPoint?.order) || list[0].order;
            select.value = targetOrder;
        }

        function createNewJourneyPoint() {
            const targetPerson = (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]) || 'xiao';
            allJourneys[targetPerson] = allJourneys[targetPerson] || [];
            const nextOrder = (allJourneys[targetPerson].length || 0) + 1;
            const newPoint = {
                id: nextOrder,
                order: nextOrder,
                name: 'New Point',
                icon: 'location_on',
                x: 0,
                z: 0,
                description: '',
                person: targetPerson
            };
            allJourneys[targetPerson].push(newPoint);
            renumberPersonJourneys(targetPerson);
            setEditingPoint(newPoint);
            journeysVisible = true;
            selectedPersonName = targetPerson;
            setJourneySelection(targetPerson);
        }

        function applyEditorChanges() {
            if (!editingPoint) return;

            const orderInput = document.getElementById('editor-order');
            const nameInput = document.getElementById('editor-name');
            const iconInput = document.getElementById('editor-icon');
            const mediaInput = document.getElementById('editor-media');
            const mediaTypeSelect = document.getElementById('editor-media-type');
            const descriptionInput = document.getElementById('editor-description');

            const targetPerson = editingPoint.person || (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]);
            const newOrder = parseInt(orderInput.value, 10) || 1;
            const targetListOld = allJourneys[editingPoint.person] || [];

            // Move to new person list if needed
            editingPoint.person = targetPerson;
            editingPoint.order = newOrder;
            editingPoint.id = newOrder;
            editingPoint.name = nameInput.value.trim();
            editingPoint.icon = iconInput.value.trim();
            editingPoint.media = mediaInput.value.trim();
            editingPoint.mediaType = mediaTypeSelect.value || detectMediaType(editingPoint.media);
            editingPoint.description = descriptionInput.value.trim();

            renumberPersonJourneys(targetPerson);
            setJourneySelection(targetPerson);
            lastJourneySaveTime = Date.now();
        }

        function deleteEditingPoint() {
            if (!editingPoint) return;
            const person = editingPoint.person;
            const list = allJourneys[person] || [];
            const idx = list.indexOf(editingPoint);
            if (idx >= 0) {
                list.splice(idx, 1);
            }
            renumberPersonJourneys(person);
            const nextPoint = (allJourneys[person] || [])[0] || null;
            editingPoint = null;
            populateEditorFields(nextPoint);
            if (nextPoint) {
                setEditingPoint(nextPoint);
            }
            rebuildJourneySystem();
        }

        function setupEditorUI() {
            document.getElementById('editor-save').addEventListener('click', () => {
                applyEditorChanges();
                rebuildJourneySystem();
                saveJourneysToBin();
            });
            document.getElementById('editor-new').addEventListener('click', () => {
                createNewJourneyPoint();
                rebuildJourneySystem();
            });
            document.getElementById('editor-delete').addEventListener('click', () => {
                deleteEditingPoint();
                saveJourneysToBin();
            });
            const pointSelect = document.getElementById('editor-point-select');
            if (pointSelect) {
                pointSelect.addEventListener('change', (e) => {
                    const person = (editingPoint && editingPoint.person) || (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]);
                    const order = parseInt(e.target.value, 10);
                    const point = (allJourneys[person] || []).find(pt => pt.order === order);
                    if (point) {
                        setEditingPoint(point);
                    }
                });
            }
        }

        window.toggleEditMode = function(force) {
            editMode = typeof force === 'boolean' ? force : !editMode;
            const editor = document.getElementById('journey-editor');
            const toggleBtn = document.getElementById('edit-toggle');
            const toggleIcon = toggleBtn?.querySelector('.toggle-icon');
            document.body.classList.toggle('edit-mode', editMode);
            editor?.classList.toggle('visible', editMode);
            toggleBtn?.classList.toggle('active', editMode);
            if (toggleIcon) {
                toggleIcon.textContent = editMode ? 'close' : 'edit';
            }

            // Keep journeys visible while editing
            if (editMode) {
                journeysVisible = true;
                const defaultPerson = editingPoint?.person || (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]);
                const targetPerson = defaultPerson || getSortedPeople()[0];
                selectedPersonName = targetPerson;
                setJourneySelection(targetPerson);
                controls.enabled = false;
                if (!editingPoint && journeyPoints.length > 0) {
                    setEditingPoint(journeyPoints[0]);
                }
            } else {
                controls.enabled = true;
                draggingJourneyMarker = null;
            }
        };

        // Currently active journey points (changes based on selection)
        let journeyPoints = [];
        let currentPerson = null;
        let selectedPersonName = 'all';
        let journeysVisible = false; // Start with journeys hidden

        // Journey system variables
        let journeyMarkers = [];
        let journeyLines = [];
        let selectedJourneyPoint = null;
        let journeyTransitioning = false;
        let journeyTransitionProgress = 0;
        let journeySavedCameraPos = null;
        let journeySavedTarget = null;
        let currentJourneyIndex = 0;

        // Label Admin Mode variables
        let labelAdminMode = false;
        let mapLabels = [];
        let label3DObjects = []; // Three.js CSS2DObjects
        let selectedLabel = null;
        let draggingLabel = null;
        let isDraggingLabel = false;

        // Load labels from localStorage
        function loadLabels() {
            const saved = localStorage.getItem('mapLabels');
            if (saved) {
                try {
                    mapLabels = JSON.parse(saved);
                    mapLabels.forEach(label => create3DLabel(label));
                } catch (e) {
                    console.error('Error loading labels:', e);
                }
            }
        }

        // Save labels to localStorage
        function saveLabels() {
            const data = mapLabels.map(l => ({
                id: l.id,
                text: l.text,
                worldX: l.worldX,
                worldY: l.worldY,
                worldZ: l.worldZ,
                size: l.size,
                color: l.color
            }));
            localStorage.setItem('mapLabels', JSON.stringify(data));
        }

        // Toggle label admin mode with Ctrl+Shift+X
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'X') {
                e.preventDefault();
                labelAdminMode = !labelAdminMode;
                document.body.classList.toggle('label-admin-mode', labelAdminMode);

                if (labelAdminMode) {
                    showNotification({ message: 'Label Admin Mode Enabled', type: 'success' });
                } else {
                    showNotification({ message: 'Label Admin Mode Disabled', type: 'success' });
                    selectedLabel = null;
                    // Remove selection highlight
                    label3DObjects.forEach(obj => {
                        obj.element.style.outline = '';
                    });
                }
            }
        });

        // Create 3D label attached to terrain
        function create3DLabel(labelData) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'map-label';
            labelDiv.textContent = labelData.text;
            labelDiv.style.fontSize = labelData.size + 'px';
            labelDiv.style.color = labelData.color;
            labelDiv.dataset.labelId = labelData.id;

            // Make clickable and draggable in admin mode
            labelDiv.addEventListener('mousedown', (e) => {
                if (!labelAdminMode) return;
                e.stopPropagation();
                e.preventDefault();

                selectedLabel = labelData;
                draggingLabel = labelData;
                isDraggingLabel = true;

                // Disable camera controls while dragging
                controls.enabled = false;

                // Highlight selected
                label3DObjects.forEach(obj => {
                    obj.element.style.outline = '';
                });
                labelDiv.style.outline = '2px solid #6b4ce6';
                labelDiv.style.cursor = 'grabbing';
            });

            const label2D = new CSS2DObject(labelDiv);
            label2D.position.set(labelData.worldX, labelData.worldY, labelData.worldZ);
            label2D.userData.labelData = labelData;

            scene.add(label2D);
            label3DObjects.push(label2D);

            return label2D;
        }

        // Add label button
        document.getElementById('add-label').addEventListener('click', () => {
            const text = document.getElementById('label-text').value.trim();
            if (!text) {
                showNotification({ message: 'Please enter label text', type: 'error' });
                return;
            }

            const size = parseInt(document.getElementById('label-size').value);
            const color = document.getElementById('label-color').value;

            // Place at center of screen, raycast to find terrain position
            mouse.x = 0;
            mouse.y = 0;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(terrainMesh);

            if (intersects.length > 0) {
                const point = intersects[0].point;

                const label = {
                    id: Date.now(),
                    text: text,
                    worldX: point.x,
                    worldY: point.y + 2, // Slightly above terrain
                    worldZ: point.z,
                    size: size,
                    color: color
                };

                mapLabels.push(label);
                create3DLabel(label);
                saveLabels();

                document.getElementById('label-text').value = '';
                showNotification({ message: 'Label added to map', type: 'success' });
            } else {
                showNotification({ message: 'Could not find terrain position', type: 'error' });
            }
        });

        // Delete label button
        document.getElementById('delete-label').addEventListener('click', () => {
            if (!selectedLabel) {
                showNotification({ message: 'No label selected', type: 'error' });
                return;
            }

            // Remove from scene
            const labelObj = label3DObjects.find(obj => obj.userData.labelData.id === selectedLabel.id);
            if (labelObj) {
                scene.remove(labelObj);
                labelObj.element.remove();
            }

            // Remove from arrays
            label3DObjects = label3DObjects.filter(obj => obj.userData.labelData.id !== selectedLabel.id);
            mapLabels = mapLabels.filter(l => l.id !== selectedLabel.id);

            saveLabels();
            selectedLabel = null;
            showNotification({ message: 'Label deleted', type: 'success' });
        });

        // Setup label click handler - called after renderer is created
        function setupLabelClickHandler() {
            // Click to place new label
            renderer.domElement.addEventListener('click', (e) => {
                if (!labelAdminMode || isDraggingLabel) return;

                const text = document.getElementById('label-text').value.trim();
                if (!text) return;

                // Calculate mouse position in normalized device coordinates
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(terrainMesh);

                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const size = parseInt(document.getElementById('label-size').value);
                    const color = document.getElementById('label-color').value;

                    const label = {
                        id: Date.now(),
                        text: text,
                        worldX: point.x,
                        worldY: point.y + 2,
                        worldZ: point.z,
                        size: size,
                        color: color
                    };

                    mapLabels.push(label);
                    create3DLabel(label);
                    saveLabels();

                    document.getElementById('label-text').value = '';
                    showNotification({ message: 'Label placed on terrain', type: 'success' });
                }
            });

            // Mousemove for dragging labels
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!labelAdminMode || !isDraggingLabel || !draggingLabel) return;

                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(terrainMesh);

                if (intersects.length > 0) {
                    const point = intersects[0].point;

                    // Update label position
                    draggingLabel.worldX = point.x;
                    draggingLabel.worldY = point.y + 2;
                    draggingLabel.worldZ = point.z;

                    // Update 3D object position
                    const labelObj = label3DObjects.find(obj => obj.userData.labelData.id === draggingLabel.id);
                    if (labelObj) {
                        labelObj.position.set(point.x, point.y + 2, point.z);
                    }
                }
            });

            // Mouseup to stop dragging
            document.addEventListener('mouseup', (e) => {
                if (isDraggingLabel) {
                    isDraggingLabel = false;
                    controls.enabled = true;

                    // Reset cursor
                    const labelObj = label3DObjects.find(obj => obj.userData.labelData.id === draggingLabel?.id);
                    if (labelObj) {
                        labelObj.element.style.cursor = 'grab';
                    }

                    if (draggingLabel) {
                        saveLabels();
                        showNotification({ message: 'Label repositioned', type: 'success' });
                    }

                    draggingLabel = null;
                }
            });
        }

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f7fa);
            // Add fog to hide edges and create infinite feel
            // Starts with heavy fog for 2D look, clears during intro animation
            scene.fog = new THREE.Fog(0xf5f7fa, 100, 200);

            // Camera - start at high position for entrance animation
            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Label renderer
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            // Post-processing setup (no bloom)
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2;

            // Mouse events
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);

            // Lighting - soft and ambient for clean look
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0xb8a5ff, 0.8, 200);
            pointLight1.position.set(50, 40, 0);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffc4e1, 0.8, 200);
            pointLight2.position.set(-50, 40, 0);
            scene.add(pointLight2);

            // Setup control panel
            setupControls();
            setupEditorUI();

            // Load heightmap
            loadHeightmap();
        }

        function setupControls() {
            // FOV control
            const fovSlider = document.getElementById('fov');
            const fovValue = document.getElementById('fov-value');
            fovSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.fov = value;
                camera.updateProjectionMatrix();
                fovValue.textContent = value;
            });

            // Position Y control
            posYSlider = document.getElementById('pos-y');
            posYValueDisplay = document.getElementById('pos-y-value');
            posYSlider.value = camera.position.y;
            posYValueDisplay.textContent = Math.round(camera.position.y);
            posYSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.y = value;
                posYValueDisplay.textContent = value;
            });

            // Position X control
            posXSlider = document.getElementById('pos-x');
            posXValueDisplay = document.getElementById('pos-x-value');
            posXSlider.value = camera.position.x;
            posXValueDisplay.textContent = Math.round(camera.position.x);
            posXSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.x = value;
                posXValueDisplay.textContent = value;
            });

            // Position Z control
            const posZSlider = document.getElementById('pos-z');
            const posZValue = document.getElementById('pos-z-value');
            posZSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.z = value;
                posZValue.textContent = value;
            });

            // Height scale control (live update terrain heights)
            const heightSlider = document.getElementById('height-scale');
            const heightValue = document.getElementById('height-value');
            heightSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                heightScale = value;
                heightValue.textContent = value;
                applyHeightScale();
            });

            // Sea threshold control (live recolor + flatten ocean)
            const seaSlider = document.getElementById('sea-threshold');
            const seaValue = document.getElementById('sea-threshold-value');
            const seaInput = document.getElementById('sea-threshold-input');
            const clampSea = (v) => Math.max(parseFloat(seaSlider.min), Math.min(parseFloat(seaSlider.max), v));

            const syncSeaUI = (v) => {
                const vv = clampSea(v);
                seaSlider.value = vv;
                seaInput.value = vv;
                seaValue.textContent = parseFloat(vv).toFixed(2);
            };

            syncSeaUI(seaThreshold);

            seaSlider.addEventListener('input', (e) => {
                const value = clampSea(parseFloat(e.target.value));
                seaThreshold = value;
                seaValue.textContent = value.toFixed(2);
                seaInput.value = value;
                applySeaThreshold();
            });

            seaInput.addEventListener('input', (e) => {
                const raw = parseFloat(e.target.value);
                if (isNaN(raw)) return;
                const value = clampSea(raw);
                seaThreshold = value;
                seaSlider.value = value;
                seaValue.textContent = value.toFixed(2);
                applySeaThreshold();
            });

            // Sea level height control (live update ocean flat height)
            const seaHeightSlider = document.getElementById('sea-height');
            const seaHeightInput = document.getElementById('sea-height-input');
            const seaHeightValue = document.getElementById('sea-height-value');
            const clampSeaHeight = (v) => Math.max(parseFloat(seaHeightSlider.min), Math.min(parseFloat(seaHeightSlider.max), v));

            const syncSeaHeightUI = (v) => {
                const vv = clampSeaHeight(v);
                seaHeightSlider.value = vv;
                seaHeightInput.value = vv;
                seaHeightValue.textContent = parseFloat(vv).toFixed(2);
            };

            syncSeaHeightUI(seaFlatHeight);

            const applySeaHeight = (value) => {
                seaFlatHeight = value;
                applySeaThreshold();
            };

            seaHeightSlider.addEventListener('input', (e) => {
                const value = clampSeaHeight(parseFloat(e.target.value));
                syncSeaHeightUI(value);
                applySeaHeight(value);
            });
            seaHeightInput.addEventListener('input', (e) => {
                const raw = parseFloat(e.target.value);
                if (isNaN(raw)) return;
                const value = clampSeaHeight(raw);
                syncSeaHeightUI(value);
                applySeaHeight(value);
            });

            // Material rotation slider
            const matRotSlider = document.getElementById('mat-rotation');
            const matRotValue = document.getElementById('mat-rotation-value');
            matRotSlider.value = matRotationDeg;
            matRotValue.textContent = Math.round(matRotationDeg);
            matRotSlider.addEventListener('input', (e) => {
                matRotationDeg = parseFloat(e.target.value) || 0;
                matRotValue.textContent = Math.round(matRotationDeg);
                applySeaThreshold();
            });

            // Material flip toggles
            const flipUEl = document.getElementById('mat-flip-u');
            const flipVEl = document.getElementById('mat-flip-v');
            flipUEl.checked = !!flipMaterialU;
            flipVEl.checked = !!flipMaterialV;
            flipUEl.addEventListener('change', (e) => {
                flipMaterialU = !!e.target.checked;
                applySeaThreshold();
            });
            flipVEl.addEventListener('change', (e) => {
                flipMaterialV = !!e.target.checked;
                applySeaThreshold();
            });

            // Height map rotation slider
            const heightRotSlider = document.getElementById('height-rotation');
            const heightRotValue = document.getElementById('height-rotation-value');
            heightRotSlider.value = heightRotationDeg;
            heightRotValue.textContent = Math.round(heightRotationDeg);
            heightRotSlider.addEventListener('input', (e) => {
                heightRotationDeg = parseFloat(e.target.value) || 0;
                heightRotValue.textContent = Math.round(heightRotationDeg);
                applyHeightMapRotation();
            });

            // Height map flip checkboxes
            const heightFlipUEl = document.getElementById('height-flip-u');
            const heightFlipVEl = document.getElementById('height-flip-v');
            heightFlipUEl.checked = flipHeightU;
            heightFlipVEl.checked = flipHeightV;
            heightFlipUEl.addEventListener('change', (e) => {
                flipHeightU = !!e.target.checked;
                applyHeightMapRotation();
            });
            heightFlipVEl.addEventListener('change', (e) => {
                flipHeightV = !!e.target.checked;
                applyHeightMapRotation();
            });
        }

        function loadTexturePromise(url) {
            return new Promise((resolve, reject) => {
                new THREE.TextureLoader().load(url, (texture) => {
                    // Use linear filtering for smooth, non-pixelated textures
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    resolve(texture);
                }, undefined, reject);
            });
        }

        function getImageDataFromTexture(tex) {
            const img = tex.image;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            return { data: imageData.data, width: canvas.width, height: canvas.height };
        }

        function loadHeightmap() {
            console.log('Loading maps...');
            const cacheBuster = '?t=' + Date.now();
            Promise.all([
                loadTexturePromise('Assets/images/Map/Map Height Map.png' + cacheBuster),
                loadTexturePromise('Assets/images/Map/JUNK Map.png' + cacheBuster)
            ]).then(async ([heightTex, materialTex]) => {
                const h = getImageDataFromTexture(heightTex);
                const m = getImageDataFromTexture(materialTex);

                // Store heightmap globally for rotation
                heightImageData = h.data;
                heightW = h.width;
                heightH = h.height;

                // Store material globally for land coloring
                matImageData = m.data;
                matW = m.width;
                matH = m.height;

                console.log('Creating terrain grid...');
                await createGridTerrain(h.data, h.width, h.height, materialTex);
                console.log('Terrain created, starting animation');

                document.getElementById('loading').style.display = 'none';

                animationStartTime = Date.now();
                startCameraIntro();
            }).catch((error) => {
                console.error('Error loading maps:', error);
                document.getElementById('loading').innerText = 'ERROR LOADING TERRAIN';
            });
        }

        // Simple noise function
        function noise2D(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return n - Math.floor(n);
        }

        // Sample material color with optional V-flip and rotation
        function sampleMaterialColor(u, v) {
            if (!matImageData) return [1, 1, 1];
            let uu = Math.max(0, Math.min(1, u));
            let vv = Math.max(0, Math.min(1, v));
            // Apply flips first if enabled
            if (flipMaterialU) uu = 1 - uu;
            if (flipMaterialV) vv = 1 - vv;
            // Apply rotation about center (0.5, 0.5)
            if (matRotationDeg !== 0) {
                const rad = matRotationDeg * Math.PI / 180;
                const cosr = Math.cos(rad);
                const sinr = Math.sin(rad);
                const cx = uu - 0.5;
                const cy = vv - 0.5;
                const rx = cx * cosr - cy * sinr;
                const ry = cx * sinr + cy * cosr;
                uu = Math.max(0, Math.min(1, rx + 0.5));
                vv = Math.max(0, Math.min(1, ry + 0.5));
            }
            const x = Math.min(matW - 1, Math.floor(uu * matW));
            const y = Math.min(matH - 1, Math.floor(vv * matH));
            const i = (y * matW + x) * 4;
            return [matImageData[i] / 255, matImageData[i + 1] / 255, matImageData[i + 2] / 255];
        }

        // Sample heightmap with rotation and flip
        function sampleHeightmap(u, v) {
            if (!heightImageData) return 0;
            let uu = Math.max(0, Math.min(1, u));
            let vv = Math.max(0, Math.min(1, v));
            // Apply flips first
            if (flipHeightU) uu = 1 - uu;
            if (flipHeightV) vv = 1 - vv;
            // Apply rotation about center (0.5, 0.5)
            if (heightRotationDeg !== 0) {
                const rad = heightRotationDeg * Math.PI / 180;
                const cosr = Math.cos(rad);
                const sinr = Math.sin(rad);
                const cx = uu - 0.5;
                const cy = vv - 0.5;
                const rx = cx * cosr - cy * sinr;
                const ry = cx * sinr + cy * cosr;
                uu = Math.max(0, Math.min(1, rx + 0.5));
                vv = Math.max(0, Math.min(1, ry + 0.5));
            }
            const x = Math.min(heightW - 1, Math.floor(uu * heightW));
            const y = Math.min(heightH - 1, Math.floor(vv * heightH));
            const i = (y * heightW + x) * 4;
            return heightImageData[i] / 255; // Return grayscale value
        }

        // Apply height map rotation to terrain
        function applyHeightMapRotation() {
            updateTerrainHeights();
        }

        async function createGridTerrain(data, width, height, materialTex) {
            const segments = Math.min(width, height) / sampleRate;

            // Create plane geometry with segments matching the texture resolution
            const geometry = new THREE.PlaneGeometry(128, 128, segments - 1, segments - 1);

            // Apply the material texture directly
            const material = new THREE.MeshBasicMaterial({
                map: materialTex,
                side: THREE.DoubleSide
            });

            // Get position attribute to modify heights
            const positions = geometry.attributes.position;

            // Modify vertex heights based on heightmap (using sampleHeightmap for rotation/flip)
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getY(i); // In PlaneGeometry, Y is the vertical axis

                // Convert world position to texture coordinates
                const u = (x + 64) / 128; // 0 to 1
                const v = (z + 64) / 128; // 0 to 1

                // Sample heightmap with rotation and flip applied
                const grayscale = sampleHeightmap(u, v);

                // Calculate vertex height
                const isOcean = grayscale <= seaThreshold;
                const vertexHeight = isOcean ? seaFlatHeight : (grayscale * heightScale + 0.5);

                // Set Z position (height in plane geometry)
                positions.setZ(i, vertexHeight);
            }

            positions.needsUpdate = true;
            geometry.computeVertexNormals(); // Recalculate normals for proper lighting

            // Create mesh
            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.rotation.x = -Math.PI / 2; // Rotate to lay flat
            scene.add(terrainMesh);

            // Create extended ocean plane (same color as terrain ocean)
            // Find an ocean pixel by checking the heightmap for dark areas
            const oceanCanvas = document.createElement('canvas');
            oceanCanvas.width = materialTex.image.width;
            oceanCanvas.height = materialTex.image.height;
            const oceanCtx = oceanCanvas.getContext('2d');
            oceanCtx.drawImage(materialTex.image, 0, 0);

            // Find ocean color by scanning for a pixel where heightmap is dark (ocean)
            let oceanColor = new THREE.Color(0x87CEEB); // Default fallback
            const matImgData = oceanCtx.getImageData(0, 0, materialTex.image.width, materialTex.image.height).data;

            for (let i = 0; i < data.length; i += 4) {
                const grayscale = data[i] / 255;
                if (grayscale <= seaThreshold) {
                    // Found an ocean pixel, get color from material texture at same position
                    const pixelIndex = i; // Same index in material image
                    if (pixelIndex < matImgData.length - 3) {
                        oceanColor = new THREE.Color(
                            matImgData[pixelIndex] / 255,
                            matImgData[pixelIndex + 1] / 255,
                            matImgData[pixelIndex + 2] / 255
                        );
                        break;
                    }
                }
            }

            const oceanGeometry = new THREE.PlaneGeometry(1024, 1024);
            const oceanMaterial = new THREE.MeshBasicMaterial({
                color: oceanColor,
                side: THREE.DoubleSide
            });
            const oceanPlane = new THREE.Mesh(oceanGeometry, oceanMaterial);
            oceanPlane.rotation.x = -Math.PI / 2;
            oceanPlane.position.y = seaFlatHeight - 0.1; // Slightly below terrain ocean
            scene.add(oceanPlane);

            // Load saved journeys
            await loadJourneyData();
            journeyPoints = buildJourneyPoints(selectedPersonName);

            // Load saved labels
            loadLabels();

            // Setup label click handler
            setupLabelClickHandler();

            // Start auto-sync to get updates from other users
            startAutoSync();

            // Start with overview (no journey points)
            showOverview();
        }

        // Get terrain height at a given world position
        function getTerrainHeight(worldX, worldZ, heightData, dataWidth, dataHeight) {
            // Convert world position to texture coordinates
            const u = (worldX + 64) / 128;
            const v = (worldZ + 64) / 128;

            // Clamp to valid range
            const clampedU = Math.max(0, Math.min(1, u));
            const clampedV = Math.max(0, Math.min(1, v));

            // Sample heightmap
            const dataX = Math.floor(clampedU * dataWidth);
            const dataZ = Math.floor(clampedV * dataHeight);
            const index = (dataZ * dataWidth + dataX) * 4;
            const grayscale = heightData[index] / 255;

            // Calculate height
            const isOcean = grayscale <= seaThreshold;
            return isOcean ? seaFlatHeight : (grayscale * heightScale + 0.5);
        }

        function clearJourneySystem() {
            journeyMarkers.forEach(({ sphere, ring, label }) => {
                scene.remove(sphere);
                scene.remove(ring);
                scene.remove(label);
            });
            journeyMarkers = [];

            journeyLines.forEach(({ line, dashLine }) => {
                if (line) scene.remove(line);
                if (dashLine) scene.remove(dashLine);
            });
            journeyLines = [];
            selectedJourneyPoint = null;
            journeyTransitioning = false;
            journeySavedCameraPos = null;
            journeySavedTarget = null;
        }

        // Create journey markers and connecting lines
        function createJourneySystem(heightData, dataWidth, dataHeight) {
            if (!heightData || journeyPoints.length === 0) return;

            const pointsByPerson = journeyPoints.reduce((acc, point) => {
                const person = point.person || 'unknown';
                if (!acc[person]) acc[person] = [];
                acc[person].push(point);
                return acc;
            }, {});

            Object.entries(pointsByPerson).forEach(([personName, points]) => {
                const personColorHex = personColors[personName] || 0x6b4ce6;
                const personColor = new THREE.Color(personColorHex);
                const linePoints = [];

                points.forEach((point, index) => {
                    // Get terrain height at this position
                    const terrainHeight = getTerrainHeight(point.x, point.z, heightData, dataWidth, dataHeight);
                    point.y = terrainHeight + 2; // Slightly above terrain

                    // Create 3D sphere marker
                    const sphereGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                    const sphereMaterial = new THREE.MeshBasicMaterial({
                        color: personColorHex,
                        transparent: true,
                        opacity: 0.9
                    });
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.set(point.x, point.y, point.z);
                    sphere.userData = { journeyPoint: point, index: index };
                    scene.add(sphere);

                    // Create pulsing ring around sphere
                    const ringGeometry = new THREE.RingGeometry(2, 2.5, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: personColorHex,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.set(point.x, point.y, point.z);
                    ring.rotation.x = -Math.PI / 2;
                    ring.userData = { pulseTime: index * 0.5 }; // Offset pulse timing
                    scene.add(ring);

                    // Create CSS2D label
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'journey-marker';
                    labelDiv.style.setProperty('--journey-accent', hexToRgba(personColorHex, 0.85));
                    labelDiv.style.setProperty('--journey-accent-surface', hexToRgba(personColorHex, 0.16));
                    labelDiv.style.setProperty('--journey-accent-border', hexToRgba(personColorHex, 0.35));
                    labelDiv.style.boxShadow = `0 12px 32px ${hexToRgba(personColorHex, 0.2)}`;

                    // Show only icon when viewing all journeys, show number + name for individual person
                    if (currentPerson === 'all' && !editMode) {
                        labelDiv.classList.add('icon-only');
                        labelDiv.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
                    } else {
                        labelDiv.innerHTML = `
                            <span class="journey-number">${index + 1}</span>
                            <span>${point.name}</span>
                        `;
                    }
                    const label = new CSS2DObject(labelDiv);
                    label.position.set(point.x, point.y + 3, point.z);
                    scene.add(label);

                    const markerObj = {
                        point: point,
                        sphere: sphere,
                        ring: ring,
                        label: label
                    };

                    // Allow clicking the label to open the gallery in normal mode
                    labelDiv.style.pointerEvents = 'auto';
                    labelDiv.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (editMode) return;
                        onJourneyPointClick(markerObj);
                    });
                    // Allow dragging via the label in edit mode
                    labelDiv.addEventListener('mousedown', (e) => {
                        if (!editMode) return;
                        e.stopPropagation();
                        draggingJourneyMarker = markerObj;
                        setEditingPoint(markerObj.point);
                        controls.enabled = false;
                    });

                    journeyMarkers.push(markerObj);

                    // Add to line points
                    linePoints.push(new THREE.Vector3(point.x, point.y + 0.5, point.z));
                });

                // Create connecting line using CatmullRomCurve3 for smooth path
                if (linePoints.length > 1) {
                    const curve = new THREE.CatmullRomCurve3(linePoints, false, 'catmullrom', 0.5);
                    const curvePoints = curve.getPoints(100);
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: personColorHex,
                        transparent: true,
                        opacity: 0.7
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    scene.add(line);

                    // Create animated dashed line on top
                    const dashGeometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
                    const dashMaterial = new THREE.LineDashedMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8,
                        dashSize: 2,
                        gapSize: 1
                    });
                    const dashLine = new THREE.Line(dashGeometry, dashMaterial);
                    dashLine.computeLineDistances();
                    dashLine.userData = { dashOffset: 0 };
                    scene.add(dashLine);

                    journeyLines.push({ line, dashLine, dashOffset: 0 });
                }
            });
        }

        // Animate journey elements
        function animateJourney() {
            const time = Date.now() * 0.001;

            journeyMarkers.forEach((marker, index) => {
                // Pulse effect on rings
                const pulsePhase = time + marker.ring.userData.pulseTime;
                const pulseScale = 1 + Math.sin(pulsePhase * 2) * 0.2;
                marker.ring.scale.set(pulseScale, pulseScale, 1);
                marker.ring.material.opacity = 0.3 + Math.sin(pulsePhase * 2) * 0.2;

                // Gentle bob on spheres
                const bobOffset = Math.sin(time * 1.5 + index * 0.7) * 0.3;
                marker.sphere.position.y = marker.point.y + bobOffset;
                marker.label.position.y = marker.point.y + 3 + bobOffset;
            });

            // Animate dashed lines
            journeyLines.forEach((lineObj) => {
                if (!lineObj.dashLine) return;
                lineObj.dashOffset = (lineObj.dashOffset || 0) - 0.05;
                lineObj.dashLine.material.dashOffset = lineObj.dashOffset;
            });
        }

        // Handle journey point click
        function onJourneyPointClick(marker) {
            selectedJourneyPoint = marker;

            // Save current camera state
            journeySavedCameraPos = camera.position.clone();
            journeySavedTarget = controls.target.clone();

            // Start transition
            journeyTransitioning = true;
            journeyTransitionProgress = 0;
            controls.enabled = false;
        }

        // Update journey camera transition
        function updateJourneyCamera() {
            if (!journeyTransitioning || !selectedJourneyPoint) return;

            journeyTransitionProgress += 0.02;
            if (journeyTransitionProgress >= 1) {
                journeyTransitionProgress = 1;
                journeyTransitioning = false;

                // Show media popup when zoom complete
                showMediaPopup(selectedJourneyPoint.point);
            }

            const eased = 1 - Math.pow(1 - journeyTransitionProgress, 3);

            // Calculate target camera position (close to the point)
            const point = selectedJourneyPoint.point;
            const targetPos = new THREE.Vector3(
                point.x + 15,
                point.y + 12,
                point.z + 15
            );
            const targetLookAt = new THREE.Vector3(point.x, point.y, point.z);

            // Lerp camera
            camera.position.lerpVectors(journeySavedCameraPos, targetPos, eased);
            controls.target.lerpVectors(journeySavedTarget, targetLookAt, eased);
            camera.lookAt(controls.target);
        }

        // Show media popup
        function showMediaPopup(point) {
            // Find the index of this point in journeyPoints
            currentJourneyIndex = journeyPoints.findIndex(p => p.id === point.id && p.person === point.person);
            if (currentJourneyIndex === -1) currentJourneyIndex = 0;

            updateGalleryContent();
            updateGalleryDots();
            updateGalleryNavButtons();

            const popup = document.getElementById('media-popup');
            popup.classList.add('visible');

            // Add keyboard listener
            document.addEventListener('keydown', handleGalleryKeydown);
        }

        // Update gallery content for current journey point
        function updateGalleryContent() {
            const point = journeyPoints[currentJourneyIndex];
            if (!point) return;

            const title = document.getElementById('media-title');
            const description = document.getElementById('media-description');
            const placeholder = document.getElementById('media-placeholder');
            const rawMedia = point.media || '';
            const mediaType = point.mediaType || detectMediaType(rawMedia);

            title.textContent = point.name;
            description.textContent = point.description;

            // Set media content
            if (rawMedia && mediaType === 'image') {
                placeholder.innerHTML = `<img src="${rawMedia}" alt="${point.name}">`;
            } else if (mediaType === 'embed') {
                // Render embed code directly (iframe/div snippets from Vimeo, etc.)
                // Strip script tags as they won't execute via innerHTML
                const cleanEmbed = rawMedia.replace(/<script[^>]*>.*?<\/script>/gi, '');
                placeholder.innerHTML = `<div style="width:80vw;max-width:800px;aspect-ratio:16/9;border-radius:12px;overflow:hidden;">${cleanEmbed}</div>`;
                // Fix any nested iframe to fill the container
                const iframe = placeholder.querySelector('iframe');
                if (iframe) {
                    iframe.style.cssText = 'width:100%;height:100%;border:0;';
                }
                // Remove the wrapper div from Vimeo embed if present
                const innerDiv = placeholder.querySelector('.gallery-media > div > div');
                if (innerDiv && innerDiv.style.padding) {
                    innerDiv.style.cssText = 'width:100%;height:100%;position:relative;';
                }
            } else if (mediaType === 'video') {
                placeholder.innerHTML = `<video controls><source src="${rawMedia}" type="video/mp4">Your browser does not support video.</video>`;
            } else if (mediaType === 'hls') {
                const videoId = 'hls-video-' + Date.now();
                placeholder.innerHTML = `<div style="position:relative;padding-bottom:56.25%;height:0;overflow:hidden;border-radius:12px;background:#000;"><video id="${videoId}" controls playsinline style="position:absolute;top:0;left:0;width:100%;height:100%;border:0;"></video></div>`;
                const video = document.getElementById(videoId);
                if (window.Hls && Hls.isSupported()) {
                    const hls = new Hls();
                    hls.loadSource(rawMedia);
                    hls.attachMedia(video);
                    hls.on(Hls.Events.ERROR, () => {
                        placeholder.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
                    });
                } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    video.src = rawMedia;
                } else {
                    placeholder.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
                }
            } else if (mediaType === 'vimeo-external') {
                const vimeoId = getVimeoExternalId(rawMedia);
                if (vimeoId) {
                    const embedUrl = `https://player.vimeo.com/video/${vimeoId}?playsinline=1`;
                    placeholder.innerHTML = `<div style="position:relative;padding-bottom:56.25%;height:0;overflow:hidden;border-radius:12px;"><iframe src="${embedUrl}" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0;" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe></div>`;
                } else {
                    placeholder.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
                }
            } else if (mediaType === 'vimeo') {
                const vimeoId = getVimeoId(rawMedia);
                if (vimeoId) {
                    const embedUrl = `https://player.vimeo.com/video/${vimeoId}?playsinline=1`;
                    placeholder.innerHTML = `<div style="position:relative;padding-bottom:56.25%;height:0;overflow:hidden;border-radius:12px;"><iframe src="${embedUrl}" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0;" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe></div>`;
                } else {
                    placeholder.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
                }
            } else {
                placeholder.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
            }
        }

        // Update gallery navigation dots
        function updateGalleryDots() {
            const dotsContainer = document.getElementById('gallery-dots');
            dotsContainer.innerHTML = '';
            dotsContainer.style.display = 'flex';

            journeyPoints.forEach((point, index) => {
                const dot = document.createElement('div');
                dot.className = 'gallery-dot' + (index === currentJourneyIndex ? ' active' : '');
                dot.textContent = index + 1;
                dot.onclick = () => goToJourneyPoint(index);
                dotsContainer.appendChild(dot);
            });
        }

        // Update navigation button visibility
        function updateGalleryNavButtons() {
            const prevBtn = document.querySelector('.gallery-prev');
            const nextBtn = document.querySelector('.gallery-next');

            prevBtn.classList.toggle('hidden', currentJourneyIndex === 0);
            nextBtn.classList.toggle('hidden', currentJourneyIndex === journeyPoints.length - 1);
        }

        // Navigate to specific journey point by index
        function goToJourneyPoint(index) {
            if (index < 0 || index >= journeyPoints.length) return;
            currentJourneyIndex = index;
            updateGalleryContent();
            updateGalleryDots();
            updateGalleryNavButtons();
            animateCameraToCurrentPoint();
        }

        // Navigate journey by direction (-1 for prev, +1 for next)
        window.navigateJourney = function(direction) {
            const newIndex = currentJourneyIndex + direction;
            if (newIndex < 0 || newIndex >= journeyPoints.length) return;
            goToJourneyPoint(newIndex);
        };

        // Animate camera to the current journey point
        function animateCameraToCurrentPoint() {
            const point = journeyPoints[currentJourneyIndex];
            if (!point) return;

            const targetPos = new THREE.Vector3(point.x + 15, point.y + 12, point.z + 15);
            const targetLookAt = new THREE.Vector3(point.x, point.y, point.z);

            let progress = 0;
            const animateCamera = () => {
                progress += 0.04;
                if (progress >= 1) {
                    camera.position.copy(targetPos);
                    controls.target.copy(targetLookAt);
                    camera.lookAt(controls.target);
                    return;
                }

                const eased = 1 - Math.pow(1 - progress, 3);
                camera.position.lerp(targetPos, eased * 0.15);
                controls.target.lerp(targetLookAt, eased * 0.15);
                camera.lookAt(controls.target);

                requestAnimationFrame(animateCamera);
            };

            animateCamera();
        }

        // Handle keyboard navigation in gallery
        function handleGalleryKeydown(e) {
            if (e.key === 'ArrowLeft') {
                navigateJourney(-1);
            } else if (e.key === 'ArrowRight') {
                navigateJourney(1);
            } else if (e.key === 'Escape') {
                closeMediaPopup();
            }
        }

        // Close media popup (global function for onclick)
        window.closeMediaPopup = function() {
            const popup = document.getElementById('media-popup');
            popup.classList.remove('visible');

            // Remove keyboard listener
            document.removeEventListener('keydown', handleGalleryKeydown);

            // Clear selected journey point immediately to allow new clicks
            selectedJourneyPoint = null;

            // Return camera to saved position
            if (journeySavedCameraPos && journeySavedTarget) {
                journeyTransitioning = true;
                journeyTransitionProgress = 0;

                const returnTransition = () => {
                    journeyTransitionProgress += 0.03;
                    if (journeyTransitionProgress >= 1) {
                        journeyTransitionProgress = 1;
                        controls.enabled = true;
                        journeyTransitioning = false;
                        return;
                    }

                    const eased = 1 - Math.pow(1 - journeyTransitionProgress, 3);
                    camera.position.lerp(journeySavedCameraPos, eased * 0.1);
                    controls.target.lerp(journeySavedTarget, eased * 0.1);
                    camera.lookAt(controls.target);

                    requestAnimationFrame(returnTransition);
                };

                returnTransition();
            } else {
                controls.enabled = true;
            }
        };

        // Also close popup when clicking outside (on the dark background)
        document.getElementById('media-popup').addEventListener('click', function(e) {
            if (e.target === this) {
                closeMediaPopup();
            }
        });

        function getAnimationDelay(x, z, width, height) {
            // Ripple from center
            const centerX = width / 2;
            const centerZ = height / 2;
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(z - centerZ, 2));
            const maxDistance = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerZ, 2));
            return (distance / maxDistance) * 2000; // 2 second wave
        }

        function startCameraIntro() {
            if (!cameraMixer) {
                cameraMixer = new THREE.AnimationMixer(camera);

                // Simple straight down zoom - start and end are both top-down
                const start = new THREE.Vector3(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
                const end = new THREE.Vector3(cameraEndPos.x, cameraEndPos.y, cameraEndPos.z);

                // Create smooth animation for straight zoom
                const duration = 3.2; // seconds
                const samples = 100;
                const times = new Float32Array(samples);
                const values = new Float32Array(samples * 3);

                for (let i = 0; i < samples; i++) {
                    const t = i / (samples - 1);
                    // Ease-out for gentle finish
                    const te = 1 - Math.pow(1 - t, 3); // easeOutCubic
                    times[i] = t * duration;
                    values[i * 3 + 0] = start.x + (end.x - start.x) * te;
                    values[i * 3 + 1] = start.y + (end.y - start.y) * te;
                    values[i * 3 + 2] = start.z + (end.z - start.z) * te;
                }

                const positionTrack = new THREE.VectorKeyframeTrack('.position', times, values);
                positionTrack.setInterpolation(THREE.InterpolateSmooth);
                const clip = new THREE.AnimationClip('CameraIntro', duration, [positionTrack]);

                cameraAction = cameraMixer.clipAction(clip);
                cameraAction.setLoop(THREE.LoopOnce, 1);
                cameraAction.clampWhenFinished = true;

                cameraMixer.addEventListener('finished', (event) => {
                    if (event.action === cameraAction) {
                        cameraIntroPlaying = false;
                        updateCameraControlDisplays();
                    }
                });
            }

            camera.position.set(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
            controls.target.set(0, 0, 0);
            controls.update();

            if (cameraAction) {
                cameraAction.reset();
                cameraAction.play();
            }

            cameraIntroPlaying = true;

            // Add listener to stop intro on user interaction
            const stopIntroOnInteraction = () => {
                stopCameraIntro();
                controls.domElement.removeEventListener('pointerdown', stopIntroOnInteraction);
            };
            controls.domElement.addEventListener('pointerdown', stopIntroOnInteraction);
            updateCameraControlDisplays();
        }

        function stopCameraIntro() {
            if (!cameraIntroPlaying) return;

            // Just pause the action instead of stopping (stop() resets position)
            if (cameraAction) {
                cameraAction.paused = true;
            }
            cameraIntroPlaying = false;

            // Set fog to final values (no visible fog)
            scene.fog.near = 400;
            scene.fog.far = 600;

            updateCameraControlDisplays();
        }

        function updateCameraControlDisplays() {
            const yActive = posYSlider && document.activeElement === posYSlider;
            if (posYSlider && !yActive) {
                posYSlider.value = Math.round(camera.position.y);
            }
            if (posYValueDisplay && !yActive) {
                posYValueDisplay.textContent = Math.round(camera.position.y);
            }

            const xActive = posXSlider && document.activeElement === posXSlider;
            if (posXSlider && !xActive) {
                posXSlider.value = Math.round(camera.position.x);
            }
            if (posXValueDisplay && !xActive) {
                posXValueDisplay.textContent = Math.round(camera.position.x);
            }
        }

        function updateTerrainHeights() {
            if (!terrainMesh || !heightImageData) return;
            const positions = terrainMesh.geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getY(i);
                const u = (x + 64) / 128;
                const v = (z + 64) / 128;
                const grayscale = sampleHeightmap(u, v);
                const isOcean = grayscale <= seaThreshold;
                const vertexHeight = isOcean ? seaFlatHeight : (grayscale * heightScale + 0.5);
                positions.setZ(i, vertexHeight);
            }
            positions.needsUpdate = true;
            terrainMesh.geometry.computeVertexNormals();
        }

        function applySeaThreshold() {
            updateTerrainHeights();
        }

        function applyHeightScale() {
            updateTerrainHeights();
        }

        function onMouseDown(event) {
            mouseDownPos.x = event.clientX;
            mouseDownPos.y = event.clientY;
            isDragging = false;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Stop camera intro animation if user clicks/drags
            if (cameraIntroPlaying) {
                if (cameraAction) {
                    cameraAction.stop();
                }
                cameraIntroPlaying = false;
                controls.enabled = true;
            }

            // Begin dragging journey marker in edit mode
            if (editMode && journeysVisible) {
                raycaster.setFromCamera(mouse, camera);
                const journeySpheres = journeyMarkers.map(m => m.sphere);
                const journeyIntersects = raycaster.intersectObjects(journeySpheres);
                if (journeyIntersects.length > 0) {
                    const clickedSphere = journeyIntersects[0].object;
                    const marker = journeyMarkers.find(m => m.sphere === clickedSphere);
                    if (marker) {
                        draggingJourneyMarker = marker;
                        setEditingPoint(marker.point);
                        controls.enabled = false;
                    }
                }
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check if mouse moved significantly from mousedown position
            if (mouseDownPos.x !== undefined && mouseDownPos.y !== undefined) {
                const dx = event.clientX - mouseDownPos.x;
                const dy = event.clientY - mouseDownPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 5) { // 5 pixel threshold
                    isDragging = true;
                }
            }

            // Drag journey marker across terrain in edit mode
            if (editMode && draggingJourneyMarker && terrainMesh && heightImageData) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(terrainMesh);
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const terrainHeight = getTerrainHeight(point.x, point.z, heightImageData, heightW, heightH);
                    const markerPoint = draggingJourneyMarker.point;
                    markerPoint.x = point.x;
                    markerPoint.z = point.z;
                    markerPoint.y = terrainHeight + 2;
                    draggingJourneyMarker.sphere.position.set(markerPoint.x, markerPoint.y, markerPoint.z);
                    draggingJourneyMarker.ring.position.set(markerPoint.x, markerPoint.y, markerPoint.z);
                    draggingJourneyMarker.label.position.set(markerPoint.x, markerPoint.y + 3, markerPoint.z);
                }
            }
        }

        function onMouseUp(event) {
            // Reset mousedown position
            mouseDownPos.x = undefined;
            mouseDownPos.y = undefined;

            if (draggingJourneyMarker) {
                draggingJourneyMarker = null;
                rebuildJourneySystem();
                if (!editMode) {
                    controls.enabled = true;
                }
            }

            // Reset after a short delay to allow click event to fire
            setTimeout(() => {
                isDragging = false;
            }, 50);
        }

        function showNotification(success, message) {
            const notification = document.getElementById('notification');
            const icon = notification.querySelector('.icon');
            const messageEl = notification.querySelector('.message');

            // Update content
            icon.textContent = success ? '✓' : '✕';
            messageEl.textContent = message;

            // Update styling and show
            notification.className = success ? 'success visible' : 'error visible';

            // Auto-hide after 2 seconds
            setTimeout(() => {
                notification.classList.remove('visible');
            }, 2000);
        }

        async function loadJourneyData() {
            try {
                const response = await fetch(`${JSONBIN_URL}/latest`, {
                    method: 'GET',
                    headers: {
                        'X-Master-Key': JSONBIN_API_KEY
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    const remoteJourneys = result.record?.journeys;
                    allJourneys = normalizeJourneyData(remoteJourneys);
                    if (journeysVisible) {
                        journeyPoints = buildJourneyPoints(selectedPersonName);
                        rebuildJourneySystem();
                    }
                    return;
                }
            } catch (e) {
                console.warn('Failed to load journeys from JSONBin, using defaults', e);
            }

            allJourneys = normalizeJourneyData(allJourneys);
        }

        async function saveJourneysToBin() {
            lastJourneySaveTime = Date.now();
            try {
                let existingRecord = {};
                try {
                    const getResponse = await fetch(`${JSONBIN_URL}/latest`, {
                        method: 'GET',
                        headers: {
                            'X-Master-Key': JSONBIN_API_KEY
                        }
                    });
                    if (getResponse.ok) {
                        const result = await getResponse.json();
                        existingRecord = result.record || {};
                    }
                } catch (e) {
                    console.warn('Could not fetch existing journeys, saving anyway', e);
                }

                const sanitizedJourneys = normalizeJourneyData(allJourneys);
                const nextBody = { ...existingRecord, journeys: sanitizedJourneys };
                const response = await fetch(JSONBIN_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': JSONBIN_API_KEY
                    },
                    body: JSON.stringify(nextBody)
                });

                if (!response.ok) {
                    showNotification(false, 'Journeys not saved');
                    return false;
                }

                await response.json();
                showNotification(true, 'Journeys synced');
                return true;
            } catch (error) {
                console.error('Error saving journeys:', error);
                showNotification(false, 'Journeys not saved');
                return false;
            }
        }

        function syncJourneysFromRemote(remoteJourneys) {
            const normalized = normalizeJourneyData(remoteJourneys);
            const localSerialized = JSON.stringify(allJourneys);
            const remoteSerialized = JSON.stringify(normalized);
            if (localSerialized !== remoteSerialized) {
                allJourneys = normalized;
                if (journeysVisible) {
                    journeyPoints = buildJourneyPoints(selectedPersonName);
                    rebuildJourneySystem();
                }
            }
        }

        function startAutoSync() {
            // Poll for updates every 5 seconds
            setInterval(async () => {
                if (Date.now() - lastJourneySaveTime < 10000) return;
                if (editMode) return;

                try {
                    const response = await fetch(`${JSONBIN_URL}/latest`, {
                        method: 'GET',
                        headers: { 'X-Master-Key': JSONBIN_API_KEY }
                    });

                    if (!response.ok) return;
                    const result = await response.json();
                    const remoteJourneys = result.record?.journeys || {};
                    syncJourneysFromRemote(remoteJourneys);
                } catch (e) {
                    // Silently fail - don't spam console with sync errors
                }
            }, 5000); // Sync every 5 seconds
        }
        function onMouseClick(event) {
            if (cameraIntroPlaying) return; // Don't allow clicks during intro
            if (isDragging) return; // Don't allow selection if dragging
            if (selectedJourneyPoint) return; // Don't allow clicks while viewing journey point

            // Edit mode: select marker for editing instead of triggering gallery
            if (editMode) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const journeySpheres = journeyMarkers.map(m => m.sphere);
                const journeyIntersects = raycaster.intersectObjects(journeySpheres);
                if (journeyIntersects.length > 0) {
                    const clickedSphere = journeyIntersects[0].object;
                    const marker = journeyMarkers.find(m => m.sphere === clickedSphere);
                    if (marker) {
                        setEditingPoint(marker.point);
                        return;
                    }
                }
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check for journey marker clicks
            raycaster.setFromCamera(mouse, camera);
            const journeySpheres = journeyMarkers.map(m => m.sphere);
            const journeyIntersects = raycaster.intersectObjects(journeySpheres);

            if (journeyIntersects.length > 0) {
                const clickedSphere = journeyIntersects[0].object;
                const marker = journeyMarkers.find(m => m.sphere === clickedSphere);
                if (marker) {
                    onJourneyPointClick(marker);
                    return;
                }
            }
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateCameraAnimation(delta) {
            if (!cameraMixer || !cameraAction || !cameraIntroPlaying) return;

            cameraMixer.update(delta);

            updateCameraControlDisplays();

            // Animate fog based on camera Y position
            // At start (y=260): fog near=100, far=200 (heavy fog, 2D look)
            // At end (y=140): fog near=400, far=600 (no visible fog)
            const startY = cameraStartPos.y;
            const endY = cameraEndPos.y;
            const currentY = camera.position.y;

            // Calculate progress (0 at start, 1 at end)
            const progress = Math.max(0, Math.min(1, (startY - currentY) / (startY - endY)));

            // Interpolate fog values
            const fogNearStart = 100;
            const fogNearEnd = 400;
            const fogFarStart = 200;
            const fogFarEnd = 600;

            scene.fog.near = fogNearStart + (fogNearEnd - fogNearStart) * progress;
            scene.fog.far = fogFarStart + (fogFarEnd - fogFarStart) * progress;
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (!journeyTransitioning) {
                controls.update();
            }
            updateCameraAnimation(delta);
            animateJourney();
            updateJourneyCamera();

            // Rotate lights
            const time = Date.now() * 0.0003;
            scene.children.forEach(child => {
                if (child instanceof THREE.PointLight) {
                    const radius = 80;
                    child.position.x = Math.sin(time) * radius;
                    child.position.z = Math.cos(time) * radius;
                }
            });

            composer.render();
            labelRenderer.render(scene, camera);
        }

        init();
        animate();

        // Navigation functions
        function setJourneySelection(selection = 'all') {
            let normalizedSelection = selection === 'all' || allJourneys[selection] ? selection : 'all';
            if (editMode && normalizedSelection === 'all') {
                normalizedSelection = editingPoint?.person || getSortedPeople()[0] || 'all';
            }
            selectedPersonName = normalizedSelection;
            currentPerson = normalizedSelection; // Update currentPerson for marker display

            const overviewBtn = document.getElementById('journey-overview');
            if (overviewBtn) {
                overviewBtn.classList.toggle('selected', normalizedSelection === 'all');
            }

            const popup = document.getElementById('media-popup');
            if (popup) {
                popup.classList.remove('visible');
            }

            document.querySelectorAll('.journey-nav-item').forEach(item => {
                const person = item.getAttribute('data-person');
                item.classList.toggle('selected', person === normalizedSelection);
            });

            // Only build and show journey points if journeys are visible
            if (journeysVisible) {
                journeyPoints = buildJourneyPoints(normalizedSelection);

                if (heightImageData) {
                    clearJourneySystem();
                    createJourneySystem(heightImageData, heightW, heightH);
                }
            }
        }

        window.selectPerson = function(personName) {
            // Show journey points when selecting a person
            journeysVisible = true;
            const nextSelection = editMode ? personName : (selectedPersonName === personName ? 'all' : personName);

            // Update overview button state
            const overviewBtn = document.getElementById('overview-btn');
            if (overviewBtn) {
                overviewBtn.classList.remove('selected');
            }

            // Update journey-overview button state based on selection
            const journeyOverviewBtn = document.getElementById('journey-overview');
            if (journeyOverviewBtn) {
                journeyOverviewBtn.classList.toggle('selected', !editMode && nextSelection === 'all');
            }

            setJourneySelection(nextSelection);

            // When editing, refresh the editor to the newly selected person's first point
            if (editMode) {
                if (journeyPoints.length > 0) {
                    setEditingPoint(journeyPoints[0]);
                } else {
                    setEditingPoint(null);
                }
            }
        };

        window.showOverview = function() {
            if (editMode) {
                toggleEditMode(false);
            }
            journeysVisible = false;
            selectedPersonName = 'all';

            // Update button states
            const overviewBtn = document.getElementById('overview-btn');
            if (overviewBtn) {
                overviewBtn.classList.add('selected');
            }

            const aboutBtn = document.getElementById('about-btn');
            if (aboutBtn) {
                aboutBtn.classList.remove('selected');
            }

            const journeyOverviewBtn = document.getElementById('journey-overview');
            if (journeyOverviewBtn) {
                journeyOverviewBtn.classList.remove('selected');
            }

            document.querySelectorAll('.journey-nav-item[data-person]').forEach(item => {
                item.classList.remove('selected');
            });

            // Hide all journey points
            clearJourneySystem();
            journeyPoints = [];
        };

        window.showAbout = function() {
            // Update button states
            const aboutBtn = document.getElementById('about-btn');
            if (aboutBtn) {
                aboutBtn.classList.add('selected');
            }

            const overviewBtn = document.getElementById('overview-btn');
            if (overviewBtn) {
                overviewBtn.classList.remove('selected');
            }

            // TODO: Show about modal or panel
            alert('About JUNK - Coming soon!');
        };

        window.showFullJourney = function() {
            if (editMode) return; // In edit mode stay on a single person
            // Stop intro animation if playing
            stopCameraIntro();

            journeysVisible = true;

            // Update button states
            const overviewBtn = document.getElementById('overview-btn');
            if (overviewBtn) {
                overviewBtn.classList.remove('selected');
            }

            const journeyOverviewBtn = document.getElementById('journey-overview');
            if (journeyOverviewBtn) {
                journeyOverviewBtn.classList.add('selected');
            }

            setJourneySelection('all');
        };
    </script>
</body>
</html>
