<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Terrain Grid Visualization</title>
    <link rel="icon" type="image/png" href="junk-logo-square.png">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.0/dist/hls.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200');

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #f5f7fa 0%, #e8eaf6 50%, #f3e5f5 100%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 10;
        }
        #info img {
            height: 40px;
            display: block;
            filter: brightness(0);
            opacity: 0.9;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6b4ce6;
            font-size: 20px;
            font-weight: 400;
            letter-spacing: 1px;
            z-index: 5;
        }
        #notification {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            padding: 12px 20px;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }
        #notification.visible {
            opacity: 1;
        }
        #notification .icon {
            font-size: 20px;
            line-height: 1;
        }
        #notification.success .icon {
            color: #4caf50;
        }
        #notification.error .icon {
            color: #f44336;
        }
        #notification .message {
            font-size: 13px;
            font-weight: 500;
            color: #1a1a1a;
        }
        #signature {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 10;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        #signature:hover {
            opacity: 1;
        }
        #signature a {
            display: block;
            text-decoration: none;
        }
        #signature img {
            height: 50px;
            display: block;
        }
        /* Journey Media Popup - Fullscreen Gallery */
        #media-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #media-popup.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .gallery-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            font-size: 28px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.2s;
            z-index: 10;
        }
        .gallery-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        .gallery-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            font-size: 36px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.2s;
            z-index: 10;
        }
        .gallery-nav:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-50%) scale(1.1);
        }
        .gallery-nav.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .gallery-prev {
            left: 20px;
        }
        .gallery-next {
            right: 20px;
        }
        .gallery-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 90vw;
            max-height: 85vh;
            gap: 20px;
        }
        .gallery-media {
            display: flex;
            align-items: center;
            justify-content: center;
            max-width: 95vw;
            max-height: 75vh;
            border-radius: 12px;
            overflow: hidden;
            background: linear-gradient(135deg, #e8eaf6 0%, #f3e5f5 100%);
        }
        .gallery-media img,
        .gallery-media video {
            max-width: 95vw;
            max-height: 75vh;
            object-fit: contain;
            border-radius: 12px;
        }
        .gallery-media .material-symbols-outlined {
            font-size: 120px;
            color: #6b4ce6;
            padding: 80px;
        }
        .gallery-info {
            text-align: center;
            color: white;
            max-width: 800px;
            width: 90vw;
        }
        .gallery-info h2 {
            margin: 0 0 8px 0;
            font-size: 24px;
            font-weight: 600;
        }
        .gallery-info p {
            margin: 0;
            font-size: 14px;
            color: white;
            line-height: 1.5;
        }
        .gallery-dots {
            position: absolute;
            bottom: 30px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .gallery-dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
        }
        .gallery-dot:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        .gallery-dot.active {
            background: white;
            color: #1a1a1a;
            transform: scale(1.1);
        }
        .journey-marker {
            --journey-accent: rgba(107, 76, 230, 0.9);
            --journey-accent-surface: rgba(107, 76, 230, 0.14);
            --journey-accent-border: rgba(107, 76, 230, 0.35);
            position: absolute;
            background: var(--journey-accent-surface);
            border: 1px solid var(--journey-accent-border);
            backdrop-filter: blur(10px);
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: #0f172a;
            white-space: nowrap;
            pointer-events: none;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            transform: translate(-50%, -100%);
            margin-top: -12px;
            transition: opacity 0.2s ease, background 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .journey-marker::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid var(--journey-accent);
        }
        .journey-marker .material-symbols-outlined {
            font-size: 16px;
            font-variation-settings: 'FILL' 1, 'wght' 500, 'GRAD' 0, 'opsz' 20;
        }
        .journey-marker .journey-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--journey-accent);
            color: white;
            font-size: 11px;
            font-weight: 700;
        }
        /* Icon-only marker for "Everyone's Journey" view */
        .journey-marker.icon-only {
            padding: 8px;
            border-radius: 50%;
            min-width: 32px;
            min-height: 32px;
            justify-content: center;
            background: var(--journey-accent);
            border-color: rgba(255, 255, 255, 0.3);
        }
        .journey-marker.icon-only .material-symbols-outlined {
            color: white;
            font-size: 14px;
        }
        .journey-marker.icon-only::after {
            border-top-color: var(--journey-accent);
        }
        /* Journey Navigation - Apple/OpenAI Style */
        #journey-nav {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        #top-nav {
            position: absolute;
            right: 30px;
            top: 30px;
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(20px);
            padding: 12px 20px;
            border-radius: 16px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        #top-nav .journey-nav-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            min-width: auto;
        }
        #top-nav .journey-nav-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        #top-nav .journey-nav-item.selected {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-4px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }
        #top-nav .nav-name {
            color: #ffffff;
        }
        #centered-title {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Space Grotesk', 'Helvetica Neue', sans-serif;
            font-size: 48px;
            font-weight: 900;
            letter-spacing: 12px;
            color: #ffffff;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            user-select: none;
            z-index: 100;
            white-space: nowrap;
        }
        .journey-nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 140px;
            min-height: 40px;
            box-sizing: border-box;
        }
        .journey-nav-item:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateX(4px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        .journey-nav-item.selected {
            background: rgba(255, 255, 255, 0.98);
            transform: translateX(8px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
        }
        .journey-nav-item.selected .nav-dot {
            transform: scale(1.2);
            box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.1);
        }
        .nav-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .nav-name {
            font-size: 13px;
            font-weight: 500;
            color: #1a1a1a;
            letter-spacing: -0.01em;
        }
        /* Top Journey Overview Button */
        #journey-overview {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 140px;
            min-height: 40px;
            box-sizing: border-box;
        }
        #journey-overview:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateX(4px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        #journey-overview.selected {
            background: rgba(255, 255, 255, 0.98);
            transform: translateX(8px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
        }
        #journey-overview.selected .mini-dot {
            transform: scale(1.3);
        }
        .overview-icon {
            font-size: 18px;
            color: #6b4ce6;
            transition: color 0.3s;
        }
        .overview-text {
            font-size: 14px;
            font-weight: 600;
            color: #1a1a1a;
            letter-spacing: -0.01em;
            transition: color 0.3s;
        }
        .overview-dots {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }
        .overview-dots .mini-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            opacity: 0.9;
        }
        #controls {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            padding: 20px;
            color: #1a1a1a;
            font-size: 13px;
            min-width: 220px;
            z-index: 10;
            display: none;
        }
        #controls h3 {
            margin: 0 0 15px 0;
            font-size: 15px;
            font-weight: 600;
            text-align: center;
            color: #6b4ce6;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #4a4a4a;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .control-group input[type="number"] {
            width: 70px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            color: #1a1a1a;
            padding: 4px 8px;
        }
        /* Journey editor */
        #edit-toggle {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 30;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            border-radius: 50%;
            width: 54px;
            height: 54px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        #edit-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.16);
        }
        #edit-toggle.active {
            background: #6b4ce6;
            color: white;
        }
        #edit-toggle .toggle-icon {
            transition: transform 0.2s ease;
        }
        #edit-toggle.active .toggle-icon {
            transform: rotate(90deg);
        }
        #journey-editor {
            position: absolute;
            right: 30px;
            bottom: 100px;
            width: 320px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 16px;
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.18);
            padding: 18px;
            box-sizing: border-box;
            z-index: 25;
            display: none;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        #journey-editor.visible {
            display: block;
        }
        #journey-editor h4 {
            margin: 0 0 12px 0;
            font-size: 15px;
            font-weight: 700;
            letter-spacing: -0.01em;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .editor-field {
            margin-bottom: 10px;
        }
        .editor-field label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            font-weight: 600;
            color: #4a4a4a;
            margin-bottom: 6px;
        }
        .editor-field input,
        .editor-field select,
        .editor-field textarea {
            width: 100%;
            box-sizing: border-box;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
            background: #f8fafc;
            padding: 9px 10px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            color: #0f172a;
        }
        .editor-field textarea {
            resize: vertical;
            min-height: 60px;
        }
        .editor-actions {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .editor-actions button {
            padding: 10px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.2s ease;
        }
        .editor-actions button.primary {
            background: #6b4ce6;
            color: white;
            box-shadow: 0 8px 20px rgba(107, 76, 230, 0.28);
        }
        .editor-actions button.secondary {
            background: #eef2ff;
            color: #312e81;
        }
        .editor-actions button.danger {
            background: #fee2e2;
            color: #b91c1c;
        }
        .editor-actions button:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 26px rgba(0, 0, 0, 0.12);
        }
        .editor-hint {
            margin-top: 8px;
            font-size: 12px;
            color: #475569;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .editor-hint .material-symbols-outlined {
            font-size: 16px;
        }
        body.edit-mode #journey-editor {
            display: block;
        }

        /* Label Admin Mode */
        #label-admin-panel {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
            padding: 24px;
            width: 320px;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            display: none;
            z-index: 900;
        }
        body.label-admin-mode #label-admin-panel {
            display: block;
        }
        #label-admin-panel h4 {
            margin: 0 0 20px 0;
            font-size: 15px;
            font-weight: 600;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .label-field {
            margin-bottom: 16px;
        }
        .label-field label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #64748b;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .label-field input,
        .label-field select {
            width: 100%;
            padding: 10px 12px;
            border: 1.5px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s;
            box-sizing: border-box;
        }
        .label-field input:focus,
        .label-field select:focus {
            outline: none;
            border-color: #6b4ce6;
            box-shadow: 0 0 0 3px rgba(107, 76, 230, 0.1);
        }
        .label-actions {
            display: flex;
            gap: 8px;
            margin-top: 20px;
        }
        .label-actions button {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .label-actions button.primary {
            background: #6b4ce6;
            color: white;
        }
        .label-actions button.secondary {
            background: #e0e7ff;
            color: #312e81;
        }
        .label-actions button.danger {
            background: #fee2e2;
            color: #b91c1c;
        }
        .label-actions button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .label-hint {
            margin-top: 12px;
            font-size: 11px;
            color: #64748b;
            padding: 8px 12px;
            background: #f8fafc;
            border-radius: 6px;
        }
        .map-label {
            pointer-events: all;
            cursor: pointer;
            user-select: none;
            color: white;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            transition: color 0.2s;
        }
        body.label-admin-mode .map-label {
            border: 1px dashed #6b4ce6;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.7);
            cursor: grab !important;
        }
        body.label-admin-mode .map-label:hover {
            background: rgba(107, 76, 230, 0.1);
            border-color: #4c3cc0;
        }
        body.label-admin-mode .map-label:active {
            cursor: grabbing !important;
        }
        /* Wave Path Editor Styles */
        #wave-path-toggle {
            position: absolute;
            bottom: 100px;
            right: 30px;
            z-index: 30;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            border-radius: 50%;
            width: 54px;
            height: 54px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        #wave-path-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.16);
        }
        #wave-path-toggle.active {
            background: #4a7c3f;
            color: white;
        }
        #wave-path-editor {
            position: absolute;
            right: 30px;
            bottom: 170px;
            width: 320px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 16px;
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.18);
            padding: 18px;
            box-sizing: border-box;
            z-index: 25;
            display: none;
            border: 1px solid rgba(0, 0, 0, 0.05);
            max-height: 60vh;
            overflow-y: auto;
        }
        #wave-path-editor.visible {
            display: block;
        }
        #wave-path-editor h4 {
            margin: 0 0 12px 0;
            font-size: 15px;
            font-weight: 700;
            letter-spacing: -0.01em;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .wave-control-group {
            margin-bottom: 12px;
        }
        .wave-control-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            font-weight: 600;
            color: #4a4a4a;
            margin-bottom: 6px;
        }
        .wave-control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
        }
        .wave-control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a7c3f;
            cursor: pointer;
        }
        .wave-point-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 12px;
        }
        .wave-point-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .wave-point-item:last-child {
            border-bottom: none;
        }
        .wave-point-item:hover {
            background: #f8fafc;
        }
        .wave-point-item.selected {
            background: #e0f7fa;
        }
        .wave-point-item .point-coords {
            color: #64748b;
            font-family: monospace;
        }
        .wave-point-item .point-actions {
            display: flex;
            gap: 4px;
        }
        .wave-point-item .point-actions button {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .wave-point-item .point-actions .delete-btn {
            background: #fee2e2;
            color: #b91c1c;
        }
        .wave-point-item .point-actions .delete-btn:hover {
            background: #fecaca;
        }
        .wave-editor-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 12px;
        }
        .wave-editor-actions button {
            padding: 10px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.2s ease;
        }
        .wave-editor-actions button.primary {
            background: #4a7c3f;
            color: white;
            box-shadow: 0 8px 20px rgba(74, 124, 63, 0.28);
        }
        .wave-editor-actions button.secondary {
            background: #e8f5e9;
            color: #2e5a27;
        }
        .wave-editor-actions button:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 26px rgba(0, 0, 0, 0.12);
        }
        .wave-path-control-point {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #4a7c3f;
            border: 3px solid white;
            border-radius: 50%;
            cursor: grab;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 50;
            transition: transform 0.1s, background 0.2s;
        }
        .wave-path-control-point:hover {
            transform: translate(-50%, -50%) scale(1.3);
            background: #3d6934;
        }
        .wave-path-control-point.dragging {
            cursor: grabbing;
            background: #2e5a27;
        }
        .wave-path-control-point.selected {
            background: #ff5722;
            transform: translate(-50%, -50%) scale(1.4);
        }
    </style>
</head>
<body>
    <div id="info">
        <img src="junk-logo.png" alt="JUNK">
    </div>
    <div id="loading">Loading...</div>

    <!-- Journey Navigation (Left Side) -->
    <nav id="journey-nav">
        <!-- All Journeys Button -->
        <div id="journey-overview" onclick="showFullJourney()">
            <div class="overview-dots">
                <div class="mini-dot" style="background: #5CCBD4;"></div>
                <div class="mini-dot" style="background: #F4D35E;"></div>
                <div class="mini-dot" style="background: #A64D79;"></div>
                <div class="mini-dot" style="background: #4A8EC2;"></div>
                <div class="mini-dot" style="background: #6B4CE6;"></div>
                <div class="mini-dot" style="background: #F4C2C2;"></div>
                <div class="mini-dot" style="background: #5ABF8C;"></div>
                <div class="mini-dot" style="background: #C855D8;"></div>
            </div>
        </div>
        <div class="journey-nav-item" data-person="ziyi" onclick="selectPerson('ziyi')">
            <div class="nav-dot" style="background: #C855D8;"></div>
            <span class="nav-name">ZIYI</span>
        </div>
        <div class="journey-nav-item" data-person="steven" onclick="selectPerson('steven')">
            <div class="nav-dot" style="background: #4A8EC2;"></div>
            <span class="nav-name">STEVEN</span>
        </div>
        <div class="journey-nav-item" data-person="yuzie" onclick="selectPerson('yuzie')">
            <div class="nav-dot" style="background: #5ABF8C;"></div>
            <span class="nav-name">YUZIE</span>
        </div>
        <div class="journey-nav-item" data-person="lilleth" onclick="selectPerson('lilleth')">
            <div class="nav-dot" style="background: #A64D79;"></div>
            <span class="nav-name">LILLETH</span>
        </div>
        <div class="journey-nav-item" data-person="jonny" onclick="selectPerson('jonny')">
            <div class="nav-dot" style="background: #F4D35E;"></div>
            <span class="nav-name">JONNY</span>
        </div>
        <div class="journey-nav-item" data-person="isabel" onclick="selectPerson('isabel')">
            <div class="nav-dot" style="background: #5CCBD4;"></div>
            <span class="nav-name">ISABEL</span>
        </div>
        <div class="journey-nav-item" data-person="xiao" onclick="selectPerson('xiao')">
            <div class="nav-dot" style="background: #F4C2C2;"></div>
            <span class="nav-name">XIAO</span>
        </div>
        <div class="journey-nav-item" data-person="tiger" onclick="selectPerson('tiger')">
            <div class="nav-dot" style="background: #6B4CE6;"></div>
            <span class="nav-name">TIGER</span>
        </div>
    </nav>

    <!-- Top Navigation (Right Side) -->
    <nav id="top-nav">
        <div class="journey-nav-item selected" id="overview-btn" onclick="showOverview()">
            <div class="nav-dot" style="background: #888;"></div>
            <span class="nav-name">OVERVIEW</span>
        </div>
        <a href="Artifact/Artifact.html" class="journey-nav-item" id="artifact-btn" style="text-decoration: none; color: inherit;">
            <div class="nav-dot" style="background: #d4af37;"></div>
            <span class="nav-name">ARTIFACTS</span>
        </a>
        <a href="INTRO/INTRO.html" class="journey-nav-item" id="about-btn" style="text-decoration: none; color: inherit;">
            <div class="nav-dot" style="background: #888;"></div>
            <span class="nav-name">ABOUT</span>
        </a>
    </nav>

    <!-- Centered Site Title -->
    <div id="centered-title">ARCHIPELAGO</div>

    <div id="edit-toggle" title="Toggle edit mode" onclick="toggleEditMode()">
        <span class="material-symbols-outlined toggle-icon" data-state="off">edit</span>
    </div>

    <!-- Wave Path Editor Toggle -->
    <div id="wave-path-toggle" title="Toggle wave path editor" onclick="toggleWavePathEditor()">
        <span class="material-symbols-outlined">waves</span>
    </div>

    <!-- Wave Path Editor Panel -->
    <div id="wave-path-editor">
        <h4>
            <span class="material-symbols-outlined">waves</span>
            Wave Path Editor
        </h4>
        <div class="wave-control-group">
            <label>Wave Height <span id="wave-height-value">1</span></label>
            <input type="range" id="wave-height-slider" min="0.5" max="10" value="1" step="0.5" oninput="updateWaveSettings()">
        </div>
        <div class="wave-control-group">
            <label>Wave Speed <span id="wave-speed-value">0.5</span></label>
            <input type="range" id="wave-speed-slider" min="0.1" max="5" value="0.5" step="0.1" oninput="updateWaveSettings()">
        </div>
        <div class="wave-control-group">
            <label>Noise Amount <span id="wave-noise-value">4</span></label>
            <input type="range" id="wave-noise-slider" min="0" max="10" value="4" step="0.5" oninput="updateWaveSettings()">
        </div>
        <div class="wave-control-group">
            <label>Path Width <span id="wave-width-value">2</span></label>
            <input type="range" id="wave-width-slider" min="1" max="20" value="2" step="1" oninput="updateWaveSettings()">
        </div>
        <div class="wave-control-group">
            <label>Hover Height <span id="wave-hover-value">2.5</span></label>
            <input type="range" id="wave-hover-slider" min="0.5" max="15" value="2.5" step="0.5" oninput="updateWaveSettings()">
        </div>
        <div class="wave-control-group">
            <label>Control Points</label>
            <div class="wave-point-list" id="wave-point-list">
                <!-- Points will be populated dynamically -->
            </div>
        </div>
        <div class="wave-editor-actions">
            <button class="secondary" onclick="addWaveControlPoint()">Add Point</button>
            <button class="secondary" onclick="resetWavePath()">Reset Path</button>
            <button class="primary" onclick="toggleWavePathVisible()">Toggle Wave</button>
            <button class="secondary" onclick="exportWavePath()">Export</button>
        </div>
    </div>

    <div id="journey-editor">
        <h4>
            <span class="material-symbols-outlined">edit_square</span>
            Journey Editor
        </h4>
        <div class="editor-field">
            <label>Person <span id="editor-point-id"></span></label>
            <div id="editor-person-name" style="font-weight:700;color:#1a1a1a;font-size:13px;"></div>
        </div>
        <div class="editor-field">
            <label>Point</label>
            <select id="editor-point-select"></select>
        </div>
        <div class="editor-field">
            <label>Order</label>
            <input type="number" id="editor-order" min="1" step="1" value="1">
        </div>
        <div class="editor-field">
            <label>Name</label>
            <input type="text" id="editor-name" placeholder="Location name">
        </div>
        <div class="editor-field">
            <label>Icon</label>
            <input type="text" id="editor-icon" placeholder="Material icon name">
        </div>
        <div class="editor-field">
            <label>Asset Link <span style="font-weight:500;font-size:11px;color:#6b4ce6;">(imgur image or vimeo link)</span></label>
            <input type="text" id="editor-media" placeholder="https://...">
        </div>
        <div class="editor-field">
            <label>Media Type</label>
            <select id="editor-media-type">
                <option value="">Auto</option>
                <option value="image">Image</option>
                <option value="video">Video</option>
            </select>
        </div>
        <div class="editor-field">
            <label>Description</label>
            <textarea id="editor-description" placeholder="What is this point?"></textarea>
        </div>
        <div class="editor-actions">
            <button class="secondary" id="editor-new">New Point</button>
            <button class="primary" id="editor-save">Save Point</button>
            <button class="danger" id="editor-delete">Delete</button>
        </div>
        <div class="editor-hint">
            <span class="material-symbols-outlined">pan_tool_alt</span>
            Drag markers on the map while edit mode is on.
        </div>
    </div>

    <!-- Label Admin Panel -->
    <div id="label-admin-panel">
        <h4>
            <span class="material-symbols-outlined">text_fields</span>
            Map Label Editor
        </h4>
        <div class="label-field">
            <label>Label Text</label>
            <input type="text" id="label-text" placeholder="Enter label text">
        </div>
        <div class="label-field">
            <label>Font Size</label>
            <select id="label-size">
                <option value="12">Small (12px)</option>
                <option value="14">Normal (14px)</option>
                <option value="16" selected>Medium (16px)</option>
                <option value="20">Large (20px)</option>
                <option value="24">Extra Large (24px)</option>
                <option value="32">Huge (32px)</option>
                <option value="48">Giant (48px)</option>
            </select>
        </div>
        <div class="label-field">
            <label>Color</label>
            <input type="color" id="label-color" value="#ffffff">
        </div>
        <div class="label-actions">
            <button class="primary" id="add-label">Add Label</button>
            <button class="danger" id="delete-label">Delete Selected</button>
        </div>
        <div class="label-hint">
            <strong>Ctrl+Shift+X</strong> to toggle label mode<br>
            Click terrain to place labels<br>
            Drag labels to reposition them<br>
            Click to select, then delete
        </div>
    </div>

    <div id="notification">
        <div class="icon">✓</div>
        <div class="message">Saved successfully!</div>
    </div>

    <div id="controls">
        <h3>CAMERA CONTROLS</h3>
        <div class="control-group">
            <label>FOV: <span id="fov-value">30</span></label>
            <input type="range" id="fov" min="30" max="120" value="30" step="1">
        </div>
        <div class="control-group">
            <label>Position Y: <span id="pos-y-value">260</span></label>
            <input type="range" id="pos-y" min="10" max="320" value="260" step="1">
        </div>
        <div class="control-group">
            <label>Position X: <span id="pos-x-value">80</span></label>
            <input type="range" id="pos-x" min="-200" max="200" value="80" step="1">
        </div>
        <div class="control-group">
            <label>Position Z: <span id="pos-z-value">80</span></label>
            <input type="range" id="pos-z" min="-200" max="200" value="80" step="1">
        </div>
        <div class="control-group">
            <label>Height Scale: <span id="height-value">7</span></label>
            <input type="range" id="height-scale" min="5" max="100" value="7" step="1">
        </div>
        <div class="control-group">
            <label>Sea Threshold: <span id="sea-threshold-value">0.07</span></label>
            <input type="range" id="sea-threshold" min="0" max="0.5" value="0.07" step="0.01">
            <input type="number" id="sea-threshold-input" min="0" max="0.5" value="0.07" step="0.001">
        </div>
        <div class="control-group">
            <label>Sea Level Height: <span id="sea-height-value">1.00</span></label>
            <input type="range" id="sea-height" min="0.1" max="10" value="1.0" step="0.01">
            <input type="number" id="sea-height-input" min="0.1" max="10" value="1.0" step="0.01">
        </div>
        <div class="control-group">
            <label>Material Rotation: <span id="mat-rotation-value">180</span>°</label>
            <input type="range" id="mat-rotation" min="-180" max="180" value="180" step="1">
        </div>
        <div class="control-group">
            <label>Height Map Rotation: <span id="height-rotation-value">-180</span>°</label>
            <input type="range" id="height-rotation" min="-180" max="180" value="-180" step="1">
        </div>
        <div class="control-group">
            <label><input type="checkbox" id="height-flip-u" checked> Flip Height U</label>
            <label style="margin-left:10px;"><input type="checkbox" id="height-flip-v"> Flip Height V</label>
        </div>
        <div class="control-group">
            <label><input type="checkbox" id="mat-flip-u"> Flip U</label>
            <label style="margin-left:10px;"><input type="checkbox" id="mat-flip-v" checked> Flip V</label>
        </div>
    </div>

    <!-- Journey Media Popup - Fullscreen Gallery -->
    <div id="media-popup">
        <button class="gallery-close" onclick="closeMediaPopup()">×</button>
        <button class="gallery-nav gallery-prev" onclick="navigateJourney(-1)">‹</button>
        <button class="gallery-nav gallery-next" onclick="navigateJourney(1)">›</button>
        <div class="gallery-content">
            <div class="gallery-media" id="media-placeholder">
                <span class="material-symbols-outlined">image</span>
            </div>
            <div class="gallery-info">
                <h2 id="media-title">Location Title</h2>
                <p id="media-description">Description of this journey location.</p>
            </div>
        </div>
        <div class="gallery-dots" id="gallery-dots"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // JSONBin configuration
        const JSONBIN_BIN_ID = '68e0256043b1c97be95965b9';
        const JSONBIN_API_KEY = '$2a$10$IcHy/if.465WYHfVCaX0WOrS.zvgk8DinfdOFdHuUoCZLt7YTP4RS';
        const JSONBIN_URL = `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`;

        let scene, camera, renderer, controls, labelRenderer;
        let terrainMesh;
        let animationStartTime = 0;
        let cameraMixer = null;
        let cameraAction = null;
        let cameraIntroPlaying = false;
        let posXSlider = null;
        let posXValueDisplay = null;
        let posYSlider = null;
        let posYValueDisplay = null;
        // Mouse interaction
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let mouseDownPos = new THREE.Vector2();
        let isDragging = false;
        let lastJourneySaveTime = 0;
        let editMode = false;
        let editingPoint = null;
        let editedPersons = new Set(); // Track which persons have been edited this session

        // Only allow one edited person at a time
        function markPersonEdited(person) {
            editedPersons.clear();
            if (person) {
                editedPersons.add(person);
            }
        }
        let draggingJourneyMarker = null;
        // Mobile detection
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        // Post-processing
        let composer;
        // Material map data for land coloring
        let matImageData = null;
        let matW = 0;
        let matH = 0;
        let flipMaterialU = true;  // allow horizontal flip
        let flipMaterialV = true;  // vertical flip (image origin alignment)
        let matRotationDeg = 180; // rotation around material center (default sweet spot)
        let heightRotationDeg = -180; // rotation for heightmap
        let flipHeightU = true; // flip heightmap horizontally
        let flipHeightV = false; // flip heightmap vertically
        let heightImageData = null; // store heightmap data for reapplying rotation
        let heightW = 0;
        let heightH = 0;
        const clock = new THREE.Clock();
        let heightScale = 7;
        const gridGap = 1.0;
        const sampleRate = 4; // Sample every Nth pixel (128x128 = 16k instances)
        let seaThreshold = 0.15; // Grayscale cutoff: <= is ocean (extended ocean)
        let seaFlatHeight = 1.0; // Flat column height for ocean

        const cameraStartPos = { x: 0, y: 260, z: 0.1 };
        const cameraEndPos = { x: 0, y: 200, z: 0.1 };

        // Person colors matching the navigation
        const personColors = {
            isabel: 0x5CCBD4,
            ziyi: 0xC855D8,
            steven: 0x4A8EC2,
            tiger: 0x6B4CE6,
            xiao: 0xF4C2C2,
            lilleth: 0xA64D79,
            lillith: 0xA64D79,  // Alias for old spelling
            yuzie: 0x5ABF8C,
            jonny: 0xF4D35E
        };

        // ============== WAVE PATH SYSTEM ==============
        let wavePathEditorVisible = false;
        let wavePathMesh = null;
        let wavePathVisible = true;
        let wavePathControlPointElements = [];
        let selectedWavePointIndex = -1;
        let draggingWavePoint = null;

        // Wave path settings (algae ring)
        let waveSettings = {
            height: 1,
            speed: 0.5,
            noiseAmount: 4,
            pathWidth: 2,
            hoverHeight: 2.5
        };

        // Default control points forming a closed loop around the island (algae ring)
        let wavePathControlPoints = [
            { x: -25.71291794965777, z: -29.217843410809053 },
            { x: -4.282529178462653, z: -46.740537308281745 },
            { x: 36.92184505219151, z: -50.99121812585662 },
            { x: 49.98813535975319, z: -15.519247201427703 },
            { x: 26.271187494134324, z: 21.400622967905292 },
            { x: 13.552623641194018, z: 53.91585522253054 },
            { x: -42.74747143324832, z: 51.24958472116657 },
            { x: -42.57115618373139, z: 14.233393590631863 },
            { x: -50.86222231758773, z: -22.849058854811517 }
        ];

        // Simplex noise implementation for wave effect
        const simplexNoise = (function() {
            const F2 = 0.5 * (Math.sqrt(3) - 1);
            const G2 = (3 - Math.sqrt(3)) / 6;
            const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
            const perm = new Array(512);
            const p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
            for (let i = 0; i < 512; i++) perm[i] = p[i & 255];

            function dot2(g, x, y) { return g[0]*x + g[1]*y; }

            return function(xin, yin) {
                let n0, n1, n2;
                const s = (xin + yin) * F2;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);
                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = xin - X0;
                const y0 = yin - Y0;
                let i1, j1;
                if (x0 > y0) { i1 = 1; j1 = 0; }
                else { i1 = 0; j1 = 1; }
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;
                const ii = i & 255;
                const jj = j & 255;
                const gi0 = perm[ii + perm[jj]] % 12;
                const gi1 = perm[ii + i1 + perm[jj + j1]] % 12;
                const gi2 = perm[ii + 1 + perm[jj + 1]] % 12;
                let t0 = 0.5 - x0*x0 - y0*y0;
                if (t0 < 0) n0 = 0.0;
                else { t0 *= t0; n0 = t0 * t0 * dot2(grad3[gi0], x0, y0); }
                let t1 = 0.5 - x1*x1 - y1*y1;
                if (t1 < 0) n1 = 0.0;
                else { t1 *= t1; n1 = t1 * t1 * dot2(grad3[gi1], x1, y1); }
                let t2 = 0.5 - x2*x2 - y2*y2;
                if (t2 < 0) n2 = 0.0;
                else { t2 *= t2; n2 = t2 * t2 * dot2(grad3[gi2], x2, y2); }
                return 70.0 * (n0 + n1 + n2);
            };
        })();

        // Empty default - all data comes from JSONBin only
        const defaultJourneys = {};

        const cloneJourneys = (source) => JSON.parse(JSON.stringify(source));

        // Active journey data (mutable and synced to JSONBin)
        let allJourneys = cloneJourneys(defaultJourneys);

        const navPersonOrder = ['ziyi','steven','yuzie','lilleth','jonny','isabel','xiao','tiger'];
        const getSortedPeople = () => {
            const existing = Object.keys(allJourneys);
            const ordered = navPersonOrder.filter(p => existing.includes(p));
            const extras = existing.filter(p => !navPersonOrder.includes(p)).sort((a, b) => a.localeCompare(b));
            return [...ordered, ...extras];
        };

        const detectMediaType = (link = '') => {
            let lower = (link || '').toLowerCase().trim();
            if (!lower) return '';
            if (lower.startsWith('%3cblockquote') || lower.includes('<blockquote')) return ''; // treat old embed snippets as invalid
            if (lower.includes('<iframe') || lower.includes('<div')) return 'embed';
            if (lower.includes('player.vimeo.com/external')) {
                if (lower.endsWith('.m3u8') || lower.includes('.m3u8')) return 'hls';
                if (lower.endsWith('.mp4') || lower.includes('.mp4')) return 'video';
            }
            if (lower.endsWith('.m3u8') || lower.includes('.m3u8')) return 'hls';
            if (lower.includes('vimeo.com')) return 'vimeo';
            if (lower.includes('youtube.com') || lower.includes('youtu.be') || lower.endsWith('.mp4') || lower.endsWith('.webm')) return 'video';
            return 'image';
        };

        function getVimeoId(url = '') {
            // Matches vimeo.com/{id} or vimeo.com/.../{id}
            const match = url.match(/vimeo\.com\/(?:video\/)?(\d+)/i);
            return match ? match[1] : '';
        }

        function normalizeJourneyPoint(stop, index, person) {
            const point = stop;
            delete point.y; // remove transient render data
            delete point.color;
            point.person = person;
            const orderValue = point.order !== undefined ? point.order : (point.id !== undefined ? point.id : index + 1);
            point.order = parseInt(orderValue, 10) || index + 1;
            point.id = point.order;
            const detectedType = point.media ? detectMediaType(point.media) : '';
            if (detectedType) {
                point.mediaType = detectedType;
            } else if (point.media) {
                // If it's an old embed snippet, clear it so it doesn't try to load
                point.media = '';
                point.mediaType = '';
            }
            return point;
        }

        function normalizeJourneyData(data) {
            const safeData = data && Object.keys(data).length > 0 ? cloneJourneys(data) : cloneJourneys(defaultJourneys);

            // Migrate old spelling: lillith -> lilleth
            if (safeData.lillith && !safeData.lilleth) {
                safeData.lilleth = safeData.lillith;
                delete safeData.lillith;
            } else if (safeData.lillith && safeData.lilleth) {
                // Merge if both exist (lilleth takes priority, but add any unique lillith points)
                delete safeData.lillith;
            }

            Object.keys(safeData).forEach(person => {
                safeData[person] = (safeData[person] || []).map((stop, idx) => normalizeJourneyPoint(stop, idx, person === 'lillith' ? 'lilleth' : person));
            });
            return safeData;
        }

        function hexToRgba(hex, alpha = 1) {
            const color = new THREE.Color(hex);
            const r = Math.round(color.r * 255);
            const g = Math.round(color.g * 255);
            const b = Math.round(color.b * 255);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function buildJourneyPoints(selection = 'all') {
            const people = selection === 'all' ? getSortedPeople() : [selection];
            const combined = [];

            people.forEach((person) => {
                const stops = (allJourneys[person] || []).slice().sort((a, b) => (a.order ?? a.id ?? 0) - (b.order ?? b.id ?? 0));
                stops.forEach((stop, idx) => {
                    combined.push(normalizeJourneyPoint(stop, idx, person));
                });
            });

            return combined;
        }

        function renumberPersonJourneys(person) {
            const list = allJourneys[person] || [];
            list.sort((a, b) => (a.order ?? a.id ?? 0) - (b.order ?? b.id ?? 0));
            list.forEach((pt, idx) => {
                pt.order = idx + 1;
                pt.id = pt.order;
            });
        }

        function rebuildJourneySystem() {
            if (!heightImageData || !journeysVisible) return;
            journeyPoints = buildJourneyPoints(selectedPersonName);
            clearJourneySystem();
            createJourneySystem(heightImageData, heightW, heightH);
        }

        function populateEditorFields(point) {
            const orderInput = document.getElementById('editor-order');
            const nameInput = document.getElementById('editor-name');
            const iconInput = document.getElementById('editor-icon');
            const mediaInput = document.getElementById('editor-media');
            const mediaTypeSelect = document.getElementById('editor-media-type');
            const descriptionInput = document.getElementById('editor-description');
            const idBadge = document.getElementById('editor-point-id');
            const personName = document.getElementById('editor-person-name');
            const pointSelect = document.getElementById('editor-point-select');

            const personToShow = (point && point.person) || (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]);
            personName.textContent = personToShow ? personToShow.toUpperCase() : '';

            // Update point selector options
            updatePointSelectOptions(point);

            if (!point) {
                orderInput.value = 1;
                nameInput.value = '';
                iconInput.value = '';
                mediaInput.value = '';
                mediaTypeSelect.value = '';
                descriptionInput.value = '';
                idBadge.textContent = '';
                return;
            }

            orderInput.value = point.order || point.id || 1;
            nameInput.value = point.name || '';
            iconInput.value = point.icon || '';
            mediaInput.value = point.media || '';
            mediaTypeSelect.value = point.mediaType || '';
            descriptionInput.value = point.description || '';
            idBadge.textContent = `#${point.order || point.id || ''}`;
        }

        function setEditingPoint(point) {
            editingPoint = point || null;
            populateEditorFields(point || null);
            updatePointSelectOptions(point || null);
        }

        function updatePointSelectOptions(currentPoint = null) {
            const select = document.getElementById('editor-point-select');
            if (!select) return;

            const person = (currentPoint && currentPoint.person) || (editingPoint && editingPoint.person) || (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]);
            const list = (allJourneys[person] || []).slice().sort((a, b) => (a.order ?? a.id ?? 0) - (b.order ?? b.id ?? 0));

            select.innerHTML = '';
            if (!list.length) {
                select.disabled = true;
                const opt = document.createElement('option');
                opt.textContent = 'No points';
                opt.value = '';
                select.appendChild(opt);
                return;
            }

            select.disabled = false;
            list.forEach(pt => {
                const opt = document.createElement('option');
                opt.value = pt.order;
                opt.textContent = `${pt.order} — ${pt.name || 'Untitled'}`;
                select.appendChild(opt);
            });

            const targetOrder = currentPoint?.order || (editingPoint?.order) || list[0].order;
            select.value = targetOrder;
        }

        function createNewJourneyPoint() {
            const targetPerson = (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]) || 'xiao';
            allJourneys[targetPerson] = allJourneys[targetPerson] || [];
            const nextOrder = (allJourneys[targetPerson].length || 0) + 1;
            const newPoint = {
                id: nextOrder,
                order: nextOrder,
                name: 'New Point',
                icon: 'location_on',
                x: 0,
                z: 0,
                description: '',
                person: targetPerson
            };
            allJourneys[targetPerson].push(newPoint);
            renumberPersonJourneys(targetPerson);
            setEditingPoint(newPoint);
            journeysVisible = true;
            selectedPersonName = targetPerson;
            markPersonEdited(targetPerson);
            setJourneySelection(targetPerson);
        }

        function applyEditorChanges() {
            if (!editingPoint) return;

            const orderInput = document.getElementById('editor-order');
            const nameInput = document.getElementById('editor-name');
            const iconInput = document.getElementById('editor-icon');
            const mediaInput = document.getElementById('editor-media');
            const mediaTypeSelect = document.getElementById('editor-media-type');
            const descriptionInput = document.getElementById('editor-description');

            const targetPerson = editingPoint.person || (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]);
            const newOrder = parseInt(orderInput.value, 10) || 1;
            const targetListOld = allJourneys[editingPoint.person] || [];

            // Move to new person list if needed
            editingPoint.person = targetPerson;
            editingPoint.order = newOrder;
            editingPoint.id = newOrder;
            editingPoint.name = nameInput.value.trim();
            editingPoint.icon = iconInput.value.trim();
            editingPoint.media = mediaInput.value.trim();
            editingPoint.mediaType = mediaTypeSelect.value || detectMediaType(editingPoint.media);
            editingPoint.description = descriptionInput.value.trim();

            renumberPersonJourneys(targetPerson);
            setJourneySelection(targetPerson);
            markPersonEdited(targetPerson);
            lastJourneySaveTime = Date.now();
        }

        function deleteEditingPoint() {
            if (!editingPoint) return;
            const person = editingPoint.person;
            const list = allJourneys[person] || [];
            const idx = list.indexOf(editingPoint);
            if (idx >= 0) {
                list.splice(idx, 1);
            }
            renumberPersonJourneys(person);
            markPersonEdited(person);
            const nextPoint = (allJourneys[person] || [])[0] || null;
            editingPoint = null;
            populateEditorFields(nextPoint);
            if (nextPoint) {
                setEditingPoint(nextPoint);
            }
            rebuildJourneySystem();
        }

        function setupEditorUI() {
            document.getElementById('editor-save').addEventListener('click', () => {
                applyEditorChanges();
                rebuildJourneySystem();
                saveJourneysToBin();
            });
            document.getElementById('editor-new').addEventListener('click', () => {
                createNewJourneyPoint();
                rebuildJourneySystem();
            });
            document.getElementById('editor-delete').addEventListener('click', () => {
                deleteEditingPoint();
                saveJourneysToBin();
            });
            const pointSelect = document.getElementById('editor-point-select');
            if (pointSelect) {
                pointSelect.addEventListener('change', (e) => {
                    const person = (editingPoint && editingPoint.person) || (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]);
                    const order = parseInt(e.target.value, 10);
                    const point = (allJourneys[person] || []).find(pt => pt.order === order);
                    if (point) {
                        setEditingPoint(point);
                    }
                });
            }
        }

        window.toggleEditMode = function(force) {
            editMode = typeof force === 'boolean' ? force : !editMode;
            const editor = document.getElementById('journey-editor');
            const toggleBtn = document.getElementById('edit-toggle');
            const toggleIcon = toggleBtn?.querySelector('.toggle-icon');
            document.body.classList.toggle('edit-mode', editMode);
            editor?.classList.toggle('visible', editMode);
            toggleBtn?.classList.toggle('active', editMode);
            if (toggleIcon) {
                toggleIcon.textContent = editMode ? 'close' : 'edit';
            }

            // Keep journeys visible while editing
            if (editMode) {
                journeysVisible = true;
                const defaultPerson = editingPoint?.person || (selectedPersonName !== 'all' ? selectedPersonName : getSortedPeople()[0]);
                const targetPerson = defaultPerson || getSortedPeople()[0];
                selectedPersonName = targetPerson;
                setJourneySelection(targetPerson);
                controls.enabled = false;
                if (!editingPoint && journeyPoints.length > 0) {
                    setEditingPoint(journeyPoints[0]);
                }
            } else {
                controls.enabled = true;
                draggingJourneyMarker = null;
            }
        };

        // Currently active journey points (changes based on selection)
        let journeyPoints = [];
        let currentPerson = null;
        let selectedPersonName = 'all';
        let journeysVisible = false; // Start with journeys hidden

        // Journey system variables
        let journeyMarkers = [];
        let journeyLines = [];
        let selectedJourneyPoint = null;
        let journeyTransitioning = false;
        let journeyTransitionProgress = 0;
        let journeySavedCameraPos = null;
        let journeySavedTarget = null;
        let currentJourneyIndex = 0;

        // Label Admin Mode variables
        let labelAdminMode = false;
        let mapLabels = [];
        let label3DObjects = []; // Three.js CSS2DObjects
        let selectedLabel = null;
        let draggingLabel = null;
        let isDraggingLabel = false;

        // Load labels from JSONBin
        async function loadLabels() {
            try {
                const response = await fetch(`${JSONBIN_URL}/latest`, {
                    method: 'GET',
                    headers: {
                        'X-Master-Key': JSONBIN_API_KEY
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    const data = result.record;

                    if (data && data.mapLabels && Array.isArray(data.mapLabels)) {
                        mapLabels = data.mapLabels;
                        mapLabels.forEach(label => create3DLabel(label));
                        console.log('Loaded labels from JSONBin:', mapLabels.length);
                    }
                }
            } catch (e) {
                console.error('Error loading labels from JSONBin:', e);
            }
        }

        // Save labels to JSONBin
        async function saveLabels() {
            try {
                // Fetch latest data to preserve journeys
                const getResponse = await fetch(`${JSONBIN_URL}/latest`, {
                    method: 'GET',
                    headers: {
                        'X-Master-Key': JSONBIN_API_KEY
                    }
                });

                let existingData = {};
                if (getResponse.ok) {
                    const result = await getResponse.json();
                    existingData = result.record || {};
                }

                // Update labels while preserving other data
                const dataToSave = {
                    ...existingData,
                    mapLabels: mapLabels.map(l => ({
                        id: l.id,
                        text: l.text,
                        worldX: l.worldX,
                        worldY: l.worldY,
                        worldZ: l.worldZ,
                        size: l.size,
                        color: l.color
                    })),
                    labelsLastModified: new Date().toISOString()
                };

                const response = await fetch(JSONBIN_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': JSONBIN_API_KEY
                    },
                    body: JSON.stringify(dataToSave)
                });

                if (response.ok) {
                    console.log('Labels saved to JSONBin');
                } else {
                    console.error('Failed to save labels:', response.status);
                }
            } catch (e) {
                console.error('Error saving labels to JSONBin:', e);
            }
        }

        // Toggle label admin mode with Ctrl+Shift+X
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'X') {
                e.preventDefault();
                labelAdminMode = !labelAdminMode;
                document.body.classList.toggle('label-admin-mode', labelAdminMode);

                if (labelAdminMode) {
                    showNotification({ message: 'Label Admin Mode Enabled', type: 'success' });
                } else {
                    showNotification({ message: 'Label Admin Mode Disabled', type: 'success' });
                    selectedLabel = null;
                    // Remove selection highlight
                    label3DObjects.forEach(obj => {
                        obj.element.style.outline = '';
                    });
                }
            }
        });

        // Create 3D label attached to terrain
        function create3DLabel(labelData) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'map-label';
            labelDiv.textContent = labelData.text;
            labelDiv.style.fontSize = labelData.size + 'px';
            labelDiv.style.color = '#ffffff';
            labelDiv.dataset.labelId = labelData.id;

            // Make clickable and draggable in admin mode
            labelDiv.addEventListener('mousedown', (e) => {
                if (!labelAdminMode) return;
                e.stopPropagation();
                e.preventDefault();

                selectedLabel = labelData;
                draggingLabel = labelData;
                isDraggingLabel = true;

                // Disable camera controls while dragging
                controls.enabled = false;

                // Highlight selected
                label3DObjects.forEach(obj => {
                    obj.element.style.outline = '';
                });
                labelDiv.style.outline = '2px solid #6b4ce6';
                labelDiv.style.cursor = 'grabbing';
            });

            const label2D = new CSS2DObject(labelDiv);
            label2D.position.set(labelData.worldX, labelData.worldY, labelData.worldZ);
            label2D.userData.labelData = labelData;

            scene.add(label2D);
            label3DObjects.push(label2D);

            return label2D;
        }

        // Add label button
        document.getElementById('add-label').addEventListener('click', () => {
            const text = document.getElementById('label-text').value.trim();
            if (!text) {
                showNotification({ message: 'Please enter label text', type: 'error' });
                return;
            }

            const size = parseInt(document.getElementById('label-size').value);
            const color = document.getElementById('label-color').value;

            // Place at center of screen, raycast to find terrain position
            mouse.x = 0;
            mouse.y = 0;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(terrainMesh);

            if (intersects.length > 0) {
                const point = intersects[0].point;

                const label = {
                    id: Date.now(),
                    text: text,
                    worldX: point.x,
                    worldY: point.y + 2, // Slightly above terrain
                    worldZ: point.z,
                    size: size,
                    color: color
                };

                mapLabels.push(label);
                create3DLabel(label);
                saveLabels();

                document.getElementById('label-text').value = '';
                showNotification({ message: 'Label added to map', type: 'success' });
            } else {
                showNotification({ message: 'Could not find terrain position', type: 'error' });
            }
        });

        // Delete label button
        document.getElementById('delete-label').addEventListener('click', () => {
            if (!selectedLabel) {
                showNotification({ message: 'No label selected', type: 'error' });
                return;
            }

            // Remove from scene
            const labelObj = label3DObjects.find(obj => obj.userData.labelData.id === selectedLabel.id);
            if (labelObj) {
                scene.remove(labelObj);
                labelObj.element.remove();
            }

            // Remove from arrays
            label3DObjects = label3DObjects.filter(obj => obj.userData.labelData.id !== selectedLabel.id);
            mapLabels = mapLabels.filter(l => l.id !== selectedLabel.id);

            saveLabels();
            selectedLabel = null;
            showNotification({ message: 'Label deleted', type: 'success' });
        });

        // Setup label click handler - called after renderer is created
        function setupLabelClickHandler() {
            // Click to place new label
            renderer.domElement.addEventListener('click', (e) => {
                if (!labelAdminMode || isDraggingLabel) return;

                const text = document.getElementById('label-text').value.trim();
                if (!text) return;

                // Calculate mouse position in normalized device coordinates
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(terrainMesh);

                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const size = parseInt(document.getElementById('label-size').value);
                    const color = document.getElementById('label-color').value;

                    const label = {
                        id: Date.now(),
                        text: text,
                        worldX: point.x,
                        worldY: point.y + 2,
                        worldZ: point.z,
                        size: size,
                        color: color
                    };

                    mapLabels.push(label);
                    create3DLabel(label);
                    saveLabels();

                    document.getElementById('label-text').value = '';
                    showNotification({ message: 'Label placed on terrain', type: 'success' });
                }
            });

            // Mousemove for dragging labels
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!labelAdminMode || !isDraggingLabel || !draggingLabel) return;

                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(terrainMesh);

                if (intersects.length > 0) {
                    const point = intersects[0].point;

                    // Update label position
                    draggingLabel.worldX = point.x;
                    draggingLabel.worldY = point.y + 2;
                    draggingLabel.worldZ = point.z;

                    // Update 3D object position
                    const labelObj = label3DObjects.find(obj => obj.userData.labelData.id === draggingLabel.id);
                    if (labelObj) {
                        labelObj.position.set(point.x, point.y + 2, point.z);
                    }
                }
            });

            // Mouseup to stop dragging
            document.addEventListener('mouseup', (e) => {
                if (isDraggingLabel) {
                    isDraggingLabel = false;
                    controls.enabled = true;

                    // Reset cursor
                    const labelObj = label3DObjects.find(obj => obj.userData.labelData.id === draggingLabel?.id);
                    if (labelObj) {
                        labelObj.element.style.cursor = 'grab';
                    }

                    if (draggingLabel) {
                        saveLabels();
                        showNotification({ message: 'Label repositioned', type: 'success' });
                    }

                    draggingLabel = null;
                }
            });
        }

        // ============== WAVE PATH FUNCTIONS ==============

        // Create wave path mesh from control points
        function createWavePath() {
            if (!scene) return; // Scene not ready yet

            if (wavePathMesh) {
                scene.remove(wavePathMesh);
                wavePathMesh.geometry.dispose();
                wavePathMesh.material.dispose();
                wavePathMesh = null;
            }

            if (wavePathControlPoints.length < 3) return;

            // Create a closed catmull-rom curve from control points
            const points3D = wavePathControlPoints.map(p => new THREE.Vector3(p.x, 0, p.z));
            const curve = new THREE.CatmullRomCurve3(points3D, true, 'catmullrom', 0.5);

            // Sample points along the curve
            const numSegments = 500;

            // For a closed curve, sample points evenly using getPointAt for consistent spacing
            const curvePoints = [];
            for (let i = 0; i < numSegments; i++) {
                curvePoints.push(curve.getPointAt(i / numSegments));
            }

            // Create geometry for the wave ribbon
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            const uvs = [];

            const width = waveSettings.pathWidth;

            // Create vertices for closed loop
            for (let i = 0; i < numSegments; i++) {
                const point = curvePoints[i];
                const nextPoint = curvePoints[(i + 1) % numSegments];
                const prevPoint = curvePoints[(i - 1 + numSegments) % numSegments];

                // Calculate smooth direction using previous and next points
                const dir = new THREE.Vector3().subVectors(nextPoint, prevPoint).normalize();
                const perp = new THREE.Vector3(-dir.z, 0, dir.x);

                // Create two vertices (inner and outer edge)
                const inner = new THREE.Vector3().copy(point).addScaledVector(perp, -width / 2);
                const outer = new THREE.Vector3().copy(point).addScaledVector(perp, width / 2);

                // Set y to hover height
                inner.y = seaFlatHeight + waveSettings.hoverHeight;
                outer.y = seaFlatHeight + waveSettings.hoverHeight;

                vertices.push(inner.x, inner.y, inner.z);
                vertices.push(outer.x, outer.y, outer.z);

                // UVs for animation - normalized 0-1 range
                const u = i / numSegments;
                uvs.push(u, 0);
                uvs.push(u, 1);
            }

            // Create faces (triangles) - connect back to start for closed loop
            for (let i = 0; i < numSegments; i++) {
                const a = i * 2;
                const b = i * 2 + 1;
                const c = ((i + 1) % numSegments) * 2;
                const d = ((i + 1) % numSegments) * 2 + 1;

                indices.push(a, b, c);
                indices.push(b, d, c);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            // Store original positions and UVs for JavaScript animation
            geometry.userData.originalPositions = new Float32Array(vertices);
            geometry.userData.uvs = new Float32Array(uvs);

            // Create fancy shader material with dynamic colors
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    baseColor1: { value: new THREE.Color(0x1a472a) },  // Dark forest green
                    baseColor2: { value: new THREE.Color(0x2d5a27) },  // Medium green
                    baseColor3: { value: new THREE.Color(0x6b8e23) },  // Olive/yellow-green
                    glowColor: { value: new THREE.Color(0x90EE90) },   // Light green glow
                    opacity: { value: 0.85 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;

                    void main() {
                        vUv = uv;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 baseColor1;
                    uniform vec3 baseColor2;
                    uniform vec3 baseColor3;
                    uniform vec3 glowColor;
                    uniform float opacity;

                    varying vec2 vUv;
                    varying vec3 vPosition;

                    // Simplex noise for organic patterns
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

                    float snoise(vec2 v) {
                        const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                        vec2 i = floor(v + dot(v, C.yy));
                        vec2 x0 = v - i + dot(i, C.xx);
                        vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                        vec4 x12 = x0.xyxy + C.xxzz;
                        x12.xy -= i1;
                        i = mod289(i);
                        vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
                        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                        m = m*m; m = m*m;
                        vec3 x = 2.0 * fract(p * C.www) - 1.0;
                        vec3 h = abs(x) - 0.5;
                        vec3 ox = floor(x + 0.5);
                        vec3 a0 = x - ox;
                        m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                        vec3 g;
                        g.x = a0.x * x0.x + h.x * x0.y;
                        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                        return 130.0 * dot(m, g);
                    }

                    void main() {
                        // Edge fade
                        float edgeDist = abs(vUv.y - 0.5) * 2.0;
                        float edgeFade = 1.0 - pow(edgeDist, 1.5);

                        // Use 2*PI multiplied coordinates for seamless tiling
                        // All multipliers are integers so sin() tiles perfectly around the loop
                        float twoPi = 6.28318530718;
                        float uAngle = vUv.x * twoPi;

                        // Flowing noise patterns - use sine-based pseudo-noise for seamless tiling
                        float noise1 = sin(uAngle * 8.0 - time * 0.3 + vUv.y * 4.0) * 0.3 +
                                       sin(uAngle * 13.0 + time * 0.2) * 0.2 + 0.5;
                        float noise2 = sin(uAngle * 15.0 + time * 0.5 + vUv.y * 8.0) * 0.3 +
                                       sin(uAngle * 21.0 - time * 0.3) * 0.2 + 0.5;
                        float noise3 = sin(uAngle * 25.0 - time * 0.8 + vUv.y * 3.0) * 0.3 +
                                       sin(uAngle * 34.0 + time * 0.4) * 0.2 + 0.5;

                        // Traveling wave patterns (integers for seamless tiling)
                        float wave1 = sin(uAngle * 20.0 - time * 2.0) * 0.5 + 0.5;
                        float wave2 = sin(uAngle * 35.0 + time * 3.0) * 0.5 + 0.5;
                        float wave3 = sin(uAngle * 50.0 - time * 4.0 + vUv.y * 10.0) * 0.5 + 0.5;

                        // Blend base colors with noise
                        vec3 color = mix(baseColor1, baseColor2, noise1);
                        color = mix(color, baseColor3, noise2 * 0.5);

                        // Add traveling color bands
                        color = mix(color, baseColor3, wave1 * 0.3);
                        color = mix(color, baseColor2, wave2 * 0.2);

                        // Bioluminescent glow pulses
                        float glow = pow(wave3 * noise3, 2.0) * 0.6;
                        glow += pow(sin(uAngle * 80.0 - time * 5.0) * 0.5 + 0.5, 4.0) * 0.3;
                        color = mix(color, glowColor, glow * edgeFade);

                        // Sparkle effect - use layered sines instead of noise for seamless tiling
                        float sparkle = pow(abs(sin(uAngle * 89.0 + time * 2.0) * sin(uAngle * 97.0 - time * 1.5) *
                                           sin(vUv.y * 50.0 - time)), 8.0);
                        color += sparkle * glowColor * 0.5;

                        // Center line glow
                        float centerGlow = exp(-edgeDist * 3.0) * 0.3;
                        color += centerGlow * glowColor * (sin(uAngle * 30.0 - time * 3.0) * 0.3 + 0.7);

                        // Final alpha with edge fade
                        float alpha = opacity * edgeFade * (0.7 + noise1 * 0.3);

                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.FrontSide,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending
            });

            wavePathMesh = new THREE.Mesh(geometry, material);
            wavePathMesh.visible = wavePathVisible;
            scene.add(wavePathMesh);
        }

        // Update wave animation - JavaScript vertex animation + shader time
        function updateWaveAnimation(time) {
            if (!wavePathMesh || !wavePathMesh.geometry) return;

            // Update shader time uniform for color animation
            if (wavePathMesh.material.uniforms && wavePathMesh.material.uniforms.time) {
                wavePathMesh.material.uniforms.time.value = time * waveSettings.speed;
            }

            const geometry = wavePathMesh.geometry;
            const positions = geometry.attributes.position;
            const originalPositions = geometry.userData.originalPositions;
            const uvs = geometry.userData.uvs;

            if (!originalPositions || !uvs) return;

            const t = time * waveSettings.speed;

            for (let i = 0; i < positions.count; i++) {
                const origX = originalPositions[i * 3];
                const origY = originalPositions[i * 3 + 1];
                const origZ = originalPositions[i * 3 + 2];

                const u = uvs[i * 2];
                const v = uvs[i * 2 + 1];

                // Edge distance (0 at center, 1 at edges)
                const edgeDist = Math.abs(v - 0.5) * 2.0;

                // Traveling wave along the path
                const wave1 = Math.sin(u * 40 - t * 4) * 0.5;
                const wave2 = Math.sin(u * 15 + t * 2.5) * 0.3;
                const wave3 = Math.sin(v * 8 + t * 3) * 0.2;

                // Combined wave
                const wave = wave1 + wave2 + wave3;

                // Noise for organic edges
                const noise = simplexNoise(u * 10 + t * 0.5, v * 5 + t * 0.2) * waveSettings.noiseAmount * 0.3;
                const edgeNoise = simplexNoise(u * 15 - t * 0.8, v * 8) * waveSettings.noiseAmount * edgeDist * 0.5;

                // Apply Y displacement (wave height)
                const newY = origY + wave * waveSettings.height + noise + edgeNoise;

                // Apply lateral displacement for wobbly edges
                const lateralNoise = simplexNoise(u * 12 + t * 0.4, v * 4) * waveSettings.noiseAmount * 0.3 * edgeDist;
                const newX = origX + lateralNoise;
                const newZ = origZ + simplexNoise(u * 12 - t * 0.3, v * 4 + 2) * waveSettings.noiseAmount * 0.3 * edgeDist;

                positions.setXYZ(i, newX, newY, newZ);
            }

            positions.needsUpdate = true;
            geometry.computeVertexNormals();
        }

        // Toggle wave path editor
        window.toggleWavePathEditor = function() {
            wavePathEditorVisible = !wavePathEditorVisible;
            const editor = document.getElementById('wave-path-editor');
            const toggle = document.getElementById('wave-path-toggle');

            if (wavePathEditorVisible) {
                editor.classList.add('visible');
                toggle.classList.add('active');
                updateWavePointList();
                createWaveControlPointElements();
            } else {
                editor.classList.remove('visible');
                toggle.classList.remove('active');
                removeWaveControlPointElements();
            }
        };

        // Update wave settings from UI
        window.updateWaveSettings = function() {
            waveSettings.height = parseFloat(document.getElementById('wave-height-slider').value);
            waveSettings.speed = parseFloat(document.getElementById('wave-speed-slider').value);
            waveSettings.noiseAmount = parseFloat(document.getElementById('wave-noise-slider').value);
            waveSettings.pathWidth = parseFloat(document.getElementById('wave-width-slider').value);
            waveSettings.hoverHeight = parseFloat(document.getElementById('wave-hover-slider').value);

            document.getElementById('wave-height-value').textContent = waveSettings.height;
            document.getElementById('wave-speed-value').textContent = waveSettings.speed;
            document.getElementById('wave-noise-value').textContent = waveSettings.noiseAmount;
            document.getElementById('wave-width-value').textContent = waveSettings.pathWidth;
            document.getElementById('wave-hover-value').textContent = waveSettings.hoverHeight;

            // Recreate wave path with new width/height settings
            createWavePath();
        };

        // Update wave point list in UI
        function updateWavePointList() {
            const list = document.getElementById('wave-point-list');
            list.innerHTML = '';

            wavePathControlPoints.forEach((point, index) => {
                const item = document.createElement('div');
                item.className = 'wave-point-item' + (index === selectedWavePointIndex ? ' selected' : '');
                item.innerHTML = `
                    <span>Point ${index + 1}</span>
                    <span class="point-coords">(${point.x.toFixed(1)}, ${point.z.toFixed(1)})</span>
                    <div class="point-actions">
                        <button class="delete-btn" onclick="deleteWaveControlPoint(${index}); event.stopPropagation();">Del</button>
                    </div>
                `;
                item.onclick = () => selectWavePoint(index);
                list.appendChild(item);
            });
        }

        // Select a wave control point
        function selectWavePoint(index) {
            selectedWavePointIndex = index;
            updateWavePointList();
            // Update the selected class on control point elements
            wavePathControlPointElements.forEach((el, i) => {
                el.classList.toggle('selected', i === selectedWavePointIndex);
            });
        }

        // Create DOM elements for control point handles
        function createWaveControlPointElements() {
            removeWaveControlPointElements();

            wavePathControlPoints.forEach((point, index) => {
                const el = document.createElement('div');
                el.className = 'wave-path-control-point';
                if (index === selectedWavePointIndex) {
                    el.classList.add('selected');
                }
                el.dataset.index = index;

                el.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    draggingWavePoint = index;
                    el.classList.add('dragging');
                    selectedWavePointIndex = index;
                    updateWavePointList();
                    // Update selected class on all control points
                    wavePathControlPointElements.forEach((elem, i) => {
                        elem.classList.toggle('selected', i === selectedWavePointIndex);
                    });
                });

                document.body.appendChild(el);
                wavePathControlPointElements.push(el);
            });

            document.addEventListener('mousemove', onWavePointDrag);
            document.addEventListener('mouseup', onWavePointDragEnd);

            updateWaveControlPointPositions();
        }

        // Remove control point elements
        function removeWaveControlPointElements() {
            wavePathControlPointElements.forEach(el => el.remove());
            wavePathControlPointElements = [];
            document.removeEventListener('mousemove', onWavePointDrag);
            document.removeEventListener('mouseup', onWavePointDragEnd);
        }

        // Update control point element positions on screen
        function updateWaveControlPointPositions() {
            if (!camera || !renderer) return;

            wavePathControlPointElements.forEach((el, index) => {
                const point = wavePathControlPoints[index];
                if (!point) return;

                const pos3D = new THREE.Vector3(point.x, seaFlatHeight + waveSettings.hoverHeight, point.z);
                pos3D.project(camera);

                const x = (pos3D.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-pos3D.y * 0.5 + 0.5) * window.innerHeight;

                el.style.left = x + 'px';
                el.style.top = y + 'px';

                // Hide if behind camera
                el.style.display = pos3D.z > 1 ? 'none' : 'block';
            });
        }

        // Handle dragging of wave control points
        function onWavePointDrag(e) {
            if (draggingWavePoint === null) return;

            // Convert screen position to world position
            const rect = renderer.domElement.getBoundingClientRect();
            const mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            const mouseY = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            // Create a ray from camera
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);

            // Intersect with horizontal plane at wave height
            const planeY = seaFlatHeight + waveSettings.hoverHeight;
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -planeY);
            const intersection = new THREE.Vector3();

            if (ray.ray.intersectPlane(plane, intersection)) {
                wavePathControlPoints[draggingWavePoint].x = intersection.x;
                wavePathControlPoints[draggingWavePoint].z = intersection.z;

                createWavePath();
                updateWavePointList();
                updateWaveControlPointPositions();
            }
        }

        // End dragging
        function onWavePointDragEnd() {
            if (draggingWavePoint !== null) {
                const el = wavePathControlPointElements[draggingWavePoint];
                if (el) el.classList.remove('dragging');
                draggingWavePoint = null;
            }
        }

        // Add a new control point
        window.addWaveControlPoint = function() {
            // Add point at average of last and first points
            const last = wavePathControlPoints[wavePathControlPoints.length - 1];
            const first = wavePathControlPoints[0];

            const newPoint = {
                x: (last.x + first.x) / 2,
                z: (last.z + first.z) / 2
            };

            wavePathControlPoints.push(newPoint);
            selectedWavePointIndex = wavePathControlPoints.length - 1;

            createWavePath();
            updateWavePointList();
            if (wavePathEditorVisible) {
                createWaveControlPointElements();
            }
        };

        // Delete a control point
        window.deleteWaveControlPoint = function(index) {
            if (wavePathControlPoints.length <= 3) {
                alert('Minimum 3 points required for a closed path');
                return;
            }

            wavePathControlPoints.splice(index, 1);
            selectedWavePointIndex = Math.min(selectedWavePointIndex, wavePathControlPoints.length - 1);

            createWavePath();
            updateWavePointList();
            if (wavePathEditorVisible) {
                createWaveControlPointElements();
            }
        };

        // Reset to default path (algae ring)
        window.resetWavePath = function() {
            wavePathControlPoints = [
                { x: -25.71291794965777, z: -29.217843410809053 },
                { x: -4.282529178462653, z: -46.740537308281745 },
                { x: 36.92184505219151, z: -50.99121812585662 },
                { x: 49.98813535975319, z: -15.519247201427703 },
                { x: 26.271187494134324, z: 21.400622967905292 },
                { x: 13.552623641194018, z: 53.91585522253054 },
                { x: -42.74747143324832, z: 51.24958472116657 },
                { x: -42.57115618373139, z: 14.233393590631863 },
                { x: -50.86222231758773, z: -22.849058854811517 }
            ];
            waveSettings = {
                height: 1,
                speed: 0.5,
                noiseAmount: 4,
                pathWidth: 2,
                hoverHeight: 2.5
            };
            selectedWavePointIndex = -1;

            // Update UI sliders
            document.getElementById('wave-height-slider').value = waveSettings.height;
            document.getElementById('wave-speed-slider').value = waveSettings.speed;
            document.getElementById('wave-noise-slider').value = waveSettings.noiseAmount;
            document.getElementById('wave-width-slider').value = waveSettings.pathWidth;
            document.getElementById('wave-hover-slider').value = waveSettings.hoverHeight;
            document.getElementById('wave-height-value').textContent = waveSettings.height;
            document.getElementById('wave-speed-value').textContent = waveSettings.speed;
            document.getElementById('wave-noise-value').textContent = waveSettings.noiseAmount;
            document.getElementById('wave-width-value').textContent = waveSettings.pathWidth;
            document.getElementById('wave-hover-value').textContent = waveSettings.hoverHeight;

            createWavePath();
            updateWavePointList();
            if (wavePathEditorVisible) {
                createWaveControlPointElements();
            }
        };

        // Toggle wave visibility
        window.toggleWavePathVisible = function() {
            wavePathVisible = !wavePathVisible;
            if (wavePathMesh) {
                wavePathMesh.visible = wavePathVisible;
            }
        };

        // Export wave path data
        window.exportWavePath = function() {
            const data = {
                controlPoints: wavePathControlPoints,
                settings: waveSettings
            };
            const json = JSON.stringify(data, null, 2);

            // Copy to clipboard
            navigator.clipboard.writeText(json).then(() => {
                alert('Wave path data copied to clipboard!');
            }).catch(() => {
                console.log('Wave path data:', json);
                alert('Check console for wave path data');
            });
        };

        // ============== END WAVE PATH FUNCTIONS ==============

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f7fa);
            // Add fog to hide edges and create infinite feel
            // Starts with heavy fog for 2D look, clears during intro animation
            scene.fog = new THREE.Fog(0xf5f7fa, 100, 200);

            // Camera - start at high position for entrance animation
            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            // Label renderer
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            // Post-processing setup (no bloom)
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2;

            // Mouse events
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);

            // Lighting - soft and ambient for clean look
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0xb8a5ff, 0.8, 200);
            pointLight1.position.set(50, 40, 0);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffc4e1, 0.8, 200);
            pointLight2.position.set(-50, 40, 0);
            scene.add(pointLight2);

            // Setup control panel
            setupControls();
            setupEditorUI();

            // Load heightmap
            loadHeightmap();
        }

        function setupControls() {
            // FOV control
            const fovSlider = document.getElementById('fov');
            const fovValue = document.getElementById('fov-value');
            fovSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.fov = value;
                camera.updateProjectionMatrix();
                fovValue.textContent = value;
            });

            // Position Y control
            posYSlider = document.getElementById('pos-y');
            posYValueDisplay = document.getElementById('pos-y-value');
            posYSlider.value = camera.position.y;
            posYValueDisplay.textContent = Math.round(camera.position.y);
            posYSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.y = value;
                posYValueDisplay.textContent = value;
            });

            // Position X control
            posXSlider = document.getElementById('pos-x');
            posXValueDisplay = document.getElementById('pos-x-value');
            posXSlider.value = camera.position.x;
            posXValueDisplay.textContent = Math.round(camera.position.x);
            posXSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.x = value;
                posXValueDisplay.textContent = value;
            });

            // Position Z control
            const posZSlider = document.getElementById('pos-z');
            const posZValue = document.getElementById('pos-z-value');
            posZSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                camera.position.z = value;
                posZValue.textContent = value;
            });

            // Height scale control (live update terrain heights)
            const heightSlider = document.getElementById('height-scale');
            const heightValue = document.getElementById('height-value');
            heightSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                heightScale = value;
                heightValue.textContent = value;
                applyHeightScale();
            });

            // Sea threshold control (live recolor + flatten ocean)
            const seaSlider = document.getElementById('sea-threshold');
            const seaValue = document.getElementById('sea-threshold-value');
            const seaInput = document.getElementById('sea-threshold-input');
            const clampSea = (v) => Math.max(parseFloat(seaSlider.min), Math.min(parseFloat(seaSlider.max), v));

            const syncSeaUI = (v) => {
                const vv = clampSea(v);
                seaSlider.value = vv;
                seaInput.value = vv;
                seaValue.textContent = parseFloat(vv).toFixed(2);
            };

            syncSeaUI(seaThreshold);

            seaSlider.addEventListener('input', (e) => {
                const value = clampSea(parseFloat(e.target.value));
                seaThreshold = value;
                seaValue.textContent = value.toFixed(2);
                seaInput.value = value;
                applySeaThreshold();
            });

            seaInput.addEventListener('input', (e) => {
                const raw = parseFloat(e.target.value);
                if (isNaN(raw)) return;
                const value = clampSea(raw);
                seaThreshold = value;
                seaSlider.value = value;
                seaValue.textContent = value.toFixed(2);
                applySeaThreshold();
            });

            // Sea level height control (live update ocean flat height)
            const seaHeightSlider = document.getElementById('sea-height');
            const seaHeightInput = document.getElementById('sea-height-input');
            const seaHeightValue = document.getElementById('sea-height-value');
            const clampSeaHeight = (v) => Math.max(parseFloat(seaHeightSlider.min), Math.min(parseFloat(seaHeightSlider.max), v));

            const syncSeaHeightUI = (v) => {
                const vv = clampSeaHeight(v);
                seaHeightSlider.value = vv;
                seaHeightInput.value = vv;
                seaHeightValue.textContent = parseFloat(vv).toFixed(2);
            };

            syncSeaHeightUI(seaFlatHeight);

            const applySeaHeight = (value) => {
                seaFlatHeight = value;
                applySeaThreshold();
            };

            seaHeightSlider.addEventListener('input', (e) => {
                const value = clampSeaHeight(parseFloat(e.target.value));
                syncSeaHeightUI(value);
                applySeaHeight(value);
            });
            seaHeightInput.addEventListener('input', (e) => {
                const raw = parseFloat(e.target.value);
                if (isNaN(raw)) return;
                const value = clampSeaHeight(raw);
                syncSeaHeightUI(value);
                applySeaHeight(value);
            });

            // Material rotation slider
            const matRotSlider = document.getElementById('mat-rotation');
            const matRotValue = document.getElementById('mat-rotation-value');
            matRotSlider.value = matRotationDeg;
            matRotValue.textContent = Math.round(matRotationDeg);
            matRotSlider.addEventListener('input', (e) => {
                matRotationDeg = parseFloat(e.target.value) || 0;
                matRotValue.textContent = Math.round(matRotationDeg);
                applySeaThreshold();
            });

            // Material flip toggles
            const flipUEl = document.getElementById('mat-flip-u');
            const flipVEl = document.getElementById('mat-flip-v');
            flipUEl.checked = !!flipMaterialU;
            flipVEl.checked = !!flipMaterialV;
            flipUEl.addEventListener('change', (e) => {
                flipMaterialU = !!e.target.checked;
                applySeaThreshold();
            });
            flipVEl.addEventListener('change', (e) => {
                flipMaterialV = !!e.target.checked;
                applySeaThreshold();
            });

            // Height map rotation slider
            const heightRotSlider = document.getElementById('height-rotation');
            const heightRotValue = document.getElementById('height-rotation-value');
            heightRotSlider.value = heightRotationDeg;
            heightRotValue.textContent = Math.round(heightRotationDeg);
            heightRotSlider.addEventListener('input', (e) => {
                heightRotationDeg = parseFloat(e.target.value) || 0;
                heightRotValue.textContent = Math.round(heightRotationDeg);
                applyHeightMapRotation();
            });

            // Height map flip checkboxes
            const heightFlipUEl = document.getElementById('height-flip-u');
            const heightFlipVEl = document.getElementById('height-flip-v');
            heightFlipUEl.checked = flipHeightU;
            heightFlipVEl.checked = flipHeightV;
            heightFlipUEl.addEventListener('change', (e) => {
                flipHeightU = !!e.target.checked;
                applyHeightMapRotation();
            });
            heightFlipVEl.addEventListener('change', (e) => {
                flipHeightV = !!e.target.checked;
                applyHeightMapRotation();
            });
        }

        function loadTexturePromise(url) {
            return new Promise((resolve, reject) => {
                new THREE.TextureLoader().load(url, (texture) => {
                    // Use linear filtering for smooth, non-pixelated textures
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    resolve(texture);
                }, undefined, reject);
            });
        }

        function getImageDataFromTexture(tex) {
            const img = tex.image;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            return { data: imageData.data, width: canvas.width, height: canvas.height };
        }

        function loadHeightmap() {
            console.log('Loading maps...');
            const cacheBuster = '?t=' + Date.now();
            Promise.all([
                loadTexturePromise('Assets/images/Map/Map Height Map.png' + cacheBuster),
                loadTexturePromise('Assets/images/Map/JUNK Map.png' + cacheBuster)
            ]).then(async ([heightTex, materialTex]) => {
                // Treat material texture as sRGB for accurate colors
                materialTex.colorSpace = THREE.SRGBColorSpace;
                materialTex.needsUpdate = true;
                const h = getImageDataFromTexture(heightTex);
                const m = getImageDataFromTexture(materialTex);

                // Store heightmap globally for rotation
                heightImageData = h.data;
                heightW = h.width;
                heightH = h.height;

                // Store material globally for land coloring
                matImageData = m.data;
                matW = m.width;
                matH = m.height;

                console.log('Creating terrain grid...');
                await createGridTerrain(h.data, h.width, h.height, materialTex);
                console.log('Terrain created, starting animation');

                document.getElementById('loading').style.display = 'none';

                animationStartTime = Date.now();
                startCameraIntro();
            }).catch((error) => {
                console.error('Error loading maps:', error);
                document.getElementById('loading').innerText = 'ERROR LOADING TERRAIN';
            });
        }

        // Simple noise function
        function noise2D(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return n - Math.floor(n);
        }

        // Sample material color with optional V-flip and rotation
        function sampleMaterialColor(u, v) {
            if (!matImageData) return [1, 1, 1];
            let uu = Math.max(0, Math.min(1, u));
            let vv = Math.max(0, Math.min(1, v));
            // Apply flips first if enabled
            if (flipMaterialU) uu = 1 - uu;
            if (flipMaterialV) vv = 1 - vv;
            // Apply rotation about center (0.5, 0.5)
            if (matRotationDeg !== 0) {
                const rad = matRotationDeg * Math.PI / 180;
                const cosr = Math.cos(rad);
                const sinr = Math.sin(rad);
                const cx = uu - 0.5;
                const cy = vv - 0.5;
                const rx = cx * cosr - cy * sinr;
                const ry = cx * sinr + cy * cosr;
                uu = Math.max(0, Math.min(1, rx + 0.5));
                vv = Math.max(0, Math.min(1, ry + 0.5));
            }
            const x = Math.min(matW - 1, Math.floor(uu * matW));
            const y = Math.min(matH - 1, Math.floor(vv * matH));
            const i = (y * matW + x) * 4;
            return [matImageData[i] / 255, matImageData[i + 1] / 255, matImageData[i + 2] / 255];
        }

        // Sample heightmap with rotation and flip
        function sampleHeightmap(u, v) {
            if (!heightImageData) return 0;
            let uu = Math.max(0, Math.min(1, u));
            let vv = Math.max(0, Math.min(1, v));
            // Apply flips first
            if (flipHeightU) uu = 1 - uu;
            if (flipHeightV) vv = 1 - vv;
            // Apply rotation about center (0.5, 0.5)
            if (heightRotationDeg !== 0) {
                const rad = heightRotationDeg * Math.PI / 180;
                const cosr = Math.cos(rad);
                const sinr = Math.sin(rad);
                const cx = uu - 0.5;
                const cy = vv - 0.5;
                const rx = cx * cosr - cy * sinr;
                const ry = cx * sinr + cy * cosr;
                uu = Math.max(0, Math.min(1, rx + 0.5));
                vv = Math.max(0, Math.min(1, ry + 0.5));
            }
            const x = Math.min(heightW - 1, Math.floor(uu * heightW));
            const y = Math.min(heightH - 1, Math.floor(vv * heightH));
            const i = (y * heightW + x) * 4;
            return heightImageData[i] / 255; // Return grayscale value
        }

        // Apply height map rotation to terrain
        function applyHeightMapRotation() {
            updateTerrainHeights();
        }

        async function createGridTerrain(data, width, height, materialTex) {
            const segments = Math.min(width, height) / sampleRate;

            // Create plane geometry with segments matching the texture resolution
            const geometry = new THREE.PlaneGeometry(128, 128, segments - 1, segments - 1);

            // Apply the material texture directly
            const material = new THREE.MeshBasicMaterial({
                map: materialTex,
                side: THREE.FrontSide
            });

            // Get position attribute to modify heights
            const positions = geometry.attributes.position;

            // Modify vertex heights based on heightmap (using sampleHeightmap for rotation/flip)
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getY(i); // In PlaneGeometry, Y is the vertical axis

                // Convert world position to texture coordinates
                const u = (x + 64) / 128; // 0 to 1
                const v = (z + 64) / 128; // 0 to 1

                // Sample heightmap with rotation and flip applied
                const grayscale = sampleHeightmap(u, v);

                // Calculate vertex height
                const isOcean = grayscale <= seaThreshold;
                const vertexHeight = isOcean ? seaFlatHeight : (grayscale * heightScale + 0.5);

                // Set Z position (height in plane geometry)
                positions.setZ(i, vertexHeight);
            }

            positions.needsUpdate = true;
            geometry.computeVertexNormals(); // Recalculate normals for proper lighting

            // Create mesh
            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.rotation.x = -Math.PI / 2; // Rotate to lay flat
            scene.add(terrainMesh);

            // Create extended ocean plane (same color as terrain ocean)
            // Find an ocean pixel by checking the heightmap for dark areas
            const oceanCanvas = document.createElement('canvas');
            oceanCanvas.width = materialTex.image.width;
            oceanCanvas.height = materialTex.image.height;
            const oceanCtx = oceanCanvas.getContext('2d');
            oceanCtx.drawImage(materialTex.image, 0, 0);

            // Find ocean color by scanning for a pixel where heightmap is dark (ocean)
            let oceanColor = new THREE.Color(0x87CEEB); // Default fallback
            const matImgData = oceanCtx.getImageData(0, 0, materialTex.image.width, materialTex.image.height).data;

            for (let i = 0; i < data.length; i += 4) {
                const grayscale = data[i] / 255;
                if (grayscale <= seaThreshold) {
                    // Found an ocean pixel, get color from material texture at same position
                    const pixelIndex = i; // Same index in material image
                    if (pixelIndex < matImgData.length - 3) {
                        oceanColor = new THREE.Color(
                            matImgData[pixelIndex] / 255,
                            matImgData[pixelIndex + 1] / 255,
                            matImgData[pixelIndex + 2] / 255
                        );
                        break;
                    }
                }
            }

            const oceanGeometry = new THREE.PlaneGeometry(1024, 1024);
            const oceanMaterial = new THREE.MeshBasicMaterial({
                color: 0x32546d,
                side: THREE.FrontSide,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
            });
            const oceanPlane = new THREE.Mesh(oceanGeometry, oceanMaterial);
            oceanPlane.rotation.x = -Math.PI / 2;
            oceanPlane.position.y = seaFlatHeight - 0.1; // Slightly below terrain ocean
            scene.add(oceanPlane);

            // Create wave path around the island
            createWavePath();

            // Load saved journeys
            await loadJourneyData();
            journeyPoints = buildJourneyPoints(selectedPersonName);

            // Load saved labels
            loadLabels();

            // Setup label click handler
            setupLabelClickHandler();

            // Start with overview (no journey points)
            showOverview();
        }

        // Get terrain height at a given world position
        function getTerrainHeight(worldX, worldZ, heightData, dataWidth, dataHeight) {
            // Convert world position to texture coordinates
            const u = (worldX + 64) / 128;
            const v = (worldZ + 64) / 128;

            // Clamp to valid range
            const clampedU = Math.max(0, Math.min(1, u));
            const clampedV = Math.max(0, Math.min(1, v));

            // Sample heightmap
            const dataX = Math.floor(clampedU * dataWidth);
            const dataZ = Math.floor(clampedV * dataHeight);
            const index = (dataZ * dataWidth + dataX) * 4;
            const grayscale = heightData[index] / 255;

            // Calculate height
            const isOcean = grayscale <= seaThreshold;
            return isOcean ? seaFlatHeight : (grayscale * heightScale + 0.5);
        }

        function clearJourneySystem() {
            journeyMarkers.forEach(({ sphere, ring, label }) => {
                scene.remove(sphere);
                scene.remove(ring);
                scene.remove(label);
            });
            journeyMarkers = [];

            journeyLines.forEach(({ line, dashLine }) => {
                if (line) scene.remove(line);
                if (dashLine) scene.remove(dashLine);
            });
            journeyLines = [];
            selectedJourneyPoint = null;
            journeyTransitioning = false;
            journeySavedCameraPos = null;
            journeySavedTarget = null;
        }

        // Create journey markers and connecting lines
        function createJourneySystem(heightData, dataWidth, dataHeight) {
            if (!heightData || journeyPoints.length === 0) return;

            const pointsByPerson = journeyPoints.reduce((acc, point) => {
                const person = point.person || 'unknown';
                if (!acc[person]) acc[person] = [];
                acc[person].push(point);
                return acc;
            }, {});

            Object.entries(pointsByPerson).forEach(([personName, points]) => {
                const personColorHex = personColors[personName] || 0x6b4ce6;
                const personColor = new THREE.Color(personColorHex);
                const linePoints = [];

                points.forEach((point, index) => {
                    // Get terrain height at this position
                    const terrainHeight = getTerrainHeight(point.x, point.z, heightData, dataWidth, dataHeight);
                    point.y = terrainHeight + 2; // Slightly above terrain

                    // Create 3D sphere marker
                    const sphereGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                    const sphereMaterial = new THREE.MeshBasicMaterial({
                        color: personColorHex,
                        transparent: true,
                        opacity: 0.9
                    });
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.set(point.x, point.y, point.z);
                    sphere.userData = { journeyPoint: point, index: index };
                    scene.add(sphere);

                    // Create pulsing ring around sphere
                    const ringGeometry = new THREE.RingGeometry(2, 2.5, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: personColorHex,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.FrontSide
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.set(point.x, point.y, point.z);
                    ring.rotation.x = -Math.PI / 2;
                    ring.userData = { pulseTime: index * 0.5 }; // Offset pulse timing
                    scene.add(ring);

                    // Create CSS2D label
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'journey-marker';
                    labelDiv.style.setProperty('--journey-accent', hexToRgba(personColorHex, 0.85));
                    labelDiv.style.setProperty('--journey-accent-surface', hexToRgba(personColorHex, 0.16));
                    labelDiv.style.setProperty('--journey-accent-border', hexToRgba(personColorHex, 0.35));
                    labelDiv.style.boxShadow = `0 12px 32px ${hexToRgba(personColorHex, 0.2)}`;

                    // Show only icon when viewing all journeys, show number + name for individual person
                    if (currentPerson === 'all' && !editMode) {
                        labelDiv.classList.add('icon-only');
                        labelDiv.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
                    } else {
                        labelDiv.innerHTML = `
                            <span class="journey-number">${index + 1}</span>
                            <span>${point.name}</span>
                        `;
                    }
                    const label = new CSS2DObject(labelDiv);
                    label.position.set(point.x, point.y + 3, point.z);
                    scene.add(label);

                    const markerObj = {
                        point: point,
                        sphere: sphere,
                        ring: ring,
                        label: label
                    };

                    // Allow clicking the label to open the gallery in normal mode
                    labelDiv.style.pointerEvents = 'auto';
                    labelDiv.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (editMode) return;
                        onJourneyPointClick(markerObj);
                    });
                    // Allow dragging via the label in edit mode
                    labelDiv.addEventListener('mousedown', (e) => {
                        if (!editMode) return;
                        e.stopPropagation();
                        draggingJourneyMarker = markerObj;
                        setEditingPoint(markerObj.point);
                        controls.enabled = false;
                    });

                    journeyMarkers.push(markerObj);

                    // Add to line points
                    linePoints.push(new THREE.Vector3(point.x, point.y + 0.5, point.z));
                });

                // Create connecting line using CatmullRomCurve3 for smooth path
                if (linePoints.length > 1) {
                    const curve = new THREE.CatmullRomCurve3(linePoints, false, 'catmullrom', 0.5);
                    const curvePoints = curve.getPoints(100);
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: personColorHex,
                        transparent: true,
                        opacity: 0.7
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    scene.add(line);

                    // Create animated dashed line on top
                    const dashGeometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
                    const dashMaterial = new THREE.LineDashedMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8,
                        dashSize: 2,
                        gapSize: 1
                    });
                    const dashLine = new THREE.Line(dashGeometry, dashMaterial);
                    dashLine.computeLineDistances();
                    dashLine.userData = { dashOffset: 0 };
                    scene.add(dashLine);

                    journeyLines.push({ line, dashLine, dashOffset: 0 });
                }
            });
        }

        // Track camera movement for collision detection
        let lastCameraPos = new THREE.Vector3();
        let lastCameraTarget = new THREE.Vector3();
        let cameraIsMoving = false;
        let journeyJustBecameVisible = false;

        // Animate journey elements
        function animateJourney() {
            const time = Date.now() * 0.001;

            // Check if camera is moving
            const cameraMoved = !camera.position.equals(lastCameraPos) || !controls.target.equals(lastCameraTarget);
            if (cameraMoved) {
                cameraIsMoving = true;
                lastCameraPos.copy(camera.position);
                lastCameraTarget.copy(controls.target);
            } else {
                cameraIsMoving = false;
            }

            // Collect label rects for collision detection (only for individual view AND when camera moves or just became visible)
            const labelRects = [];
            const shouldRunCollision = cameraIsMoving || journeyJustBecameVisible;
            const doCollisionDetection = currentPerson && currentPerson !== 'all' && shouldRunCollision;
            journeyJustBecameVisible = false; // Reset flag after use

            journeyMarkers.forEach((marker, index) => {
                // Pulse effect on rings
                const pulsePhase = time + marker.ring.userData.pulseTime;
                const pulseScale = 1 + Math.sin(pulsePhase * 2) * 0.2;
                marker.ring.scale.set(pulseScale, pulseScale, 1);
                marker.ring.material.opacity = 0.3 + Math.sin(pulsePhase * 2) * 0.2;

                // Gentle bob on spheres
                const bobOffset = Math.sin(time * 1.5 + index * 0.7) * 0.3;
                marker.sphere.position.y = marker.point.y + bobOffset;

                // Set z-index based on distance to camera (closer = higher z-index)
                const dist = camera.position.distanceTo(marker.sphere.position);
                const zIndex = Math.round(10000 - dist * 10);
                marker.label.element.style.zIndex = zIndex;

                if (doCollisionDetection) {
                    const rect = marker.label.element.getBoundingClientRect();
                    labelRects.push({ marker, rect, dist });
                } else {
                    // Reset offset when viewing all
                    marker.currentOffsetY = 0;
                    marker.label.element.style.marginTop = '-12px';
                }
            });

            // Collision detection for individual journey view
            if (doCollisionDetection && labelRects.length > 0) {
                labelRects.sort((a, b) => a.dist - b.dist);

                const padding = 8;
                const targetOffsets = new Map();
                const placedLabels = [];

                labelRects.forEach(({ marker, rect }) => {
                    const baseTop = rect.top + (marker.currentOffsetY || 0);
                    const baseBottom = rect.bottom + (marker.currentOffsetY || 0);

                    let targetOffsetY = 0;

                    for (const placed of placedLabels) {
                        const horizontalOverlap = !(rect.right < placed.left || rect.left > placed.right);
                        const verticalOverlap = !(baseBottom - targetOffsetY < placed.top || baseTop - targetOffsetY > placed.bottom);

                        if (horizontalOverlap && verticalOverlap) {
                            targetOffsetY = Math.max(targetOffsetY, baseBottom - placed.top + padding);
                        }
                    }

                    targetOffsets.set(marker, targetOffsetY);

                    placedLabels.push({
                        left: rect.left,
                        right: rect.right,
                        top: baseTop - targetOffsetY,
                        bottom: baseBottom - targetOffsetY
                    });
                });

                labelRects.forEach(({ marker }) => {
                    if (marker.currentOffsetY === undefined) marker.currentOffsetY = 0;
                    const target = targetOffsets.get(marker) || 0;
                    marker.currentOffsetY += (target - marker.currentOffsetY) * 0.1;
                    marker.label.element.style.marginTop = `${-12 - marker.currentOffsetY}px`;
                });
            }

            // Animate dashed lines
            journeyLines.forEach((lineObj) => {
                if (!lineObj.dashLine) return;
                lineObj.dashOffset = (lineObj.dashOffset || 0) - 0.05;
                lineObj.dashLine.material.dashOffset = lineObj.dashOffset;
            });
        }

        // Handle journey point click
        function onJourneyPointClick(marker) {
            selectedJourneyPoint = marker;

            // Save current camera state
            journeySavedCameraPos = camera.position.clone();
            journeySavedTarget = controls.target.clone();

            // Start transition
            journeyTransitioning = true;
            journeyTransitionProgress = 0;
            controls.enabled = false;
        }

        // Update journey camera transition
        function updateJourneyCamera() {
            if (!journeyTransitioning || !selectedJourneyPoint) return;

            journeyTransitionProgress += 0.02;
            if (journeyTransitionProgress >= 1) {
                journeyTransitionProgress = 1;
                journeyTransitioning = false;

                // Show media popup when zoom complete
                showMediaPopup(selectedJourneyPoint.point);
            }

            const eased = 1 - Math.pow(1 - journeyTransitionProgress, 3);

            // Calculate target camera position (close to the point)
            const point = selectedJourneyPoint.point;
            const targetPos = new THREE.Vector3(
                point.x + 15,
                point.y + 12,
                point.z + 15
            );
            const targetLookAt = new THREE.Vector3(point.x, point.y, point.z);

            // Lerp camera
            camera.position.lerpVectors(journeySavedCameraPos, targetPos, eased);
            controls.target.lerpVectors(journeySavedTarget, targetLookAt, eased);
            camera.lookAt(controls.target);
        }

        // Show media popup
        function showMediaPopup(point) {
            // Find the index of this point in journeyPoints
            currentJourneyIndex = journeyPoints.findIndex(p => p.id === point.id && p.person === point.person);
            if (currentJourneyIndex === -1) currentJourneyIndex = 0;

            updateGalleryContent();
            updateGalleryDots();
            updateGalleryNavButtons();

            const popup = document.getElementById('media-popup');
            popup.classList.add('visible');

            // Add keyboard listener
            document.addEventListener('keydown', handleGalleryKeydown);
        }

        // Update gallery content for current journey point
        function updateGalleryContent() {
            const point = journeyPoints[currentJourneyIndex];
            if (!point) return;

            const title = document.getElementById('media-title');
            const description = document.getElementById('media-description');
            const placeholder = document.getElementById('media-placeholder');
            const rawMedia = point.media || '';
            const mediaType = point.mediaType || detectMediaType(rawMedia);

            title.textContent = point.name;
            description.textContent = point.description;

            // Set media content
            if (rawMedia && mediaType === 'image') {
                placeholder.innerHTML = `<img src="${rawMedia}" alt="${point.name}">`;
            } else if (mediaType === 'embed') {
                // Render embed code directly (iframe/div snippets from Vimeo, etc.)
                // Use exact CSS trick from CodePen to hide controls
                const wrapperId = 'vimeo-wrapper-' + Date.now();
                // .top: padding-bottom:56.25%, height:0, overflow:hidden, position:relative
                // .wrapper: position:relative, padding-bottom:200%, transform:translateY(-35.95%)
                // iframe: position:absolute, top:0, left:0, width:100%, height:100%
                placeholder.innerHTML = `
                    <div id="${wrapperId}" style="padding-bottom:56.25%;height:0;overflow:hidden;position:relative;width:80vw;max-width:800px;border-radius:12px;">
                        <div class="vimeo-wrapper" style="position:relative;padding-bottom:200%;transform:translateY(-35.95%);">
                        </div>
                    </div>`;

                const wrapper = document.getElementById(wrapperId);
                const innerWrapper = wrapper.querySelector('.vimeo-wrapper');

                // Extract iframe src from the embed code
                const srcMatch = rawMedia.match(/src=["']([^"']+)["']/i);
                if (srcMatch && srcMatch[1].includes('vimeo.com')) {
                    let src = srcMatch[1];
                    // Clean and rebuild URL - match CodePen exactly
                    src = src.replace(/[&?]title=\d/gi, '');
                    src = src.replace(/[&?]byline=\d/gi, '');
                    src = src.replace(/[&?]portrait=\d/gi, '');
                    const separator = src.includes('?') ? '&' : '?';
                    src += `${separator}title=0&byline=0&portrait=0&transparent=0&autoplay=1&muted=1`;

                    // Create iframe
                    const iframe = document.createElement('iframe');
                    iframe.src = src;
                    iframe.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;border:0;';
                    iframe.setAttribute('frameborder', '0');
                    iframe.setAttribute('allow', 'autoplay; fullscreen; picture-in-picture');
                    iframe.setAttribute('allowfullscreen', '');
                    iframe.setAttribute('webkitallowfullscreen', '');
                    iframe.setAttribute('mozallowfullscreen', '');
                    innerWrapper.appendChild(iframe);
                }
            } else if (mediaType === 'video') {
                placeholder.innerHTML = `<video controls><source src="${rawMedia}" type="video/mp4">Your browser does not support video.</video>`;
            } else if (mediaType === 'hls') {
                const videoId = 'hls-video-' + Date.now();
                placeholder.innerHTML = `<div style="position:relative;padding-bottom:56.25%;height:0;overflow:hidden;border-radius:12px;background:#000;"><video id="${videoId}" controls playsinline style="position:absolute;top:0;left:0;width:100%;height:100%;border:0;"></video></div>`;
                const video = document.getElementById(videoId);
                if (window.Hls && Hls.isSupported()) {
                    const hls = new Hls();
                    hls.loadSource(rawMedia);
                    hls.attachMedia(video);
                    hls.on(Hls.Events.ERROR, () => {
                        placeholder.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
                    });
                } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    video.src = rawMedia;
                } else {
                    placeholder.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
                }
            } else if (mediaType === 'vimeo-external') {
                const vimeoId = getVimeoExternalId(rawMedia);
                if (vimeoId) {
                    const embedUrl = `https://player.vimeo.com/video/${vimeoId}?playsinline=1`;
                    placeholder.innerHTML = `<div style="position:relative;padding-bottom:56.25%;height:0;overflow:hidden;border-radius:12px;"><iframe src="${embedUrl}" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0;" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe></div>`;
                } else {
                    placeholder.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
                }
            } else if (mediaType === 'vimeo') {
                const vimeoId = getVimeoId(rawMedia);
                if (vimeoId) {
                    const embedUrl = `https://player.vimeo.com/video/${vimeoId}?playsinline=1`;
                    placeholder.innerHTML = `<div style="position:relative;padding-bottom:56.25%;height:0;overflow:hidden;border-radius:12px;"><iframe src="${embedUrl}" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0;" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe></div>`;
                } else {
                    placeholder.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
                }
            } else {
                placeholder.innerHTML = `<span class="material-symbols-outlined">${point.icon}</span>`;
            }
        }

        // Update gallery navigation dots
        function updateGalleryDots() {
            const dotsContainer = document.getElementById('gallery-dots');
            dotsContainer.innerHTML = '';
            dotsContainer.style.display = 'flex';

            journeyPoints.forEach((point, index) => {
                const dot = document.createElement('div');
                dot.className = 'gallery-dot' + (index === currentJourneyIndex ? ' active' : '');
                dot.textContent = index + 1;
                dot.onclick = () => goToJourneyPoint(index);
                dotsContainer.appendChild(dot);
            });
        }

        // Update navigation button visibility
        function updateGalleryNavButtons() {
            const prevBtn = document.querySelector('.gallery-prev');
            const nextBtn = document.querySelector('.gallery-next');

            prevBtn.classList.toggle('hidden', currentJourneyIndex === 0);
            nextBtn.classList.toggle('hidden', currentJourneyIndex === journeyPoints.length - 1);
        }

        // Navigate to specific journey point by index
        function goToJourneyPoint(index) {
            if (index < 0 || index >= journeyPoints.length) return;
            currentJourneyIndex = index;
            updateGalleryContent();
            updateGalleryDots();
            updateGalleryNavButtons();
            animateCameraToCurrentPoint();
        }

        // Navigate journey by direction (-1 for prev, +1 for next)
        window.navigateJourney = function(direction) {
            const newIndex = currentJourneyIndex + direction;
            if (newIndex < 0 || newIndex >= journeyPoints.length) return;
            goToJourneyPoint(newIndex);
        };

        // Animate camera to the current journey point
        function animateCameraToCurrentPoint() {
            const point = journeyPoints[currentJourneyIndex];
            if (!point) return;

            const targetPos = new THREE.Vector3(point.x + 15, point.y + 12, point.z + 15);
            const targetLookAt = new THREE.Vector3(point.x, point.y, point.z);

            let progress = 0;
            const animateCamera = () => {
                progress += 0.04;
                if (progress >= 1) {
                    camera.position.copy(targetPos);
                    controls.target.copy(targetLookAt);
                    camera.lookAt(controls.target);
                    return;
                }

                const eased = 1 - Math.pow(1 - progress, 3);
                camera.position.lerp(targetPos, eased * 0.15);
                controls.target.lerp(targetLookAt, eased * 0.15);
                camera.lookAt(controls.target);

                requestAnimationFrame(animateCamera);
            };

            animateCamera();
        }

        // Handle keyboard navigation in gallery
        function handleGalleryKeydown(e) {
            if (e.key === 'ArrowLeft') {
                navigateJourney(-1);
            } else if (e.key === 'ArrowRight') {
                navigateJourney(1);
            } else if (e.key === 'Escape') {
                closeMediaPopup();
            }
        }

        // Close media popup (global function for onclick)
        window.closeMediaPopup = function() {
            const popup = document.getElementById('media-popup');
            popup.classList.remove('visible');

            // Stop any playing videos or iframes
            const placeholder = document.getElementById('media-placeholder');
            const video = placeholder.querySelector('video');
            if (video) {
                video.pause();
                video.currentTime = 0;
            }
            const iframe = placeholder.querySelector('iframe');
            if (iframe) {
                iframe.src = iframe.src; // Reset iframe to stop playback
            }

            // Remove keyboard listener
            document.removeEventListener('keydown', handleGalleryKeydown);

            // Clear selected journey point immediately to allow new clicks
            selectedJourneyPoint = null;

            // Return camera to saved position
            if (journeySavedCameraPos && journeySavedTarget) {
                journeyTransitioning = true;
                journeyTransitionProgress = 0;

                const returnTransition = () => {
                    journeyTransitionProgress += 0.03;
                    if (journeyTransitionProgress >= 1) {
                        journeyTransitionProgress = 1;
                        controls.enabled = true;
                        journeyTransitioning = false;
                        return;
                    }

                    const eased = 1 - Math.pow(1 - journeyTransitionProgress, 3);
                    camera.position.lerp(journeySavedCameraPos, eased * 0.1);
                    controls.target.lerp(journeySavedTarget, eased * 0.1);
                    camera.lookAt(controls.target);

                    requestAnimationFrame(returnTransition);
                };

                returnTransition();
            } else {
                controls.enabled = true;
            }
        };

        // Also close popup when clicking outside (on the dark background)
        document.getElementById('media-popup').addEventListener('click', function(e) {
            if (e.target === this) {
                closeMediaPopup();
            }
        });

        function getAnimationDelay(x, z, width, height) {
            // Ripple from center
            const centerX = width / 2;
            const centerZ = height / 2;
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(z - centerZ, 2));
            const maxDistance = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerZ, 2));
            return (distance / maxDistance) * 2000; // 2 second wave
        }

        function startCameraIntro() {
            if (!cameraMixer) {
                cameraMixer = new THREE.AnimationMixer(camera);

                // Simple straight down zoom - start and end are both top-down
                const start = new THREE.Vector3(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
                const end = new THREE.Vector3(cameraEndPos.x, cameraEndPos.y, cameraEndPos.z);

                // Create smooth animation for straight zoom
                const duration = 3.2; // seconds
                const samples = 100;
                const times = new Float32Array(samples);
                const values = new Float32Array(samples * 3);

                for (let i = 0; i < samples; i++) {
                    const t = i / (samples - 1);
                    // Ease-out for gentle finish
                    const te = 1 - Math.pow(1 - t, 3); // easeOutCubic
                    times[i] = t * duration;
                    values[i * 3 + 0] = start.x + (end.x - start.x) * te;
                    values[i * 3 + 1] = start.y + (end.y - start.y) * te;
                    values[i * 3 + 2] = start.z + (end.z - start.z) * te;
                }

                const positionTrack = new THREE.VectorKeyframeTrack('.position', times, values);
                positionTrack.setInterpolation(THREE.InterpolateSmooth);
                const clip = new THREE.AnimationClip('CameraIntro', duration, [positionTrack]);

                cameraAction = cameraMixer.clipAction(clip);
                cameraAction.setLoop(THREE.LoopOnce, 1);
                cameraAction.clampWhenFinished = true;

                cameraMixer.addEventListener('finished', (event) => {
                    if (event.action === cameraAction) {
                        cameraIntroPlaying = false;
                        updateCameraControlDisplays();
                    }
                });
            }

            camera.position.set(cameraStartPos.x, cameraStartPos.y, cameraStartPos.z);
            controls.target.set(0, 0, 0);
            controls.update();

            if (cameraAction) {
                cameraAction.reset();
                cameraAction.play();
            }

            cameraIntroPlaying = true;

            // Add listener to stop intro on user interaction
            const stopIntroOnInteraction = () => {
                stopCameraIntro();
                controls.domElement.removeEventListener('pointerdown', stopIntroOnInteraction);
            };
            controls.domElement.addEventListener('pointerdown', stopIntroOnInteraction);
            updateCameraControlDisplays();
        }

        function stopCameraIntro() {
            if (!cameraIntroPlaying) return;

            // Just pause the action instead of stopping (stop() resets position)
            if (cameraAction) {
                cameraAction.paused = true;
            }
            cameraIntroPlaying = false;

            // Set fog to final values (no visible fog)
            scene.fog.near = 400;
            scene.fog.far = 600;

            updateCameraControlDisplays();
        }

        function updateCameraControlDisplays() {
            const yActive = posYSlider && document.activeElement === posYSlider;
            if (posYSlider && !yActive) {
                posYSlider.value = Math.round(camera.position.y);
            }
            if (posYValueDisplay && !yActive) {
                posYValueDisplay.textContent = Math.round(camera.position.y);
            }

            const xActive = posXSlider && document.activeElement === posXSlider;
            if (posXSlider && !xActive) {
                posXSlider.value = Math.round(camera.position.x);
            }
            if (posXValueDisplay && !xActive) {
                posXValueDisplay.textContent = Math.round(camera.position.x);
            }
        }

        function updateTerrainHeights() {
            if (!terrainMesh || !heightImageData) return;
            const positions = terrainMesh.geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getY(i);
                const u = (x + 64) / 128;
                const v = (z + 64) / 128;
                const grayscale = sampleHeightmap(u, v);
                const isOcean = grayscale <= seaThreshold;
                const vertexHeight = isOcean ? seaFlatHeight : (grayscale * heightScale + 0.5);
                positions.setZ(i, vertexHeight);
            }
            positions.needsUpdate = true;
            terrainMesh.geometry.computeVertexNormals();
        }

        function applySeaThreshold() {
            updateTerrainHeights();
        }

        function applyHeightScale() {
            updateTerrainHeights();
        }

        function onMouseDown(event) {
            mouseDownPos.x = event.clientX;
            mouseDownPos.y = event.clientY;
            isDragging = false;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Stop camera intro animation if user clicks/drags
            if (cameraIntroPlaying) {
                if (cameraAction) {
                    cameraAction.stop();
                }
                cameraIntroPlaying = false;
                controls.enabled = true;
            }

            // Begin dragging journey marker in edit mode
            if (editMode && journeysVisible) {
                raycaster.setFromCamera(mouse, camera);
                const journeySpheres = journeyMarkers.map(m => m.sphere);
                const journeyIntersects = raycaster.intersectObjects(journeySpheres);
                if (journeyIntersects.length > 0) {
                    const clickedSphere = journeyIntersects[0].object;
                    const marker = journeyMarkers.find(m => m.sphere === clickedSphere);
                    if (marker) {
                        draggingJourneyMarker = marker;
                        setEditingPoint(marker.point);
                        controls.enabled = false;
                    }
                }
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check if mouse moved significantly from mousedown position
            if (mouseDownPos.x !== undefined && mouseDownPos.y !== undefined) {
                const dx = event.clientX - mouseDownPos.x;
                const dy = event.clientY - mouseDownPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 5) { // 5 pixel threshold
                    isDragging = true;
                }
            }

            // Drag journey marker across terrain in edit mode
            if (editMode && draggingJourneyMarker && terrainMesh && heightImageData) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(terrainMesh);
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const terrainHeight = getTerrainHeight(point.x, point.z, heightImageData, heightW, heightH);
                    const markerPoint = draggingJourneyMarker.point;
                    markerPoint.x = point.x;
                    markerPoint.z = point.z;
                    markerPoint.y = terrainHeight + 2;
                    draggingJourneyMarker.sphere.position.set(markerPoint.x, markerPoint.y, markerPoint.z);
                    draggingJourneyMarker.ring.position.set(markerPoint.x, markerPoint.y, markerPoint.z);
                    draggingJourneyMarker.label.position.set(markerPoint.x, markerPoint.y + 3, markerPoint.z);
                }
            }
        }

        function onMouseUp(event) {
            // Reset mousedown position
            mouseDownPos.x = undefined;
            mouseDownPos.y = undefined;

            if (draggingJourneyMarker) {
                draggingJourneyMarker = null;
                rebuildJourneySystem();
                if (!editMode) {
                    controls.enabled = true;
                }
            }

            // Reset after a short delay to allow click event to fire
            setTimeout(() => {
                isDragging = false;
            }, 50);
        }

        function showNotification(success, message) {
            const notification = document.getElementById('notification');
            const icon = notification.querySelector('.icon');
            const messageEl = notification.querySelector('.message');

            // Update content
            icon.textContent = success ? '✓' : '✕';
            messageEl.textContent = message;

            // Update styling and show
            notification.className = success ? 'success visible' : 'error visible';

            // Auto-hide after 2 seconds
            setTimeout(() => {
                notification.classList.remove('visible');
            }, 2000);
        }

        let journeyLoadSuccess = false; // Track if we successfully loaded from JSONBin

        async function loadJourneyData() {
            try {
                const response = await fetch(`${JSONBIN_URL}/latest`, {
                    method: 'GET',
                    headers: {
                        'X-Master-Key': JSONBIN_API_KEY
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    const remoteJourneys = result.record?.journeys;
                    allJourneys = normalizeJourneyData(remoteJourneys);
                    journeyLoadSuccess = true;
                    if (journeysVisible) {
                        journeyPoints = buildJourneyPoints(selectedPersonName);
                        rebuildJourneySystem();
                    }
                    return;
                }
            } catch (e) {
                console.error('Failed to load journeys from JSONBin', e);
            }

            // Load failed - do NOT use defaults, show error
            journeyLoadSuccess = false;
            showNotification(false, 'Failed to load journeys - edits disabled');
        }

        async function saveJourneysToBin() {
            // Prevent saving if initial load failed (would overwrite with defaults)
            if (!journeyLoadSuccess) {
                showNotification(false, 'Cannot save - initial load failed');
                return false;
            }

            // Don't save if nothing was edited
            if (editedPersons.size === 0) {
                console.log('No edits to save');
                return true;
            }

            lastJourneySaveTime = Date.now();
            try {
                // MUST fetch existing data first - abort if this fails
                let existingRecord = null;
                try {
                    const getResponse = await fetch(`${JSONBIN_URL}/latest`, {
                        method: 'GET',
                        headers: {
                            'X-Master-Key': JSONBIN_API_KEY
                        }
                    });
                    if (getResponse.ok) {
                        const result = await getResponse.json();
                        existingRecord = result.record || {};
                    }
                } catch (e) {
                    console.error('Could not fetch existing journeys', e);
                }

                // CRITICAL: If we couldn't fetch existing data, abort save to prevent data loss
                if (existingRecord === null) {
                    showNotification(false, 'Cannot save - failed to fetch current data');
                    return false;
                }

                // Merge: start with remote journeys, then overlay ONLY the persons that were edited
                let remoteJourneys = existingRecord.journeys || {};

                // Migrate old spelling in remote data: lillith -> lilleth
                if (remoteJourneys.lillith) {
                    if (!remoteJourneys.lilleth) {
                        remoteJourneys.lilleth = remoteJourneys.lillith;
                    }
                    delete remoteJourneys.lillith;
                    console.log('Migrated lillith -> lilleth in JSONBin');
                }

                const localJourneys = normalizeJourneyData(allJourneys);

                // Only update persons that were actually edited this session
                const mergedJourneys = { ...remoteJourneys };
                const editedList = Array.from(editedPersons);
                console.log('Saving only edited persons:', editedList);
                editedPersons.forEach(person => {
                    if (localJourneys[person]) {
                        mergedJourneys[person] = localJourneys[person];
                        console.log(`  - Updated ${person}: ${localJourneys[person].length} points`);
                    }
                });

                const nextBody = { ...existingRecord, journeys: mergedJourneys };
                const response = await fetch(JSONBIN_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': JSONBIN_API_KEY
                    },
                    body: JSON.stringify(nextBody)
                });

                if (!response.ok) {
                    showNotification(false, 'Journeys not saved');
                    return false;
                }

                await response.json();
                // Update local state with merged data and clear edited tracking
                allJourneys = normalizeJourneyData(mergedJourneys);
                editedPersons.clear();
                showNotification(true, 'Journeys synced');
                return true;
            } catch (error) {
                console.error('Error saving journeys:', error);
                showNotification(false, 'Journeys not saved');
                return false;
            }
        }

        function syncJourneysFromRemote(remoteJourneys) {
            const normalized = normalizeJourneyData(remoteJourneys);
            const localSerialized = JSON.stringify(allJourneys);
            const remoteSerialized = JSON.stringify(normalized);
            if (localSerialized !== remoteSerialized) {
                allJourneys = normalized;
                if (journeysVisible) {
                    journeyPoints = buildJourneyPoints(selectedPersonName);
                    rebuildJourneySystem();
                }
            }
        }

        function onMouseClick(event) {
            if (cameraIntroPlaying) return; // Don't allow clicks during intro
            if (isDragging) return; // Don't allow selection if dragging
            if (selectedJourneyPoint) return; // Don't allow clicks while viewing journey point

            // Edit mode: select marker for editing instead of triggering gallery
            if (editMode) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const journeySpheres = journeyMarkers.map(m => m.sphere);
                const journeyIntersects = raycaster.intersectObjects(journeySpheres);
                if (journeyIntersects.length > 0) {
                    const clickedSphere = journeyIntersects[0].object;
                    const marker = journeyMarkers.find(m => m.sphere === clickedSphere);
                    if (marker) {
                        setEditingPoint(marker.point);
                        return;
                    }
                }
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check for journey marker clicks
            raycaster.setFromCamera(mouse, camera);
            const journeySpheres = journeyMarkers.map(m => m.sphere);
            const journeyIntersects = raycaster.intersectObjects(journeySpheres);

            if (journeyIntersects.length > 0) {
                const clickedSphere = journeyIntersects[0].object;
                const marker = journeyMarkers.find(m => m.sphere === clickedSphere);
                if (marker) {
                    onJourneyPointClick(marker);
                    return;
                }
            }
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateCameraAnimation(delta) {
            if (!cameraMixer || !cameraAction || !cameraIntroPlaying) return;

            cameraMixer.update(delta);

            updateCameraControlDisplays();

            // Animate fog based on camera Y position
            // At start (y=260): fog near=100, far=200 (heavy fog, 2D look)
            // At end (y=140): fog near=400, far=600 (no visible fog)
            const startY = cameraStartPos.y;
            const endY = cameraEndPos.y;
            const currentY = camera.position.y;

            // Calculate progress (0 at start, 1 at end)
            const progress = Math.max(0, Math.min(1, (startY - currentY) / (startY - endY)));

            // Interpolate fog values
            const fogNearStart = 100;
            const fogNearEnd = 400;
            const fogFarStart = 200;
            const fogFarEnd = 600;

            scene.fog.near = fogNearStart + (fogNearEnd - fogNearStart) * progress;
            scene.fog.far = fogFarStart + (fogFarEnd - fogFarStart) * progress;
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (!journeyTransitioning) {
                controls.update();
            }
            updateCameraAnimation(delta);
            animateJourney();
            updateJourneyCamera();

            // Rotate lights
            const time = Date.now() * 0.0003;
            scene.children.forEach(child => {
                if (child instanceof THREE.PointLight) {
                    const radius = 80;
                    child.position.x = Math.sin(time) * radius;
                    child.position.z = Math.cos(time) * radius;
                }
            });

            // Update wave path animation
            updateWaveAnimation(Date.now() * 0.001);

            // Update wave control point positions if editor is visible
            if (wavePathEditorVisible) {
                updateWaveControlPointPositions();
            }

            composer.render();
            labelRenderer.render(scene, camera);
        }

        init();
        animate();

        // Navigation functions
        function setJourneySelection(selection = 'all') {
            let normalizedSelection = selection === 'all' || allJourneys[selection] ? selection : 'all';
            if (editMode && normalizedSelection === 'all') {
                normalizedSelection = editingPoint?.person || getSortedPeople()[0] || 'all';
            }
            selectedPersonName = normalizedSelection;
            currentPerson = normalizedSelection; // Update currentPerson for marker display

            const overviewBtn = document.getElementById('journey-overview');
            if (overviewBtn) {
                overviewBtn.classList.toggle('selected', normalizedSelection === 'all');
            }

            const popup = document.getElementById('media-popup');
            if (popup) {
                popup.classList.remove('visible');
            }

            document.querySelectorAll('.journey-nav-item').forEach(item => {
                const person = item.getAttribute('data-person');
                item.classList.toggle('selected', person === normalizedSelection);
            });

            // Only build and show journey points if journeys are visible
            if (journeysVisible) {
                journeyPoints = buildJourneyPoints(normalizedSelection);

                if (heightImageData) {
                    clearJourneySystem();
                    createJourneySystem(heightImageData, heightW, heightH);
                    journeyJustBecameVisible = true; // Trigger collision detection on first display
                }
            }
        }

        window.selectPerson = function(personName) {
            // Show journey points when selecting a person
            journeysVisible = true;
            const nextSelection = editMode ? personName : (selectedPersonName === personName ? 'all' : personName);

            // Update overview button state
            const overviewBtn = document.getElementById('overview-btn');
            if (overviewBtn) {
                overviewBtn.classList.remove('selected');
            }

            // Update journey-overview button state based on selection
            const journeyOverviewBtn = document.getElementById('journey-overview');
            if (journeyOverviewBtn) {
                journeyOverviewBtn.classList.toggle('selected', !editMode && nextSelection === 'all');
            }

            setJourneySelection(nextSelection);

            // When editing, refresh the editor to the newly selected person's first point
            if (editMode) {
                if (journeyPoints.length > 0) {
                    setEditingPoint(journeyPoints[0]);
                } else {
                    setEditingPoint(null);
                }
            }
        };

        window.showOverview = function() {
            if (editMode) {
                toggleEditMode(false);
            }
            journeysVisible = false;
            selectedPersonName = 'all';

            // Update button states
            const overviewBtn = document.getElementById('overview-btn');
            if (overviewBtn) {
                overviewBtn.classList.add('selected');
            }

            const aboutBtn = document.getElementById('about-btn');
            if (aboutBtn) {
                aboutBtn.classList.remove('selected');
            }

            const journeyOverviewBtn = document.getElementById('journey-overview');
            if (journeyOverviewBtn) {
                journeyOverviewBtn.classList.remove('selected');
            }

            document.querySelectorAll('.journey-nav-item[data-person]').forEach(item => {
                item.classList.remove('selected');
            });

            // Hide all journey points
            clearJourneySystem();
            journeyPoints = [];
        };

        window.showAbout = function() {
            // Update button states
            const aboutBtn = document.getElementById('about-btn');
            if (aboutBtn) {
                aboutBtn.classList.add('selected');
            }

            const overviewBtn = document.getElementById('overview-btn');
            if (overviewBtn) {
                overviewBtn.classList.remove('selected');
            }

            // TODO: Show about modal or panel
            alert('About JUNK - Coming soon!');
        };

        window.showFullJourney = function() {
            if (editMode) return; // In edit mode stay on a single person
            // Stop intro animation if playing
            stopCameraIntro();

            journeysVisible = true;

            // Update button states
            const overviewBtn = document.getElementById('overview-btn');
            if (overviewBtn) {
                overviewBtn.classList.remove('selected');
            }

            const journeyOverviewBtn = document.getElementById('journey-overview');
            if (journeyOverviewBtn) {
                journeyOverviewBtn.classList.add('selected');
            }

            setJourneySelection('all');

            // Reset camera to intro animation end position
            const targetPos = new THREE.Vector3(cameraEndPos.x, cameraEndPos.y, cameraEndPos.z);
            const targetLookAt = new THREE.Vector3(0, 0, 0);
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();

            let progress = 0;
            const animateCameraReset = () => {
                progress += 0.02;
                if (progress >= 1) {
                    progress = 1;
                }

                const eased = 1 - Math.pow(1 - progress, 3);
                camera.position.lerpVectors(startPos, targetPos, eased);
                controls.target.lerpVectors(startTarget, targetLookAt, eased);
                camera.lookAt(controls.target);

                if (progress < 1) {
                    requestAnimationFrame(animateCameraReset);
                }
            };

            animateCameraReset();
        };
    </script>
</body>
</html>
